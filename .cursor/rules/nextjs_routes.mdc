---
description:
globs:
alwaysApply: false
---
- **Route Handler Type Definitions**
  - Always use explicit type imports from next/server
  - Define route parameter types separately for clarity
  - Use NextRequest instead of Request type
  - Structure context parameters explicitly

  ```typescript
  // ✅ DO: Use explicit types and structured parameters
  import { NextResponse } from 'next/server';
  import type { NextRequest } from 'next/server';

  type RouteParams = { params: { paramName: string } };

  export async function GET(
    request: NextRequest,
    context: RouteParams
  ) {
    const { paramName } = context.params;
    return NextResponse.json({ data: paramName });
  }

  // ❌ DON'T: Use implicit types or destructured parameters
  export async function GET(
    request: Request,
    { params }: { params: { paramName: string } }
  ) {
    return NextResponse.json({ data: params.paramName });
  }
  ```

- **AWS Amplify Compatibility**
  - Known issue with Next.js 15+ type definitions
  - Required explicit type structure for successful builds
  - Avoid parameter destructuring in function signatures
  - Use context object pattern consistently

- **Response Handling**
  - Always use NextResponse.json() for JSON responses
  - Include proper status codes and error handling
  - Type the response data when possible

  ```typescript
  // ✅ DO: Proper response handling with types
  type ResponseData = {
    data?: YourDataType;
    error?: string;
  };

  return NextResponse.json<ResponseData>(
    { data: result },
    { status: 200 }
  );

  // ❌ DON'T: Return raw Response objects
  return new Response(JSON.stringify({ data }));
  ```

- **Error Handling Pattern**
  ```typescript
  // ✅ DO: Structured error handling
  try {
    const result = await yourOperation();
    if (!result) {
      return NextResponse.json(
        { error: 'Not found' },
        { status: 404 }
      );
    }
    return NextResponse.json({ data: result });
  } catch (error) {
    console.error('Operation failed:', error);
    return NextResponse.json(
      { error: 'Operation failed' },
      { status: 500 }
    );
  }
  ```

- **Dynamic Route Parameters**
  - Define specific types for each route parameter
  - Use descriptive names for parameter types
  - Keep parameter types in sync with folder structure

  ```typescript
  // ✅ DO: Clear parameter typing
  type UserRouteParams = { params: { userId: string } };
  type PostRouteParams = { params: { userId: string; postId: string } };

  // For /api/users/[userId]/posts/[postId]
  export async function GET(
    request: NextRequest,
    context: PostRouteParams
  ) {
    const { userId, postId } = context.params;
    // ...
  }
  ```

- **Request Handling**
  - Use NextRequest methods for data extraction
  - Type query parameters when used
  - Handle headers and cookies properly

  ```typescript
  // ✅ DO: Proper request handling
  export async function GET(
    request: NextRequest,
    context: RouteParams
  ) {
    const searchParams = request.nextUrl.searchParams;
    const query = searchParams.get('q');
    const page = parseInt(searchParams.get('page') ?? '1');
    // ...
  }
  ```

- **Middleware Integration**
  - Export middleware config when needed
  - Use proper typing for middleware functions
  - Keep consistent with route handler patterns

  ```typescript
  // ✅ DO: Proper middleware config
  export const config = {
    matcher: '/api/:path*',
  };
  ```

- **Testing Considerations**
  - Mock NextRequest and RouteParams types in tests
  - Test error handling paths
  - Verify response types and structures

- **References**
  - [Next.js Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)
  - [AWS Amplify SSR Support](https://docs.aws.amazon.com/amplify/latest/userguide/ssr-support.html)
