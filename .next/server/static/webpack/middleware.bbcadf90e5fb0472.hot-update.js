"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("middleware",{

/***/ "(middleware)/./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-server-dom-webpack-server.edge.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \n true && function() {\n    function voidHandler() {}\n    function getIteratorFn(maybeIterable) {\n        if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[\"@@iterator\"];\n        return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function _defineProperty(obj, key, value) {\n        a: if (\"object\" == typeof key && key) {\n            var e = key[Symbol.toPrimitive];\n            if (void 0 !== e) {\n                key = e.call(key, \"string\");\n                if (\"object\" != typeof key) break a;\n                throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n            }\n            key = String(key);\n        }\n        key = \"symbol\" == typeof key ? key : key + \"\";\n        key in obj ? Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n        }) : obj[key] = value;\n        return obj;\n    }\n    function handleErrorInNextTick(error) {\n        setTimeoutOrImmediate(function() {\n            throw error;\n        });\n    }\n    function writeChunkAndReturn(destination, chunk) {\n        if (0 !== chunk.byteLength) if (2048 < chunk.byteLength) 0 < writtenBytes && (destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes)), currentView = new Uint8Array(2048), writtenBytes = 0), destination.enqueue(chunk);\n        else {\n            var allowableBytes = currentView.length - writtenBytes;\n            allowableBytes < chunk.byteLength && (0 === allowableBytes ? destination.enqueue(currentView) : (currentView.set(chunk.subarray(0, allowableBytes), writtenBytes), destination.enqueue(currentView), chunk = chunk.subarray(allowableBytes)), currentView = new Uint8Array(2048), writtenBytes = 0);\n            currentView.set(chunk, writtenBytes);\n            writtenBytes += chunk.byteLength;\n        }\n        return !0;\n    }\n    function stringToChunk(content) {\n        return textEncoder.encode(content);\n    }\n    function byteLengthOfChunk(chunk) {\n        return chunk.byteLength;\n    }\n    function closeWithError(destination, error) {\n        \"function\" === typeof destination.error ? destination.error(error) : destination.close();\n    }\n    function isClientReference(reference) {\n        return reference.$$typeof === CLIENT_REFERENCE_TAG$1;\n    }\n    function registerClientReferenceImpl(proxyImplementation, id, async) {\n        return Object.defineProperties(proxyImplementation, {\n            $$typeof: {\n                value: CLIENT_REFERENCE_TAG$1\n            },\n            $$id: {\n                value: id\n            },\n            $$async: {\n                value: async\n            }\n        });\n    }\n    function bind() {\n        var newFn = FunctionBind.apply(this, arguments);\n        if (this.$$typeof === SERVER_REFERENCE_TAG) {\n            null != arguments[0] && console.error('Cannot bind \"this\" of a Server Action. Pass null or undefined as the first argument to .bind().');\n            var args = ArraySlice.call(arguments, 1), $$typeof = {\n                value: SERVER_REFERENCE_TAG\n            }, $$id = {\n                value: this.$$id\n            };\n            args = {\n                value: this.$$bound ? this.$$bound.concat(args) : args\n            };\n            return Object.defineProperties(newFn, {\n                $$typeof: $$typeof,\n                $$id: $$id,\n                $$bound: args,\n                $$location: {\n                    value: this.$$location,\n                    configurable: !0\n                },\n                bind: {\n                    value: bind,\n                    configurable: !0\n                }\n            });\n        }\n        return newFn;\n    }\n    function getReference(target, name) {\n        switch(name){\n            case \"$$typeof\":\n                return target.$$typeof;\n            case \"$$id\":\n                return target.$$id;\n            case \"$$async\":\n                return target.$$async;\n            case \"name\":\n                return target.name;\n            case \"defaultProps\":\n                return;\n            case \"toJSON\":\n                return;\n            case Symbol.toPrimitive:\n                return Object.prototype[Symbol.toPrimitive];\n            case Symbol.toStringTag:\n                return Object.prototype[Symbol.toStringTag];\n            case \"__esModule\":\n                var moduleId = target.$$id;\n                target.default = registerClientReferenceImpl(function() {\n                    throw Error(\"Attempted to call the default export of \" + moduleId + \" from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\");\n                }, target.$$id + \"#\", target.$$async);\n                return !0;\n            case \"then\":\n                if (target.then) return target.then;\n                if (target.$$async) return;\n                var clientReference = registerClientReferenceImpl({}, target.$$id, !0), proxy = new Proxy(clientReference, proxyHandlers$1);\n                target.status = \"fulfilled\";\n                target.value = proxy;\n                return target.then = registerClientReferenceImpl(function(resolve) {\n                    return Promise.resolve(resolve(proxy));\n                }, target.$$id + \"#then\", !1);\n        }\n        if (\"symbol\" === typeof name) throw Error(\"Cannot read Symbol exports. Only named exports are supported on a client module imported on the server.\");\n        clientReference = target[name];\n        clientReference || (clientReference = registerClientReferenceImpl(function() {\n            throw Error(\"Attempted to call \" + String(name) + \"() from the server but \" + String(name) + \" is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\");\n        }, target.$$id + \"#\" + name, target.$$async), Object.defineProperty(clientReference, \"name\", {\n            value: name\n        }), clientReference = target[name] = new Proxy(clientReference, deepProxyHandlers));\n        return clientReference;\n    }\n    function trimOptions(options) {\n        if (null == options) return null;\n        var hasProperties = !1, trimmed = {}, key;\n        for(key in options)null != options[key] && (hasProperties = !0, trimmed[key] = options[key]);\n        return hasProperties ? trimmed : null;\n    }\n    function prepareStackTrace(error, structuredStackTrace) {\n        error = (error.name || \"Error\") + \": \" + (error.message || \"\");\n        for(var i = 0; i < structuredStackTrace.length; i++)error += \"\\n    at \" + structuredStackTrace[i].toString();\n        return error;\n    }\n    function parseStackTrace(error, skipFrames) {\n        a: {\n            var previousPrepare = Error.prepareStackTrace;\n            Error.prepareStackTrace = prepareStackTrace;\n            try {\n                var stack = String(error.stack);\n                break a;\n            } finally{\n                Error.prepareStackTrace = previousPrepare;\n            }\n            stack = void 0;\n        }\n        stack.startsWith(\"Error: react-stack-top-frame\\n\") && (stack = stack.slice(29));\n        error = stack.indexOf(\"react-stack-bottom-frame\");\n        -1 !== error && (error = stack.lastIndexOf(\"\\n\", error));\n        -1 !== error && (stack = stack.slice(0, error));\n        stack = stack.split(\"\\n\");\n        for(error = []; skipFrames < stack.length; skipFrames++)if (previousPrepare = frameRegExp.exec(stack[skipFrames])) {\n            var name = previousPrepare[1] || \"\";\n            \"<anonymous>\" === name && (name = \"\");\n            var filename = previousPrepare[2] || previousPrepare[5] || \"\";\n            \"<anonymous>\" === filename && (filename = \"\");\n            error.push([\n                name,\n                filename,\n                +(previousPrepare[3] || previousPrepare[6]),\n                +(previousPrepare[4] || previousPrepare[7])\n            ]);\n        }\n        return error;\n    }\n    function createTemporaryReference(temporaryReferences, id) {\n        var reference = Object.defineProperties(function() {\n            throw Error(\"Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\");\n        }, {\n            $$typeof: {\n                value: TEMPORARY_REFERENCE_TAG\n            }\n        });\n        reference = new Proxy(reference, proxyHandlers);\n        temporaryReferences.set(reference, id);\n        return reference;\n    }\n    function noop$1() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n        index = thenableState[index];\n        void 0 === index ? thenableState.push(thenable) : index !== thenable && (thenable.then(noop$1, noop$1), thenable = index);\n        switch(thenable.status){\n            case \"fulfilled\":\n                return thenable.value;\n            case \"rejected\":\n                throw thenable.reason;\n            default:\n                \"string\" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenableState = thenable, thenableState.status = \"pending\", thenableState.then(function(fulfilledValue) {\n                    if (\"pending\" === thenable.status) {\n                        var fulfilledThenable = thenable;\n                        fulfilledThenable.status = \"fulfilled\";\n                        fulfilledThenable.value = fulfilledValue;\n                    }\n                }, function(error) {\n                    if (\"pending\" === thenable.status) {\n                        var rejectedThenable = thenable;\n                        rejectedThenable.status = \"rejected\";\n                        rejectedThenable.reason = error;\n                    }\n                }));\n                switch(thenable.status){\n                    case \"fulfilled\":\n                        return thenable.value;\n                    case \"rejected\":\n                        throw thenable.reason;\n                }\n                suspendedThenable = thenable;\n                throw SuspenseException;\n        }\n    }\n    function getSuspendedThenable() {\n        if (null === suspendedThenable) throw Error(\"Expected a suspended thenable. This is a bug in React. Please file an issue.\");\n        var thenable = suspendedThenable;\n        suspendedThenable = null;\n        return thenable;\n    }\n    function getThenableStateAfterSuspending() {\n        var state = thenableState || [];\n        state._componentDebugInfo = currentComponentDebugInfo;\n        thenableState = currentComponentDebugInfo = null;\n        return state;\n    }\n    function unsupportedHook() {\n        throw Error(\"This Hook is not supported in Server Components.\");\n    }\n    function unsupportedRefresh() {\n        throw Error(\"Refreshing the cache is not supported in Server Components.\");\n    }\n    function unsupportedContext() {\n        throw Error(\"Cannot read a Client Context from a Server Component.\");\n    }\n    function resolveOwner() {\n        if (currentOwner) return currentOwner;\n        if (supportsComponentStorage) {\n            var owner = componentStorage.getStore();\n            if (owner) return owner;\n        }\n        return null;\n    }\n    function resetOwnerStackLimit() {\n        var now = getCurrentTime();\n        1e3 < now - lastResetTime && (ReactSharedInternalsServer.recentlyCreatedOwnerStacks = 0, lastResetTime = now);\n    }\n    function isObjectPrototype(object) {\n        if (!object) return !1;\n        var ObjectPrototype = Object.prototype;\n        if (object === ObjectPrototype) return !0;\n        if (getPrototypeOf(object)) return !1;\n        object = Object.getOwnPropertyNames(object);\n        for(var i = 0; i < object.length; i++)if (!(object[i] in ObjectPrototype)) return !1;\n        return !0;\n    }\n    function isSimpleObject(object) {\n        if (!isObjectPrototype(getPrototypeOf(object))) return !1;\n        for(var names = Object.getOwnPropertyNames(object), i = 0; i < names.length; i++){\n            var descriptor = Object.getOwnPropertyDescriptor(object, names[i]);\n            if (!descriptor || !descriptor.enumerable && (\"key\" !== names[i] && \"ref\" !== names[i] || \"function\" !== typeof descriptor.get)) return !1;\n        }\n        return !0;\n    }\n    function objectName(object) {\n        return Object.prototype.toString.call(object).replace(/^\\[object (.*)\\]$/, function(m, p0) {\n            return p0;\n        });\n    }\n    function describeKeyForErrorMessage(key) {\n        var encodedKey = JSON.stringify(key);\n        return '\"' + key + '\"' === encodedKey ? key : encodedKey;\n    }\n    function describeValueForErrorMessage(value) {\n        switch(typeof value){\n            case \"string\":\n                return JSON.stringify(10 >= value.length ? value : value.slice(0, 10) + \"...\");\n            case \"object\":\n                if (isArrayImpl(value)) return \"[...]\";\n                if (null !== value && value.$$typeof === CLIENT_REFERENCE_TAG) return \"client\";\n                value = objectName(value);\n                return \"Object\" === value ? \"{...}\" : value;\n            case \"function\":\n                return value.$$typeof === CLIENT_REFERENCE_TAG ? \"client\" : (value = value.displayName || value.name) ? \"function \" + value : \"function\";\n            default:\n                return String(value);\n        }\n    }\n    function describeElementType(type) {\n        if (\"string\" === typeof type) return type;\n        switch(type){\n            case REACT_SUSPENSE_TYPE:\n                return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n                return \"SuspenseList\";\n        }\n        if (\"object\" === typeof type) switch(type.$$typeof){\n            case REACT_FORWARD_REF_TYPE:\n                return describeElementType(type.render);\n            case REACT_MEMO_TYPE:\n                return describeElementType(type.type);\n            case REACT_LAZY_TYPE:\n                var payload = type._payload;\n                type = type._init;\n                try {\n                    return describeElementType(type(payload));\n                } catch (x) {}\n        }\n        return \"\";\n    }\n    function describeObjectForErrorMessage(objectOrArray, expandedName) {\n        var objKind = objectName(objectOrArray);\n        if (\"Object\" !== objKind && \"Array\" !== objKind) return objKind;\n        var start = -1, length = 0;\n        if (isArrayImpl(objectOrArray)) if (jsxChildrenParents.has(objectOrArray)) {\n            var type = jsxChildrenParents.get(objectOrArray);\n            objKind = \"<\" + describeElementType(type) + \">\";\n            for(var i = 0; i < objectOrArray.length; i++){\n                var value = objectOrArray[i];\n                value = \"string\" === typeof value ? value : \"object\" === typeof value && null !== value ? \"{\" + describeObjectForErrorMessage(value) + \"}\" : \"{\" + describeValueForErrorMessage(value) + \"}\";\n                \"\" + i === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + \"{...}\";\n            }\n            objKind += \"</\" + describeElementType(type) + \">\";\n        } else {\n            objKind = \"[\";\n            for(type = 0; type < objectOrArray.length; type++)0 < type && (objKind += \", \"), i = objectOrArray[type], i = \"object\" === typeof i && null !== i ? describeObjectForErrorMessage(i) : describeValueForErrorMessage(i), \"\" + type === expandedName ? (start = objKind.length, length = i.length, objKind += i) : objKind = 10 > i.length && 40 > objKind.length + i.length ? objKind + i : objKind + \"...\";\n            objKind += \"]\";\n        }\n        else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE) objKind = \"<\" + describeElementType(objectOrArray.type) + \"/>\";\n        else {\n            if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) return \"client\";\n            if (jsxPropsParents.has(objectOrArray)) {\n                objKind = jsxPropsParents.get(objectOrArray);\n                objKind = \"<\" + (describeElementType(objKind) || \"...\");\n                type = Object.keys(objectOrArray);\n                for(i = 0; i < type.length; i++){\n                    objKind += \" \";\n                    value = type[i];\n                    objKind += describeKeyForErrorMessage(value) + \"=\";\n                    var _value2 = objectOrArray[value];\n                    var _substr2 = value === expandedName && \"object\" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);\n                    \"string\" !== typeof _value2 && (_substr2 = \"{\" + _substr2 + \"}\");\n                    value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + \"...\";\n                }\n                objKind += \">\";\n            } else {\n                objKind = \"{\";\n                type = Object.keys(objectOrArray);\n                for(i = 0; i < type.length; i++)0 < i && (objKind += \", \"), value = type[i], objKind += describeKeyForErrorMessage(value) + \": \", _value2 = objectOrArray[value], _value2 = \"object\" === typeof _value2 && null !== _value2 ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + \"...\";\n                objKind += \"}\";\n            }\n        }\n        return void 0 === expandedName ? objKind : -1 < start && 0 < length ? (objectOrArray = \" \".repeat(start) + \"^\".repeat(length), \"\\n  \" + objKind + \"\\n  \" + objectOrArray) : \"\\n  \" + objKind;\n    }\n    function defaultFilterStackFrame(filename) {\n        return \"\" !== filename && !filename.startsWith(\"node:\") && !filename.includes(\"node_modules\");\n    }\n    function filterStackTrace(request, error, skipFrames) {\n        request = request.filterStackFrame;\n        error = parseStackTrace(error, skipFrames);\n        for(skipFrames = 0; skipFrames < error.length; skipFrames++){\n            var callsite = error[skipFrames], functionName = callsite[0], url = callsite[1];\n            if (url.startsWith(\"rsc://React/\")) {\n                var envIdx = url.indexOf(\"/\", 12), suffixIdx = url.lastIndexOf(\"?\");\n                -1 < envIdx && -1 < suffixIdx && (url = callsite[1] = url.slice(envIdx + 1, suffixIdx));\n            }\n            request(url, functionName) || (error.splice(skipFrames, 1), skipFrames--);\n        }\n        return error;\n    }\n    function patchConsole(consoleInst, methodName) {\n        var descriptor = Object.getOwnPropertyDescriptor(consoleInst, methodName);\n        if (descriptor && (descriptor.configurable || descriptor.writable) && \"function\" === typeof descriptor.value) {\n            var originalMethod = descriptor.value;\n            descriptor = Object.getOwnPropertyDescriptor(originalMethod, \"name\");\n            var wrapperMethod = function() {\n                var request = resolveRequest();\n                if ((\"assert\" !== methodName || !arguments[0]) && null !== request) {\n                    var stack = filterStackTrace(request, Error(\"react-stack-top-frame\"), 1);\n                    request.pendingChunks++;\n                    var owner = resolveOwner();\n                    emitConsoleChunk(request, methodName, owner, stack, arguments);\n                }\n                return originalMethod.apply(this, arguments);\n            };\n            descriptor && Object.defineProperty(wrapperMethod, \"name\", descriptor);\n            Object.defineProperty(consoleInst, methodName, {\n                value: wrapperMethod\n            });\n        }\n    }\n    function getCurrentStackInDEV() {\n        var owner = resolveOwner();\n        if (null === owner) return \"\";\n        try {\n            var info = \"\";\n            if (owner.owner || \"string\" !== typeof owner.name) {\n                for(; owner;){\n                    var ownerStack = owner.debugStack;\n                    if (null != ownerStack) {\n                        if (owner = owner.owner) {\n                            var JSCompiler_temp_const = info;\n                            var error = ownerStack, prevPrepareStackTrace = Error.prepareStackTrace;\n                            Error.prepareStackTrace = prepareStackTrace;\n                            var stack = error.stack;\n                            Error.prepareStackTrace = prevPrepareStackTrace;\n                            stack.startsWith(\"Error: react-stack-top-frame\\n\") && (stack = stack.slice(29));\n                            var idx = stack.indexOf(\"\\n\");\n                            -1 !== idx && (stack = stack.slice(idx + 1));\n                            idx = stack.indexOf(\"react-stack-bottom-frame\");\n                            -1 !== idx && (idx = stack.lastIndexOf(\"\\n\", idx));\n                            var JSCompiler_inline_result = -1 !== idx ? stack = stack.slice(0, idx) : \"\";\n                            info = JSCompiler_temp_const + (\"\\n\" + JSCompiler_inline_result);\n                        }\n                    } else break;\n                }\n                var JSCompiler_inline_result$jscomp$0 = info;\n            } else {\n                JSCompiler_temp_const = owner.name;\n                if (void 0 === prefix) try {\n                    throw Error();\n                } catch (x) {\n                    prefix = (error = x.stack.trim().match(/\\n( *(at )?)/)) && error[1] || \"\", suffix = -1 < x.stack.indexOf(\"\\n    at\") ? \" (<anonymous>)\" : -1 < x.stack.indexOf(\"@\") ? \"@unknown:0:0\" : \"\";\n                }\n                JSCompiler_inline_result$jscomp$0 = \"\\n\" + prefix + JSCompiler_temp_const + suffix;\n            }\n        } catch (x) {\n            JSCompiler_inline_result$jscomp$0 = \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n        }\n        return JSCompiler_inline_result$jscomp$0;\n    }\n    function defaultErrorHandler(error) {\n        console.error(error);\n    }\n    function defaultPostponeHandler() {}\n    function RequestInstance(type, model, bundlerConfig, onError, identifierPrefix, onPostpone, temporaryReferences, environmentName, filterStackFrame, onAllReady, onFatalError) {\n        if (null !== ReactSharedInternalsServer.A && ReactSharedInternalsServer.A !== DefaultAsyncDispatcher) throw Error(\"Currently React only supports one RSC renderer at a time.\");\n        ReactSharedInternalsServer.A = DefaultAsyncDispatcher;\n        ReactSharedInternalsServer.getCurrentStack = getCurrentStackInDEV;\n        var abortSet = new Set(), pingedTasks = [], hints = new Set();\n        this.type = type;\n        this.status = OPENING;\n        this.flushScheduled = !1;\n        this.destination = this.fatalError = null;\n        this.bundlerConfig = bundlerConfig;\n        this.cache = new Map();\n        this.pendingChunks = this.nextChunkId = 0;\n        this.hints = hints;\n        this.abortListeners = new Set();\n        this.abortableTasks = abortSet;\n        this.pingedTasks = pingedTasks;\n        this.completedImportChunks = [];\n        this.completedHintChunks = [];\n        this.completedRegularChunks = [];\n        this.completedErrorChunks = [];\n        this.writtenSymbols = new Map();\n        this.writtenClientReferences = new Map();\n        this.writtenServerReferences = new Map();\n        this.writtenObjects = new WeakMap();\n        this.temporaryReferences = temporaryReferences;\n        this.identifierPrefix = identifierPrefix || \"\";\n        this.identifierCount = 1;\n        this.taintCleanupQueue = [];\n        this.onError = void 0 === onError ? defaultErrorHandler : onError;\n        this.onPostpone = void 0 === onPostpone ? defaultPostponeHandler : onPostpone;\n        this.onAllReady = onAllReady;\n        this.onFatalError = onFatalError;\n        this.environmentName = void 0 === environmentName ? function() {\n            return \"Server\";\n        } : \"function\" !== typeof environmentName ? function() {\n            return environmentName;\n        } : environmentName;\n        this.filterStackFrame = void 0 === filterStackFrame ? defaultFilterStackFrame : filterStackFrame;\n        this.didWarnForKey = null;\n        type = createTask(this, model, null, !1, abortSet, null, null, null);\n        pingedTasks.push(type);\n    }\n    function noop() {}\n    function createRequest(model, bundlerConfig, onError, identifierPrefix, onPostpone, temporaryReferences, environmentName, filterStackFrame) {\n        resetOwnerStackLimit();\n        return new RequestInstance(20, model, bundlerConfig, onError, identifierPrefix, onPostpone, temporaryReferences, environmentName, filterStackFrame, noop, noop);\n    }\n    function createPrerenderRequest(model, bundlerConfig, onAllReady, onFatalError, onError, identifierPrefix, onPostpone, temporaryReferences, environmentName, filterStackFrame) {\n        resetOwnerStackLimit();\n        return new RequestInstance(PRERENDER, model, bundlerConfig, onError, identifierPrefix, onPostpone, temporaryReferences, environmentName, filterStackFrame, onAllReady, onFatalError);\n    }\n    function resolveRequest() {\n        if (currentRequest) return currentRequest;\n        if (supportsRequestStorage) {\n            var store = requestStorage.getStore();\n            if (store) return store;\n        }\n        return null;\n    }\n    function serializeThenable(request, task, thenable) {\n        var newTask = createTask(request, null, task.keyPath, task.implicitSlot, request.abortableTasks, task.debugOwner, task.debugStack, task.debugTask);\n        (task = thenable._debugInfo) && forwardDebugInfo(request, newTask.id, task);\n        switch(thenable.status){\n            case \"fulfilled\":\n                return newTask.model = thenable.value, pingTask(request, newTask), newTask.id;\n            case \"rejected\":\n                return erroredTask(request, newTask, thenable.reason), newTask.id;\n            default:\n                if (request.status === ABORTING) return request.abortableTasks.delete(newTask), newTask.status = ABORTED, task = stringify(serializeByValueID(request.fatalError)), emitModelChunk(request, newTask.id, task), newTask.id;\n                \"string\" !== typeof thenable.status && (thenable.status = \"pending\", thenable.then(function(fulfilledValue) {\n                    \"pending\" === thenable.status && (thenable.status = \"fulfilled\", thenable.value = fulfilledValue);\n                }, function(error) {\n                    \"pending\" === thenable.status && (thenable.status = \"rejected\", thenable.reason = error);\n                }));\n        }\n        thenable.then(function(value) {\n            newTask.model = value;\n            pingTask(request, newTask);\n        }, function(reason) {\n            newTask.status === PENDING$1 && (erroredTask(request, newTask, reason), enqueueFlush(request));\n        });\n        return newTask.id;\n    }\n    function serializeReadableStream(request, task, stream) {\n        function progress(entry) {\n            if (!aborted) if (entry.done) request.abortListeners.delete(abortStream), entry = streamTask.id.toString(16) + \":C\\n\", request.completedRegularChunks.push(stringToChunk(entry)), enqueueFlush(request), aborted = !0;\n            else try {\n                streamTask.model = entry.value, request.pendingChunks++, tryStreamTask(request, streamTask), enqueueFlush(request), reader.read().then(progress, error);\n            } catch (x$0) {\n                error(x$0);\n            }\n        }\n        function error(reason) {\n            aborted || (aborted = !0, request.abortListeners.delete(abortStream), erroredTask(request, streamTask, reason), enqueueFlush(request), reader.cancel(reason).then(error, error));\n        }\n        function abortStream(reason) {\n            aborted || (aborted = !0, request.abortListeners.delete(abortStream), erroredTask(request, streamTask, reason), enqueueFlush(request), reader.cancel(reason).then(error, error));\n        }\n        var supportsBYOB = stream.supportsBYOB;\n        if (void 0 === supportsBYOB) try {\n            stream.getReader({\n                mode: \"byob\"\n            }).releaseLock(), supportsBYOB = !0;\n        } catch (x) {\n            supportsBYOB = !1;\n        }\n        var reader = stream.getReader(), streamTask = createTask(request, task.model, task.keyPath, task.implicitSlot, request.abortableTasks, task.debugOwner, task.debugStack, task.debugTask);\n        request.abortableTasks.delete(streamTask);\n        request.pendingChunks++;\n        task = streamTask.id.toString(16) + \":\" + (supportsBYOB ? \"r\" : \"R\") + \"\\n\";\n        request.completedRegularChunks.push(stringToChunk(task));\n        var aborted = !1;\n        request.abortListeners.add(abortStream);\n        reader.read().then(progress, error);\n        return serializeByValueID(streamTask.id);\n    }\n    function serializeAsyncIterable(request, task, iterable, iterator) {\n        function progress(entry) {\n            if (!aborted) if (entry.done) {\n                request.abortListeners.delete(abortIterable);\n                if (void 0 === entry.value) var endStreamRow = streamTask.id.toString(16) + \":C\\n\";\n                else try {\n                    var chunkId = outlineModel(request, entry.value);\n                    endStreamRow = streamTask.id.toString(16) + \":C\" + stringify(serializeByValueID(chunkId)) + \"\\n\";\n                } catch (x) {\n                    error(x);\n                    return;\n                }\n                request.completedRegularChunks.push(stringToChunk(endStreamRow));\n                enqueueFlush(request);\n                aborted = !0;\n            } else try {\n                streamTask.model = entry.value, request.pendingChunks++, tryStreamTask(request, streamTask), enqueueFlush(request), callIteratorInDEV(iterator, progress, error);\n            } catch (x$1) {\n                error(x$1);\n            }\n        }\n        function error(reason) {\n            aborted || (aborted = !0, request.abortListeners.delete(abortIterable), erroredTask(request, streamTask, reason), enqueueFlush(request), \"function\" === typeof iterator.throw && iterator.throw(reason).then(error, error));\n        }\n        function abortIterable(reason) {\n            aborted || (aborted = !0, request.abortListeners.delete(abortIterable), erroredTask(request, streamTask, reason), enqueueFlush(request), \"function\" === typeof iterator.throw && iterator.throw(reason).then(error, error));\n        }\n        var isIterator = iterable === iterator, streamTask = createTask(request, task.model, task.keyPath, task.implicitSlot, request.abortableTasks, task.debugOwner, task.debugStack, task.debugTask);\n        request.abortableTasks.delete(streamTask);\n        request.pendingChunks++;\n        task = streamTask.id.toString(16) + \":\" + (isIterator ? \"x\" : \"X\") + \"\\n\";\n        request.completedRegularChunks.push(stringToChunk(task));\n        (iterable = iterable._debugInfo) && forwardDebugInfo(request, streamTask.id, iterable);\n        var aborted = !1;\n        request.abortListeners.add(abortIterable);\n        callIteratorInDEV(iterator, progress, error);\n        return serializeByValueID(streamTask.id);\n    }\n    function emitHint(request, code, model) {\n        model = stringify(model);\n        code = stringToChunk(\":H\" + code + model + \"\\n\");\n        request.completedHintChunks.push(code);\n        enqueueFlush(request);\n    }\n    function readThenable(thenable) {\n        if (\"fulfilled\" === thenable.status) return thenable.value;\n        if (\"rejected\" === thenable.status) throw thenable.reason;\n        throw thenable;\n    }\n    function createLazyWrapperAroundWakeable(wakeable) {\n        switch(wakeable.status){\n            case \"fulfilled\":\n            case \"rejected\":\n                break;\n            default:\n                \"string\" !== typeof wakeable.status && (wakeable.status = \"pending\", wakeable.then(function(fulfilledValue) {\n                    \"pending\" === wakeable.status && (wakeable.status = \"fulfilled\", wakeable.value = fulfilledValue);\n                }, function(error) {\n                    \"pending\" === wakeable.status && (wakeable.status = \"rejected\", wakeable.reason = error);\n                }));\n        }\n        var lazyType = {\n            $$typeof: REACT_LAZY_TYPE,\n            _payload: wakeable,\n            _init: readThenable\n        };\n        lazyType._debugInfo = wakeable._debugInfo || [];\n        return lazyType;\n    }\n    function callWithDebugContextInDEV(request, task, callback, arg) {\n        var componentDebugInfo = {\n            name: \"\",\n            env: task.environmentName,\n            key: null,\n            owner: task.debugOwner\n        };\n        componentDebugInfo.stack = null === task.debugStack ? null : filterStackTrace(request, task.debugStack, 1);\n        componentDebugInfo.debugStack = task.debugStack;\n        request = componentDebugInfo.debugTask = task.debugTask;\n        currentOwner = componentDebugInfo;\n        try {\n            return request ? request.run(callback.bind(null, arg)) : callback(arg);\n        } finally{\n            currentOwner = null;\n        }\n    }\n    function processServerComponentReturnValue(request, task, Component, result) {\n        if (\"object\" !== typeof result || null === result || isClientReference(result)) return result;\n        if (\"function\" === typeof result.then) return result.then(function(resolvedValue) {\n            \"object\" === typeof resolvedValue && null !== resolvedValue && resolvedValue.$$typeof === REACT_ELEMENT_TYPE && (resolvedValue._store.validated = 1);\n        }, voidHandler), \"fulfilled\" === result.status ? result.value : createLazyWrapperAroundWakeable(result);\n        result.$$typeof === REACT_ELEMENT_TYPE && (result._store.validated = 1);\n        var iteratorFn = getIteratorFn(result);\n        if (iteratorFn) {\n            var multiShot = _defineProperty({}, Symbol.iterator, function() {\n                var iterator = iteratorFn.call(result);\n                iterator !== result || \"[object GeneratorFunction]\" === Object.prototype.toString.call(Component) && \"[object Generator]\" === Object.prototype.toString.call(result) || callWithDebugContextInDEV(request, task, function() {\n                    console.error(\"Returning an Iterator from a Server Component is not supported since it cannot be looped over more than once. \");\n                });\n                return iterator;\n            });\n            multiShot._debugInfo = result._debugInfo;\n            return multiShot;\n        }\n        return \"function\" !== typeof result[ASYNC_ITERATOR] || \"function\" === typeof ReadableStream && result instanceof ReadableStream ? result : (multiShot = _defineProperty({}, ASYNC_ITERATOR, function() {\n            var iterator = result[ASYNC_ITERATOR]();\n            iterator !== result || \"[object AsyncGeneratorFunction]\" === Object.prototype.toString.call(Component) && \"[object AsyncGenerator]\" === Object.prototype.toString.call(result) || callWithDebugContextInDEV(request, task, function() {\n                console.error(\"Returning an AsyncIterator from a Server Component is not supported since it cannot be looped over more than once. \");\n            });\n            return iterator;\n        }), multiShot._debugInfo = result._debugInfo, multiShot);\n    }\n    function renderFunctionComponent(request, task, key, Component, props, validated) {\n        var prevThenableState = task.thenableState;\n        task.thenableState = null;\n        if (null === debugID) return outlineTask(request, task);\n        if (null !== prevThenableState) var componentDebugInfo = prevThenableState._componentDebugInfo;\n        else {\n            var componentDebugID = debugID;\n            componentDebugInfo = Component.displayName || Component.name || \"\";\n            var componentEnv = (0, request.environmentName)();\n            request.pendingChunks++;\n            componentDebugInfo = {\n                name: componentDebugInfo,\n                env: componentEnv,\n                key: key,\n                owner: task.debugOwner\n            };\n            componentDebugInfo.stack = null === task.debugStack ? null : filterStackTrace(request, task.debugStack, 1);\n            componentDebugInfo.props = props;\n            componentDebugInfo.debugStack = task.debugStack;\n            componentDebugInfo.debugTask = task.debugTask;\n            outlineComponentInfo(request, componentDebugInfo);\n            emitDebugChunk(request, componentDebugID, componentDebugInfo);\n            task.environmentName = componentEnv;\n            2 === validated && warnForMissingKey(request, key, componentDebugInfo, task.debugTask);\n        }\n        thenableIndexCounter = 0;\n        thenableState = prevThenableState;\n        currentComponentDebugInfo = componentDebugInfo;\n        props = supportsComponentStorage ? task.debugTask ? task.debugTask.run(componentStorage.run.bind(componentStorage, componentDebugInfo, callComponentInDEV, Component, props, componentDebugInfo)) : componentStorage.run(componentDebugInfo, callComponentInDEV, Component, props, componentDebugInfo) : task.debugTask ? task.debugTask.run(callComponentInDEV.bind(null, Component, props, componentDebugInfo)) : callComponentInDEV(Component, props, componentDebugInfo);\n        if (request.status === ABORTING) throw \"object\" !== typeof props || null === props || \"function\" !== typeof props.then || isClientReference(props) || props.then(voidHandler, voidHandler), null;\n        props = processServerComponentReturnValue(request, task, Component, props);\n        Component = task.keyPath;\n        validated = task.implicitSlot;\n        null !== key ? task.keyPath = null === Component ? key : Component + \",\" + key : null === Component && (task.implicitSlot = !0);\n        request = renderModelDestructive(request, task, emptyRoot, \"\", props);\n        task.keyPath = Component;\n        task.implicitSlot = validated;\n        return request;\n    }\n    function warnForMissingKey(request, key, componentDebugInfo, debugTask) {\n        function logKeyError() {\n            console.error('Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.', \"\", \"\");\n        }\n        key = request.didWarnForKey;\n        null == key && (key = request.didWarnForKey = new WeakSet());\n        request = componentDebugInfo.owner;\n        if (null != request) {\n            if (key.has(request)) return;\n            key.add(request);\n        }\n        supportsComponentStorage ? debugTask ? debugTask.run(componentStorage.run.bind(componentStorage, componentDebugInfo, callComponentInDEV, logKeyError, null, componentDebugInfo)) : componentStorage.run(componentDebugInfo, callComponentInDEV, logKeyError, null, componentDebugInfo) : debugTask ? debugTask.run(callComponentInDEV.bind(null, logKeyError, null, componentDebugInfo)) : callComponentInDEV(logKeyError, null, componentDebugInfo);\n    }\n    function renderFragment(request, task, children) {\n        for(var i = 0; i < children.length; i++){\n            var child = children[i];\n            null === child || \"object\" !== typeof child || child.$$typeof !== REACT_ELEMENT_TYPE || null !== child.key || child._store.validated || (child._store.validated = 2);\n        }\n        if (null !== task.keyPath) return request = [\n            REACT_ELEMENT_TYPE,\n            REACT_FRAGMENT_TYPE,\n            task.keyPath,\n            {\n                children: children\n            },\n            null,\n            null,\n            0\n        ], task.implicitSlot ? [\n            request\n        ] : request;\n        if (i = children._debugInfo) {\n            if (null === debugID) return outlineTask(request, task);\n            forwardDebugInfo(request, debugID, i);\n            children = Array.from(children);\n        }\n        return children;\n    }\n    function renderAsyncFragment(request, task, children, getAsyncIterator) {\n        if (null !== task.keyPath) return request = [\n            REACT_ELEMENT_TYPE,\n            REACT_FRAGMENT_TYPE,\n            task.keyPath,\n            {\n                children: children\n            },\n            null,\n            null,\n            0\n        ], task.implicitSlot ? [\n            request\n        ] : request;\n        getAsyncIterator = getAsyncIterator.call(children);\n        return serializeAsyncIterable(request, task, children, getAsyncIterator);\n    }\n    function outlineTask(request, task) {\n        task = createTask(request, task.model, task.keyPath, task.implicitSlot, request.abortableTasks, task.debugOwner, task.debugStack, task.debugTask);\n        retryTask(request, task);\n        return task.status === COMPLETED ? serializeByValueID(task.id) : \"$L\" + task.id.toString(16);\n    }\n    function renderElement(request, task, type, key, ref, props, validated) {\n        if (null !== ref && void 0 !== ref) throw Error(\"Refs cannot be used in Server Components, nor passed to Client Components.\");\n        jsxPropsParents.set(props, type);\n        \"object\" === typeof props.children && null !== props.children && jsxChildrenParents.set(props.children, type);\n        if (\"function\" !== typeof type || isClientReference(type) || type.$$typeof === TEMPORARY_REFERENCE_TAG) {\n            if (type === REACT_FRAGMENT_TYPE && null === key) return 2 === validated && (validated = {\n                name: \"Fragment\",\n                env: (0, request.environmentName)(),\n                key: key,\n                owner: task.debugOwner,\n                stack: null === task.debugStack ? null : filterStackTrace(request, task.debugStack, 1),\n                props: props,\n                debugStack: task.debugStack,\n                debugTask: task.debugTask\n            }, warnForMissingKey(request, key, validated, task.debugTask)), validated = task.implicitSlot, null === task.keyPath && (task.implicitSlot = !0), request = renderModelDestructive(request, task, emptyRoot, \"\", props.children), task.implicitSlot = validated, request;\n            if (null != type && \"object\" === typeof type && !isClientReference(type)) switch(type.$$typeof){\n                case REACT_LAZY_TYPE:\n                    type = callLazyInitInDEV(type);\n                    if (request.status === ABORTING) throw null;\n                    return renderElement(request, task, type, key, ref, props, validated);\n                case REACT_FORWARD_REF_TYPE:\n                    return renderFunctionComponent(request, task, key, type.render, props, validated);\n                case REACT_MEMO_TYPE:\n                    return renderElement(request, task, type.type, key, ref, props, validated);\n                case REACT_ELEMENT_TYPE:\n                    type._store.validated = 1;\n            }\n        } else return renderFunctionComponent(request, task, key, type, props, validated);\n        ref = task.keyPath;\n        null === key ? key = ref : null !== ref && (key = ref + \",\" + key);\n        null !== task.debugOwner && outlineComponentInfo(request, task.debugOwner);\n        request = [\n            REACT_ELEMENT_TYPE,\n            type,\n            key,\n            props,\n            task.debugOwner,\n            null === task.debugStack ? null : filterStackTrace(request, task.debugStack, 1),\n            validated\n        ];\n        task = task.implicitSlot && null !== key ? [\n            request\n        ] : request;\n        return task;\n    }\n    function pingTask(request, task) {\n        var pingedTasks = request.pingedTasks;\n        pingedTasks.push(task);\n        1 === pingedTasks.length && (request.flushScheduled = null !== request.destination, request.type === PRERENDER || request.status === OPENING ? scheduleMicrotask(function() {\n            return performWork(request);\n        }) : setTimeoutOrImmediate(function() {\n            return performWork(request);\n        }, 0));\n    }\n    function createTask(request, model, keyPath, implicitSlot, abortSet, debugOwner, debugStack, debugTask) {\n        request.pendingChunks++;\n        var id = request.nextChunkId++;\n        \"object\" !== typeof model || null === model || null !== keyPath || implicitSlot || request.writtenObjects.set(model, serializeByValueID(id));\n        var task = {\n            id: id,\n            status: PENDING$1,\n            model: model,\n            keyPath: keyPath,\n            implicitSlot: implicitSlot,\n            ping: function() {\n                return pingTask(request, task);\n            },\n            toJSON: function(parentPropertyName, value) {\n                var parent = this, originalValue = parent[parentPropertyName];\n                \"object\" !== typeof originalValue || originalValue === value || originalValue instanceof Date || callWithDebugContextInDEV(request, task, function() {\n                    \"Object\" !== objectName(originalValue) ? \"string\" === typeof jsxChildrenParents.get(parent) ? console.error(\"%s objects cannot be rendered as text children. Try formatting it using toString().%s\", objectName(originalValue), describeObjectForErrorMessage(parent, parentPropertyName)) : console.error(\"Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s\", objectName(originalValue), describeObjectForErrorMessage(parent, parentPropertyName)) : console.error(\"Only plain objects can be passed to Client Components from Server Components. Objects with toJSON methods are not supported. Convert it manually to a simple value before passing it to props.%s\", describeObjectForErrorMessage(parent, parentPropertyName));\n                });\n                return renderModel(request, task, parent, parentPropertyName, value);\n            },\n            thenableState: null\n        };\n        task.environmentName = request.environmentName();\n        task.debugOwner = debugOwner;\n        task.debugStack = debugStack;\n        task.debugTask = debugTask;\n        abortSet.add(task);\n        return task;\n    }\n    function serializeByValueID(id) {\n        return \"$\" + id.toString(16);\n    }\n    function serializeNumber(number) {\n        return Number.isFinite(number) ? 0 === number && -Infinity === 1 / number ? \"$-0\" : number : Infinity === number ? \"$Infinity\" : -Infinity === number ? \"$-Infinity\" : \"$NaN\";\n    }\n    function encodeReferenceChunk(request, id, reference) {\n        request = stringify(reference);\n        id = id.toString(16) + \":\" + request + \"\\n\";\n        return stringToChunk(id);\n    }\n    function serializeClientReference(request, parent, parentPropertyName, clientReference) {\n        var clientReferenceKey = clientReference.$$async ? clientReference.$$id + \"#async\" : clientReference.$$id, writtenClientReferences = request.writtenClientReferences, existingId = writtenClientReferences.get(clientReferenceKey);\n        if (void 0 !== existingId) return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName ? \"$L\" + existingId.toString(16) : serializeByValueID(existingId);\n        try {\n            var config = request.bundlerConfig, modulePath = clientReference.$$id;\n            existingId = \"\";\n            var resolvedModuleData = config[modulePath];\n            if (resolvedModuleData) existingId = resolvedModuleData.name;\n            else {\n                var idx = modulePath.lastIndexOf(\"#\");\n                -1 !== idx && (existingId = modulePath.slice(idx + 1), resolvedModuleData = config[modulePath.slice(0, idx)]);\n                if (!resolvedModuleData) throw Error('Could not find the module \"' + modulePath + '\" in the React Client Manifest. This is probably a bug in the React Server Components bundler.');\n            }\n            if (!0 === resolvedModuleData.async && !0 === clientReference.$$async) throw Error('The module \"' + modulePath + '\" is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.');\n            var clientReferenceMetadata = !0 === resolvedModuleData.async || !0 === clientReference.$$async ? [\n                resolvedModuleData.id,\n                resolvedModuleData.chunks,\n                existingId,\n                1\n            ] : [\n                resolvedModuleData.id,\n                resolvedModuleData.chunks,\n                existingId\n            ];\n            request.pendingChunks++;\n            var importId = request.nextChunkId++, json = stringify(clientReferenceMetadata), row = importId.toString(16) + \":I\" + json + \"\\n\", processedChunk = stringToChunk(row);\n            request.completedImportChunks.push(processedChunk);\n            writtenClientReferences.set(clientReferenceKey, importId);\n            return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName ? \"$L\" + importId.toString(16) : serializeByValueID(importId);\n        } catch (x) {\n            return request.pendingChunks++, parent = request.nextChunkId++, parentPropertyName = logRecoverableError(request, x, null), emitErrorChunk(request, parent, parentPropertyName, x), serializeByValueID(parent);\n        }\n    }\n    function outlineModel(request, value) {\n        value = createTask(request, value, null, !1, request.abortableTasks, null, null, null);\n        retryTask(request, value);\n        return value.id;\n    }\n    function serializeServerReference(request, serverReference) {\n        var writtenServerReferences = request.writtenServerReferences, existingId = writtenServerReferences.get(serverReference);\n        if (void 0 !== existingId) return \"$F\" + existingId.toString(16);\n        existingId = serverReference.$$bound;\n        existingId = null === existingId ? null : Promise.resolve(existingId);\n        var id = serverReference.$$id, location = null, error = serverReference.$$location;\n        error && (error = parseStackTrace(error, 1), 0 < error.length && (location = error[0]));\n        existingId = null !== location ? {\n            id: id,\n            bound: existingId,\n            name: \"function\" === typeof serverReference ? serverReference.name : \"\",\n            env: (0, request.environmentName)(),\n            location: location\n        } : {\n            id: id,\n            bound: existingId\n        };\n        request = outlineModel(request, existingId);\n        writtenServerReferences.set(serverReference, request);\n        return \"$F\" + request.toString(16);\n    }\n    function serializeLargeTextString(request, text) {\n        request.pendingChunks++;\n        var textId = request.nextChunkId++;\n        emitTextChunk(request, textId, text);\n        return serializeByValueID(textId);\n    }\n    function serializeMap(request, map) {\n        map = Array.from(map);\n        return \"$Q\" + outlineModel(request, map).toString(16);\n    }\n    function serializeFormData(request, formData) {\n        formData = Array.from(formData.entries());\n        return \"$K\" + outlineModel(request, formData).toString(16);\n    }\n    function serializeSet(request, set) {\n        set = Array.from(set);\n        return \"$W\" + outlineModel(request, set).toString(16);\n    }\n    function serializeTypedArray(request, tag, typedArray) {\n        request.pendingChunks++;\n        var bufferId = request.nextChunkId++;\n        emitTypedArrayChunk(request, bufferId, tag, typedArray);\n        return serializeByValueID(bufferId);\n    }\n    function serializeBlob(request, blob) {\n        function progress(entry) {\n            if (!aborted) if (entry.done) request.abortListeners.delete(abortBlob), aborted = !0, pingTask(request, newTask);\n            else return model.push(entry.value), reader.read().then(progress).catch(error);\n        }\n        function error(reason) {\n            aborted || (aborted = !0, request.abortListeners.delete(abortBlob), erroredTask(request, newTask, reason), enqueueFlush(request), reader.cancel(reason).then(error, error));\n        }\n        function abortBlob(reason) {\n            aborted || (aborted = !0, request.abortListeners.delete(abortBlob), erroredTask(request, newTask, reason), enqueueFlush(request), reader.cancel(reason).then(error, error));\n        }\n        var model = [\n            blob.type\n        ], newTask = createTask(request, model, null, !1, request.abortableTasks, null, null, null), reader = blob.stream().getReader(), aborted = !1;\n        request.abortListeners.add(abortBlob);\n        reader.read().then(progress).catch(error);\n        return \"$B\" + newTask.id.toString(16);\n    }\n    function renderModel(request, task, parent, key, value) {\n        var prevKeyPath = task.keyPath, prevImplicitSlot = task.implicitSlot;\n        try {\n            return renderModelDestructive(request, task, parent, key, value);\n        } catch (thrownValue) {\n            parent = task.model;\n            parent = \"object\" === typeof parent && null !== parent && (parent.$$typeof === REACT_ELEMENT_TYPE || parent.$$typeof === REACT_LAZY_TYPE);\n            if (request.status === ABORTING) return task.status = ABORTED, task = request.fatalError, parent ? \"$L\" + task.toString(16) : serializeByValueID(task);\n            key = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;\n            if (\"object\" === typeof key && null !== key && \"function\" === typeof key.then) return request = createTask(request, task.model, task.keyPath, task.implicitSlot, request.abortableTasks, task.debugOwner, task.debugStack, task.debugTask), value = request.ping, key.then(value, value), request.thenableState = getThenableStateAfterSuspending(), task.keyPath = prevKeyPath, task.implicitSlot = prevImplicitSlot, parent ? \"$L\" + request.id.toString(16) : serializeByValueID(request.id);\n            task.keyPath = prevKeyPath;\n            task.implicitSlot = prevImplicitSlot;\n            request.pendingChunks++;\n            prevKeyPath = request.nextChunkId++;\n            task = logRecoverableError(request, key, task);\n            emitErrorChunk(request, prevKeyPath, task, key);\n            return parent ? \"$L\" + prevKeyPath.toString(16) : serializeByValueID(prevKeyPath);\n        }\n    }\n    function renderModelDestructive(request, task, parent, parentPropertyName, value) {\n        task.model = value;\n        if (value === REACT_ELEMENT_TYPE) return \"$\";\n        if (null === value) return null;\n        if (\"object\" === typeof value) {\n            switch(value.$$typeof){\n                case REACT_ELEMENT_TYPE:\n                    var elementReference = null, _writtenObjects = request.writtenObjects;\n                    if (null === task.keyPath && !task.implicitSlot) {\n                        var _existingReference = _writtenObjects.get(value);\n                        if (void 0 !== _existingReference) if (modelRoot === value) modelRoot = null;\n                        else return _existingReference;\n                        else -1 === parentPropertyName.indexOf(\":\") && (_existingReference = _writtenObjects.get(parent), void 0 !== _existingReference && (elementReference = _existingReference + \":\" + parentPropertyName, _writtenObjects.set(value, elementReference)));\n                    }\n                    if (_existingReference = value._debugInfo) {\n                        if (null === debugID) return outlineTask(request, task);\n                        forwardDebugInfo(request, debugID, _existingReference);\n                    }\n                    _existingReference = value.props;\n                    var refProp = _existingReference.ref;\n                    task.debugOwner = value._owner;\n                    task.debugStack = value._debugStack;\n                    task.debugTask = value._debugTask;\n                    request = renderElement(request, task, value.type, value.key, void 0 !== refProp ? refProp : null, _existingReference, value._store.validated);\n                    \"object\" === typeof request && null !== request && null !== elementReference && (_writtenObjects.has(request) || _writtenObjects.set(request, elementReference));\n                    return request;\n                case REACT_LAZY_TYPE:\n                    task.thenableState = null;\n                    elementReference = callLazyInitInDEV(value);\n                    if (request.status === ABORTING) throw null;\n                    if (_writtenObjects = value._debugInfo) {\n                        if (null === debugID) return outlineTask(request, task);\n                        forwardDebugInfo(request, debugID, _writtenObjects);\n                    }\n                    return renderModelDestructive(request, task, emptyRoot, \"\", elementReference);\n                case REACT_LEGACY_ELEMENT_TYPE:\n                    throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\\n- Multiple copies of the \"react\" package is used.\\n- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\\n- A compiler tries to \"inline\" JSX instead of using the runtime.');\n            }\n            if (isClientReference(value)) return serializeClientReference(request, parent, parentPropertyName, value);\n            if (void 0 !== request.temporaryReferences && (elementReference = request.temporaryReferences.get(value), void 0 !== elementReference)) return \"$T\" + elementReference;\n            elementReference = request.writtenObjects;\n            _writtenObjects = elementReference.get(value);\n            if (\"function\" === typeof value.then) {\n                if (void 0 !== _writtenObjects) {\n                    if (null !== task.keyPath || task.implicitSlot) return \"$@\" + serializeThenable(request, task, value).toString(16);\n                    if (modelRoot === value) modelRoot = null;\n                    else return _writtenObjects;\n                }\n                request = \"$@\" + serializeThenable(request, task, value).toString(16);\n                elementReference.set(value, request);\n                return request;\n            }\n            if (void 0 !== _writtenObjects) if (modelRoot === value) modelRoot = null;\n            else return _writtenObjects;\n            else if (-1 === parentPropertyName.indexOf(\":\") && (_writtenObjects = elementReference.get(parent), void 0 !== _writtenObjects)) {\n                _existingReference = parentPropertyName;\n                if (isArrayImpl(parent) && parent[0] === REACT_ELEMENT_TYPE) switch(parentPropertyName){\n                    case \"1\":\n                        _existingReference = \"type\";\n                        break;\n                    case \"2\":\n                        _existingReference = \"key\";\n                        break;\n                    case \"3\":\n                        _existingReference = \"props\";\n                        break;\n                    case \"4\":\n                        _existingReference = \"_owner\";\n                }\n                elementReference.set(value, _writtenObjects + \":\" + _existingReference);\n            }\n            if (isArrayImpl(value)) return renderFragment(request, task, value);\n            if (value instanceof Map) return serializeMap(request, value);\n            if (value instanceof Set) return serializeSet(request, value);\n            if (\"function\" === typeof FormData && value instanceof FormData) return serializeFormData(request, value);\n            if (value instanceof Error) return serializeErrorValue(request, value);\n            if (value instanceof ArrayBuffer) return serializeTypedArray(request, \"A\", new Uint8Array(value));\n            if (value instanceof Int8Array) return serializeTypedArray(request, \"O\", value);\n            if (value instanceof Uint8Array) return serializeTypedArray(request, \"o\", value);\n            if (value instanceof Uint8ClampedArray) return serializeTypedArray(request, \"U\", value);\n            if (value instanceof Int16Array) return serializeTypedArray(request, \"S\", value);\n            if (value instanceof Uint16Array) return serializeTypedArray(request, \"s\", value);\n            if (value instanceof Int32Array) return serializeTypedArray(request, \"L\", value);\n            if (value instanceof Uint32Array) return serializeTypedArray(request, \"l\", value);\n            if (value instanceof Float32Array) return serializeTypedArray(request, \"G\", value);\n            if (value instanceof Float64Array) return serializeTypedArray(request, \"g\", value);\n            if (value instanceof BigInt64Array) return serializeTypedArray(request, \"M\", value);\n            if (value instanceof BigUint64Array) return serializeTypedArray(request, \"m\", value);\n            if (value instanceof DataView) return serializeTypedArray(request, \"V\", value);\n            if (\"function\" === typeof Blob && value instanceof Blob) return serializeBlob(request, value);\n            if (elementReference = getIteratorFn(value)) return elementReference = elementReference.call(value), elementReference === value ? \"$i\" + outlineModel(request, Array.from(elementReference)).toString(16) : renderFragment(request, task, Array.from(elementReference));\n            if (\"function\" === typeof ReadableStream && value instanceof ReadableStream) return serializeReadableStream(request, task, value);\n            elementReference = value[ASYNC_ITERATOR];\n            if (\"function\" === typeof elementReference) return renderAsyncFragment(request, task, value, elementReference);\n            if (value instanceof Date) return \"$D\" + value.toJSON();\n            elementReference = getPrototypeOf(value);\n            if (elementReference !== ObjectPrototype && (null === elementReference || null !== getPrototypeOf(elementReference))) throw Error(\"Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported.\" + describeObjectForErrorMessage(parent, parentPropertyName));\n            if (\"Object\" !== objectName(value)) callWithDebugContextInDEV(request, task, function() {\n                console.error(\"Only plain objects can be passed to Client Components from Server Components. %s objects are not supported.%s\", objectName(value), describeObjectForErrorMessage(parent, parentPropertyName));\n            });\n            else if (!isSimpleObject(value)) callWithDebugContextInDEV(request, task, function() {\n                console.error(\"Only plain objects can be passed to Client Components from Server Components. Classes or other objects with methods are not supported.%s\", describeObjectForErrorMessage(parent, parentPropertyName));\n            });\n            else if (Object.getOwnPropertySymbols) {\n                var symbols = Object.getOwnPropertySymbols(value);\n                0 < symbols.length && callWithDebugContextInDEV(request, task, function() {\n                    console.error(\"Only plain objects can be passed to Client Components from Server Components. Objects with symbol properties like %s are not supported.%s\", symbols[0].description, describeObjectForErrorMessage(parent, parentPropertyName));\n                });\n            }\n            return value;\n        }\n        if (\"string\" === typeof value) return \"Z\" === value[value.length - 1] && parent[parentPropertyName] instanceof Date ? \"$D\" + value : 1024 <= value.length && null !== byteLengthOfChunk ? serializeLargeTextString(request, value) : \"$\" === value[0] ? \"$\" + value : value;\n        if (\"boolean\" === typeof value) return value;\n        if (\"number\" === typeof value) return serializeNumber(value);\n        if (\"undefined\" === typeof value) return \"$undefined\";\n        if (\"function\" === typeof value) {\n            if (isClientReference(value)) return serializeClientReference(request, parent, parentPropertyName, value);\n            if (value.$$typeof === SERVER_REFERENCE_TAG) return serializeServerReference(request, value);\n            if (void 0 !== request.temporaryReferences && (request = request.temporaryReferences.get(value), void 0 !== request)) return \"$T\" + request;\n            if (value.$$typeof === TEMPORARY_REFERENCE_TAG) throw Error(\"Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.\");\n            if (/^on[A-Z]/.test(parentPropertyName)) throw Error(\"Event handlers cannot be passed to Client Component props.\" + describeObjectForErrorMessage(parent, parentPropertyName) + \"\\nIf you need interactivity, consider converting part of this to a Client Component.\");\n            if (jsxChildrenParents.has(parent) || jsxPropsParents.has(parent) && \"children\" === parentPropertyName) throw request = value.displayName || value.name || \"Component\", Error(\"Functions are not valid as a child of Client Components. This may happen if you return \" + request + \" instead of <\" + request + \" /> from render. Or maybe you meant to call this function rather than return it.\" + describeObjectForErrorMessage(parent, parentPropertyName));\n            throw Error('Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with \"use server\". Or maybe you meant to call this function rather than return it.' + describeObjectForErrorMessage(parent, parentPropertyName));\n        }\n        if (\"symbol\" === typeof value) {\n            task = request.writtenSymbols;\n            elementReference = task.get(value);\n            if (void 0 !== elementReference) return serializeByValueID(elementReference);\n            elementReference = value.description;\n            if (Symbol.for(elementReference) !== value) throw Error(\"Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(\" + (value.description + \") cannot be found among global symbols.\") + describeObjectForErrorMessage(parent, parentPropertyName));\n            request.pendingChunks++;\n            _writtenObjects = request.nextChunkId++;\n            emitSymbolChunk(request, _writtenObjects, elementReference);\n            task.set(value, _writtenObjects);\n            return serializeByValueID(_writtenObjects);\n        }\n        if (\"bigint\" === typeof value) return \"$n\" + value.toString(10);\n        throw Error(\"Type \" + typeof value + \" is not supported in Client Component props.\" + describeObjectForErrorMessage(parent, parentPropertyName));\n    }\n    function logRecoverableError(request, error, task) {\n        var prevRequest = currentRequest;\n        currentRequest = null;\n        try {\n            var onError = request.onError;\n            var errorDigest = null !== task ? supportsRequestStorage ? requestStorage.run(void 0, callWithDebugContextInDEV, request, task, onError, error) : callWithDebugContextInDEV(request, task, onError, error) : supportsRequestStorage ? requestStorage.run(void 0, onError, error) : onError(error);\n        } finally{\n            currentRequest = prevRequest;\n        }\n        if (null != errorDigest && \"string\" !== typeof errorDigest) throw Error('onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"' + typeof errorDigest + '\" instead');\n        return errorDigest || \"\";\n    }\n    function fatalError(request, error) {\n        var onFatalError = request.onFatalError;\n        onFatalError(error);\n        null !== request.destination ? (request.status = CLOSED, closeWithError(request.destination, error)) : (request.status = CLOSING, request.fatalError = error);\n    }\n    function serializeErrorValue(request, error) {\n        var name = \"Error\", env = (0, request.environmentName)();\n        try {\n            name = error.name;\n            var message = String(error.message);\n            var stack = filterStackTrace(request, error, 0);\n            var errorEnv = error.environmentName;\n            \"string\" === typeof errorEnv && (env = errorEnv);\n        } catch (x) {\n            message = \"An error occurred but serializing the error message failed.\", stack = [];\n        }\n        return \"$Z\" + outlineModel(request, {\n            name: name,\n            message: message,\n            stack: stack,\n            env: env\n        }).toString(16);\n    }\n    function emitErrorChunk(request, id, digest, error) {\n        var name = \"Error\", env = (0, request.environmentName)();\n        try {\n            if (error instanceof Error) {\n                name = error.name;\n                var message = String(error.message);\n                var stack = filterStackTrace(request, error, 0);\n                var errorEnv = error.environmentName;\n                \"string\" === typeof errorEnv && (env = errorEnv);\n            } else message = \"object\" === typeof error && null !== error ? describeObjectForErrorMessage(error) : String(error), stack = [];\n        } catch (x) {\n            message = \"An error occurred but serializing the error message failed.\", stack = [];\n        }\n        digest = {\n            digest: digest,\n            name: name,\n            message: message,\n            stack: stack,\n            env: env\n        };\n        id = id.toString(16) + \":E\" + stringify(digest) + \"\\n\";\n        id = stringToChunk(id);\n        request.completedErrorChunks.push(id);\n    }\n    function emitSymbolChunk(request, id, name) {\n        id = encodeReferenceChunk(request, id, \"$S\" + name);\n        request.completedImportChunks.push(id);\n    }\n    function emitModelChunk(request, id, json) {\n        id = id.toString(16) + \":\" + json + \"\\n\";\n        id = stringToChunk(id);\n        request.completedRegularChunks.push(id);\n    }\n    function emitDebugChunk(request, id, debugInfo) {\n        var counter = {\n            objectLimit: 500\n        };\n        debugInfo = stringify(debugInfo, function(parentPropertyName, value) {\n            return renderConsoleValue(request, counter, this, parentPropertyName, value);\n        });\n        id = id.toString(16) + \":D\" + debugInfo + \"\\n\";\n        id = stringToChunk(id);\n        request.completedRegularChunks.push(id);\n    }\n    function outlineComponentInfo(request, componentInfo) {\n        if (!request.writtenObjects.has(componentInfo)) {\n            null != componentInfo.owner && outlineComponentInfo(request, componentInfo.owner);\n            var objectLimit = 10;\n            null != componentInfo.stack && (objectLimit += componentInfo.stack.length);\n            objectLimit = {\n                objectLimit: objectLimit\n            };\n            var componentDebugInfo = {\n                name: componentInfo.name,\n                env: componentInfo.env,\n                key: componentInfo.key,\n                owner: componentInfo.owner\n            };\n            componentDebugInfo.stack = componentInfo.stack;\n            componentDebugInfo.props = componentInfo.props;\n            objectLimit = outlineConsoleValue(request, objectLimit, componentDebugInfo);\n            request.writtenObjects.set(componentInfo, serializeByValueID(objectLimit));\n        }\n    }\n    function emitTypedArrayChunk(request, id, tag, typedArray) {\n        request.pendingChunks++;\n        var buffer = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n        typedArray = 2048 < typedArray.byteLength ? buffer.slice() : buffer;\n        buffer = typedArray.byteLength;\n        id = id.toString(16) + \":\" + tag + buffer.toString(16) + \",\";\n        id = stringToChunk(id);\n        request.completedRegularChunks.push(id, typedArray);\n    }\n    function emitTextChunk(request, id, text) {\n        if (null === byteLengthOfChunk) throw Error(\"Existence of byteLengthOfChunk should have already been checked. This is a bug in React.\");\n        request.pendingChunks++;\n        text = stringToChunk(text);\n        var binaryLength = text.byteLength;\n        id = id.toString(16) + \":T\" + binaryLength.toString(16) + \",\";\n        id = stringToChunk(id);\n        request.completedRegularChunks.push(id, text);\n    }\n    function renderConsoleValue(request, counter, parent, parentPropertyName, value) {\n        if (null === value) return null;\n        if (value === REACT_ELEMENT_TYPE) return \"$\";\n        if (\"object\" === typeof value) {\n            if (isClientReference(value)) return serializeClientReference(request, parent, parentPropertyName, value);\n            if (void 0 !== request.temporaryReferences && (parent = request.temporaryReferences.get(value), void 0 !== parent)) return \"$T\" + parent;\n            parent = request.writtenObjects.get(value);\n            if (void 0 !== parent) return parent;\n            if (0 >= counter.objectLimit && !doNotLimit.has(value)) return \"$Y\";\n            counter.objectLimit--;\n            switch(value.$$typeof){\n                case REACT_ELEMENT_TYPE:\n                    null != value._owner && outlineComponentInfo(request, value._owner);\n                    \"object\" === typeof value.type && null !== value.type && doNotLimit.add(value.type);\n                    \"object\" === typeof value.key && null !== value.key && doNotLimit.add(value.key);\n                    doNotLimit.add(value.props);\n                    null !== value._owner && doNotLimit.add(value._owner);\n                    counter = null;\n                    if (null != value._debugStack) for(counter = filterStackTrace(request, value._debugStack, 1), doNotLimit.add(counter), request = 0; request < counter.length; request++)doNotLimit.add(counter[request]);\n                    return [\n                        REACT_ELEMENT_TYPE,\n                        value.type,\n                        value.key,\n                        value.props,\n                        value._owner,\n                        counter,\n                        value._store.validated\n                    ];\n            }\n            if (\"function\" === typeof value.then) {\n                switch(value.status){\n                    case \"fulfilled\":\n                        return \"$@\" + outlineConsoleValue(request, counter, value.value).toString(16);\n                    case \"rejected\":\n                        return counter = value.reason, request.pendingChunks++, value = request.nextChunkId++, emitErrorChunk(request, value, \"\", counter), \"$@\" + value.toString(16);\n                }\n                return \"$@\";\n            }\n            if (isArrayImpl(value)) return value;\n            if (value instanceof Map) {\n                value = Array.from(value);\n                counter.objectLimit++;\n                for(parent = 0; parent < value.length; parent++){\n                    var entry = value[parent];\n                    doNotLimit.add(entry);\n                    parentPropertyName = entry[0];\n                    entry = entry[1];\n                    \"object\" === typeof parentPropertyName && null !== parentPropertyName && doNotLimit.add(parentPropertyName);\n                    \"object\" === typeof entry && null !== entry && doNotLimit.add(entry);\n                }\n                return \"$Q\" + outlineConsoleValue(request, counter, value).toString(16);\n            }\n            if (value instanceof Set) {\n                value = Array.from(value);\n                counter.objectLimit++;\n                for(parent = 0; parent < value.length; parent++)parentPropertyName = value[parent], \"object\" === typeof parentPropertyName && null !== parentPropertyName && doNotLimit.add(parentPropertyName);\n                return \"$W\" + outlineConsoleValue(request, counter, value).toString(16);\n            }\n            return \"function\" === typeof FormData && value instanceof FormData ? serializeFormData(request, value) : value instanceof Error ? serializeErrorValue(request, value) : value instanceof ArrayBuffer ? serializeTypedArray(request, \"A\", new Uint8Array(value)) : value instanceof Int8Array ? serializeTypedArray(request, \"O\", value) : value instanceof Uint8Array ? serializeTypedArray(request, \"o\", value) : value instanceof Uint8ClampedArray ? serializeTypedArray(request, \"U\", value) : value instanceof Int16Array ? serializeTypedArray(request, \"S\", value) : value instanceof Uint16Array ? serializeTypedArray(request, \"s\", value) : value instanceof Int32Array ? serializeTypedArray(request, \"L\", value) : value instanceof Uint32Array ? serializeTypedArray(request, \"l\", value) : value instanceof Float32Array ? serializeTypedArray(request, \"G\", value) : value instanceof Float64Array ? serializeTypedArray(request, \"g\", value) : value instanceof BigInt64Array ? serializeTypedArray(request, \"M\", value) : value instanceof BigUint64Array ? serializeTypedArray(request, \"m\", value) : value instanceof DataView ? serializeTypedArray(request, \"V\", value) : \"function\" === typeof Blob && value instanceof Blob ? serializeBlob(request, value) : getIteratorFn(value) ? Array.from(value) : value;\n        }\n        if (\"string\" === typeof value) return \"Z\" === value[value.length - 1] && parent[parentPropertyName] instanceof Date ? \"$D\" + value : 1024 <= value.length ? serializeLargeTextString(request, value) : \"$\" === value[0] ? \"$\" + value : value;\n        if (\"boolean\" === typeof value) return value;\n        if (\"number\" === typeof value) return serializeNumber(value);\n        if (\"undefined\" === typeof value) return \"$undefined\";\n        if (\"function\" === typeof value) return isClientReference(value) ? serializeClientReference(request, parent, parentPropertyName, value) : void 0 !== request.temporaryReferences && (request = request.temporaryReferences.get(value), void 0 !== request) ? \"$T\" + request : \"$E(\" + (Function.prototype.toString.call(value) + \")\");\n        if (\"symbol\" === typeof value) {\n            counter = request.writtenSymbols.get(value);\n            if (void 0 !== counter) return serializeByValueID(counter);\n            counter = value.description;\n            request.pendingChunks++;\n            value = request.nextChunkId++;\n            emitSymbolChunk(request, value, counter);\n            return serializeByValueID(value);\n        }\n        return \"bigint\" === typeof value ? \"$n\" + value.toString(10) : value instanceof Date ? \"$D\" + value.toJSON() : \"unknown type \" + typeof value;\n    }\n    function outlineConsoleValue(request, counter, model) {\n        function replacer(parentPropertyName, value) {\n            try {\n                return renderConsoleValue(request, counter, this, parentPropertyName, value);\n            } catch (x) {\n                return \"Unknown Value: React could not send it from the server.\\n\" + x.message;\n            }\n        }\n        \"object\" === typeof model && null !== model && doNotLimit.add(model);\n        try {\n            var json = stringify(model, replacer);\n        } catch (x) {\n            json = stringify(\"Unknown Value: React could not send it from the server.\\n\" + x.message);\n        }\n        request.pendingChunks++;\n        model = request.nextChunkId++;\n        json = model.toString(16) + \":\" + json + \"\\n\";\n        json = stringToChunk(json);\n        request.completedRegularChunks.push(json);\n        return model;\n    }\n    function emitConsoleChunk(request, methodName, owner, stackTrace, args) {\n        function replacer(parentPropertyName, value) {\n            try {\n                return renderConsoleValue(request, counter, this, parentPropertyName, value);\n            } catch (x) {\n                return \"Unknown Value: React could not send it from the server.\\n\" + x.message;\n            }\n        }\n        var counter = {\n            objectLimit: 500\n        };\n        null != owner && outlineComponentInfo(request, owner);\n        var env = (0, request.environmentName)(), payload = [\n            methodName,\n            stackTrace,\n            owner,\n            env\n        ];\n        payload.push.apply(payload, args);\n        try {\n            var json = stringify(payload, replacer);\n        } catch (x) {\n            json = stringify([\n                methodName,\n                stackTrace,\n                owner,\n                env,\n                \"Unknown Value: React could not send it from the server.\",\n                x\n            ], replacer);\n        }\n        methodName = stringToChunk(\":W\" + json + \"\\n\");\n        request.completedRegularChunks.push(methodName);\n    }\n    function forwardDebugInfo(request, id, debugInfo) {\n        for(var i = 0; i < debugInfo.length; i++)\"number\" !== typeof debugInfo[i].time && (request.pendingChunks++, \"string\" === typeof debugInfo[i].name && outlineComponentInfo(request, debugInfo[i]), emitDebugChunk(request, id, debugInfo[i]));\n    }\n    function emitChunk(request, task, value) {\n        var id = task.id;\n        \"string\" === typeof value && null !== byteLengthOfChunk ? emitTextChunk(request, id, value) : value instanceof ArrayBuffer ? emitTypedArrayChunk(request, id, \"A\", new Uint8Array(value)) : value instanceof Int8Array ? emitTypedArrayChunk(request, id, \"O\", value) : value instanceof Uint8Array ? emitTypedArrayChunk(request, id, \"o\", value) : value instanceof Uint8ClampedArray ? emitTypedArrayChunk(request, id, \"U\", value) : value instanceof Int16Array ? emitTypedArrayChunk(request, id, \"S\", value) : value instanceof Uint16Array ? emitTypedArrayChunk(request, id, \"s\", value) : value instanceof Int32Array ? emitTypedArrayChunk(request, id, \"L\", value) : value instanceof Uint32Array ? emitTypedArrayChunk(request, id, \"l\", value) : value instanceof Float32Array ? emitTypedArrayChunk(request, id, \"G\", value) : value instanceof Float64Array ? emitTypedArrayChunk(request, id, \"g\", value) : value instanceof BigInt64Array ? emitTypedArrayChunk(request, id, \"M\", value) : value instanceof BigUint64Array ? emitTypedArrayChunk(request, id, \"m\", value) : value instanceof DataView ? emitTypedArrayChunk(request, id, \"V\", value) : (value = stringify(value, task.toJSON), emitModelChunk(request, task.id, value));\n    }\n    function erroredTask(request, task, error) {\n        request.abortableTasks.delete(task);\n        task.status = ERRORED$1;\n        var digest = logRecoverableError(request, error, task);\n        emitErrorChunk(request, task.id, digest, error);\n    }\n    function retryTask(request, task) {\n        if (task.status === PENDING$1) {\n            var prevDebugID = debugID;\n            task.status = RENDERING;\n            try {\n                modelRoot = task.model;\n                debugID = task.id;\n                var resolvedModel = renderModelDestructive(request, task, emptyRoot, \"\", task.model);\n                debugID = null;\n                modelRoot = resolvedModel;\n                task.keyPath = null;\n                task.implicitSlot = !1;\n                var currentEnv = (0, request.environmentName)();\n                currentEnv !== task.environmentName && (request.pendingChunks++, emitDebugChunk(request, task.id, {\n                    env: currentEnv\n                }));\n                if (\"object\" === typeof resolvedModel && null !== resolvedModel) request.writtenObjects.set(resolvedModel, serializeByValueID(task.id)), emitChunk(request, task, resolvedModel);\n                else {\n                    var json = stringify(resolvedModel);\n                    emitModelChunk(request, task.id, json);\n                }\n                request.abortableTasks.delete(task);\n                task.status = COMPLETED;\n            } catch (thrownValue) {\n                if (request.status === ABORTING) {\n                    request.abortableTasks.delete(task);\n                    task.status = ABORTED;\n                    var model = stringify(serializeByValueID(request.fatalError));\n                    emitModelChunk(request, task.id, model);\n                } else {\n                    var x = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;\n                    if (\"object\" === typeof x && null !== x && \"function\" === typeof x.then) {\n                        task.status = PENDING$1;\n                        task.thenableState = getThenableStateAfterSuspending();\n                        var ping = task.ping;\n                        x.then(ping, ping);\n                    } else erroredTask(request, task, x);\n                }\n            } finally{\n                debugID = prevDebugID;\n            }\n        }\n    }\n    function tryStreamTask(request, task) {\n        var prevDebugID = debugID;\n        debugID = null;\n        try {\n            emitChunk(request, task, task.model);\n        } finally{\n            debugID = prevDebugID;\n        }\n    }\n    function performWork(request) {\n        var prevDispatcher = ReactSharedInternalsServer.H;\n        ReactSharedInternalsServer.H = HooksDispatcher;\n        var prevRequest = currentRequest;\n        currentRequest$1 = currentRequest = request;\n        var hadAbortableTasks = 0 < request.abortableTasks.size;\n        try {\n            var pingedTasks = request.pingedTasks;\n            request.pingedTasks = [];\n            for(var i = 0; i < pingedTasks.length; i++)retryTask(request, pingedTasks[i]);\n            null !== request.destination && flushCompletedChunks(request, request.destination);\n            if (hadAbortableTasks && 0 === request.abortableTasks.size) {\n                var onAllReady = request.onAllReady;\n                onAllReady();\n            }\n        } catch (error) {\n            logRecoverableError(request, error, null), fatalError(request, error);\n        } finally{\n            ReactSharedInternalsServer.H = prevDispatcher, currentRequest$1 = null, currentRequest = prevRequest;\n        }\n    }\n    function flushCompletedChunks(request, destination) {\n        currentView = new Uint8Array(2048);\n        writtenBytes = 0;\n        try {\n            for(var importsChunks = request.completedImportChunks, i = 0; i < importsChunks.length; i++)if (request.pendingChunks--, !writeChunkAndReturn(destination, importsChunks[i])) {\n                request.destination = null;\n                i++;\n                break;\n            }\n            importsChunks.splice(0, i);\n            var hintChunks = request.completedHintChunks;\n            for(i = 0; i < hintChunks.length; i++)if (!writeChunkAndReturn(destination, hintChunks[i])) {\n                request.destination = null;\n                i++;\n                break;\n            }\n            hintChunks.splice(0, i);\n            var regularChunks = request.completedRegularChunks;\n            for(i = 0; i < regularChunks.length; i++)if (request.pendingChunks--, !writeChunkAndReturn(destination, regularChunks[i])) {\n                request.destination = null;\n                i++;\n                break;\n            }\n            regularChunks.splice(0, i);\n            var errorChunks = request.completedErrorChunks;\n            for(i = 0; i < errorChunks.length; i++)if (request.pendingChunks--, !writeChunkAndReturn(destination, errorChunks[i])) {\n                request.destination = null;\n                i++;\n                break;\n            }\n            errorChunks.splice(0, i);\n        } finally{\n            request.flushScheduled = !1, currentView && 0 < writtenBytes && (destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes)), currentView = null, writtenBytes = 0);\n        }\n        0 === request.pendingChunks && (request.status = CLOSED, destination.close(), request.destination = null);\n    }\n    function startWork(request) {\n        request.flushScheduled = null !== request.destination;\n        supportsRequestStorage ? scheduleMicrotask(function() {\n            requestStorage.run(request, performWork, request);\n        }) : scheduleMicrotask(function() {\n            return performWork(request);\n        });\n        setTimeoutOrImmediate(function() {\n            request.status === OPENING && (request.status = 11);\n        }, 0);\n    }\n    function enqueueFlush(request) {\n        !1 === request.flushScheduled && 0 === request.pingedTasks.length && null !== request.destination && (request.flushScheduled = !0, setTimeoutOrImmediate(function() {\n            request.flushScheduled = !1;\n            var destination = request.destination;\n            destination && flushCompletedChunks(request, destination);\n        }, 0));\n    }\n    function startFlowing(request, destination) {\n        if (request.status === CLOSING) request.status = CLOSED, closeWithError(destination, request.fatalError);\n        else if (request.status !== CLOSED && null === request.destination) {\n            request.destination = destination;\n            try {\n                flushCompletedChunks(request, destination);\n            } catch (error) {\n                logRecoverableError(request, error, null), fatalError(request, error);\n            }\n        }\n    }\n    function abort(request, reason) {\n        try {\n            11 >= request.status && (request.status = ABORTING);\n            var abortableTasks = request.abortableTasks;\n            if (0 < abortableTasks.size) {\n                var error = void 0 === reason ? Error(\"The render was aborted by the server without a reason.\") : \"object\" === typeof reason && null !== reason && \"function\" === typeof reason.then ? Error(\"The render was aborted by the server with a promise.\") : reason, digest = logRecoverableError(request, error, null), _errorId2 = request.nextChunkId++;\n                request.fatalError = _errorId2;\n                request.pendingChunks++;\n                emitErrorChunk(request, _errorId2, digest, error);\n                abortableTasks.forEach(function(task) {\n                    if (task.status !== RENDERING) {\n                        task.status = ABORTED;\n                        var ref = serializeByValueID(_errorId2);\n                        task = encodeReferenceChunk(request, task.id, ref);\n                        request.completedErrorChunks.push(task);\n                    }\n                });\n                abortableTasks.clear();\n                var onAllReady = request.onAllReady;\n                onAllReady();\n            }\n            var abortListeners = request.abortListeners;\n            if (0 < abortListeners.size) {\n                var _error = void 0 === reason ? Error(\"The render was aborted by the server without a reason.\") : \"object\" === typeof reason && null !== reason && \"function\" === typeof reason.then ? Error(\"The render was aborted by the server with a promise.\") : reason;\n                abortListeners.forEach(function(callback) {\n                    return callback(_error);\n                });\n                abortListeners.clear();\n            }\n            null !== request.destination && flushCompletedChunks(request, request.destination);\n        } catch (error$2) {\n            logRecoverableError(request, error$2, null), fatalError(request, error$2);\n        }\n    }\n    function resolveServerReference(bundlerConfig, id) {\n        var name = \"\", resolvedModuleData = bundlerConfig[id];\n        if (resolvedModuleData) name = resolvedModuleData.name;\n        else {\n            var idx = id.lastIndexOf(\"#\");\n            -1 !== idx && (name = id.slice(idx + 1), resolvedModuleData = bundlerConfig[id.slice(0, idx)]);\n            if (!resolvedModuleData) throw Error('Could not find the module \"' + id + '\" in the React Server Manifest. This is probably a bug in the React Server Components bundler.');\n        }\n        return resolvedModuleData.async ? [\n            resolvedModuleData.id,\n            resolvedModuleData.chunks,\n            name,\n            1\n        ] : [\n            resolvedModuleData.id,\n            resolvedModuleData.chunks,\n            name\n        ];\n    }\n    function requireAsyncModule(id) {\n        var promise = globalThis.__next_require__(id);\n        if (\"function\" !== typeof promise.then || \"fulfilled\" === promise.status) return null;\n        promise.then(function(value) {\n            promise.status = \"fulfilled\";\n            promise.value = value;\n        }, function(reason) {\n            promise.status = \"rejected\";\n            promise.reason = reason;\n        });\n        return promise;\n    }\n    function ignoreReject() {}\n    function preloadModule(metadata) {\n        for(var chunks = metadata[1], promises = [], i = 0; i < chunks.length;){\n            var chunkId = chunks[i++];\n            chunks[i++];\n            var entry = chunkCache.get(chunkId);\n            if (void 0 === entry) {\n                entry = __webpack_require__.e(chunkId);\n                promises.push(entry);\n                var resolve = chunkCache.set.bind(chunkCache, chunkId, null);\n                entry.then(resolve, ignoreReject);\n                chunkCache.set(chunkId, entry);\n            } else null !== entry && promises.push(entry);\n        }\n        return 4 === metadata.length ? 0 === promises.length ? requireAsyncModule(metadata[0]) : Promise.all(promises).then(function() {\n            return requireAsyncModule(metadata[0]);\n        }) : 0 < promises.length ? Promise.all(promises) : null;\n    }\n    function requireModule(metadata) {\n        var moduleExports = globalThis.__next_require__(metadata[0]);\n        if (4 === metadata.length && \"function\" === typeof moduleExports.then) if (\"fulfilled\" === moduleExports.status) moduleExports = moduleExports.value;\n        else throw moduleExports.reason;\n        return \"*\" === metadata[2] ? moduleExports : \"\" === metadata[2] ? moduleExports.__esModule ? moduleExports.default : moduleExports : moduleExports[metadata[2]];\n    }\n    function Chunk(status, value, reason, response) {\n        this.status = status;\n        this.value = value;\n        this.reason = reason;\n        this._response = response;\n    }\n    function createPendingChunk(response) {\n        return new Chunk(\"pending\", null, null, response);\n    }\n    function wakeChunk(listeners, value) {\n        for(var i = 0; i < listeners.length; i++)(0, listeners[i])(value);\n    }\n    function triggerErrorOnChunk(chunk, error) {\n        if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status) chunk.reason.error(error);\n        else {\n            var listeners = chunk.reason;\n            chunk.status = \"rejected\";\n            chunk.reason = error;\n            null !== listeners && wakeChunk(listeners, error);\n        }\n    }\n    function resolveModelChunk(chunk, value, id) {\n        if (\"pending\" !== chunk.status) chunk = chunk.reason, \"C\" === value[0] ? chunk.close(\"C\" === value ? '\"$undefined\"' : value.slice(1)) : chunk.enqueueModel(value);\n        else {\n            var resolveListeners = chunk.value, rejectListeners = chunk.reason;\n            chunk.status = \"resolved_model\";\n            chunk.value = value;\n            chunk.reason = id;\n            if (null !== resolveListeners) switch(initializeModelChunk(chunk), chunk.status){\n                case \"fulfilled\":\n                    wakeChunk(resolveListeners, chunk.value);\n                    break;\n                case \"pending\":\n                case \"blocked\":\n                case \"cyclic\":\n                    if (chunk.value) for(value = 0; value < resolveListeners.length; value++)chunk.value.push(resolveListeners[value]);\n                    else chunk.value = resolveListeners;\n                    if (chunk.reason) {\n                        if (rejectListeners) for(value = 0; value < rejectListeners.length; value++)chunk.reason.push(rejectListeners[value]);\n                    } else chunk.reason = rejectListeners;\n                    break;\n                case \"rejected\":\n                    rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n            }\n        }\n    }\n    function createResolvedIteratorResultChunk(response, value, done) {\n        return new Chunk(\"resolved_model\", (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\", -1, response);\n    }\n    function resolveIteratorResultChunk(chunk, value, done) {\n        resolveModelChunk(chunk, (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\", -1);\n    }\n    function loadServerReference$1(response, id, bound, parentChunk, parentObject, key) {\n        var serverReference = resolveServerReference(response._bundlerConfig, id);\n        id = preloadModule(serverReference);\n        if (bound) bound = Promise.all([\n            bound,\n            id\n        ]).then(function(_ref) {\n            _ref = _ref[0];\n            var fn = requireModule(serverReference);\n            return fn.bind.apply(fn, [\n                null\n            ].concat(_ref));\n        });\n        else if (id) bound = Promise.resolve(id).then(function() {\n            return requireModule(serverReference);\n        });\n        else return requireModule(serverReference);\n        bound.then(createModelResolver(parentChunk, parentObject, key, !1, response, createModel, []), createModelReject(parentChunk));\n        return null;\n    }\n    function reviveModel(response, parentObj, parentKey, value, reference) {\n        if (\"string\" === typeof value) return parseModelString(response, parentObj, parentKey, value, reference);\n        if (\"object\" === typeof value && null !== value) if (void 0 !== reference && void 0 !== response._temporaryReferences && response._temporaryReferences.set(value, reference), Array.isArray(value)) for(var i = 0; i < value.length; i++)value[i] = reviveModel(response, value, \"\" + i, value[i], void 0 !== reference ? reference + \":\" + i : void 0);\n        else for(i in value)hasOwnProperty.call(value, i) && (parentObj = void 0 !== reference && -1 === i.indexOf(\":\") ? reference + \":\" + i : void 0, parentObj = reviveModel(response, value, i, value[i], parentObj), void 0 !== parentObj ? value[i] = parentObj : delete value[i]);\n        return value;\n    }\n    function initializeModelChunk(chunk) {\n        var prevChunk = initializingChunk, prevBlocked = initializingChunkBlockedModel;\n        initializingChunk = chunk;\n        initializingChunkBlockedModel = null;\n        var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16), resolvedModel = chunk.value;\n        chunk.status = \"cyclic\";\n        chunk.value = null;\n        chunk.reason = null;\n        try {\n            var rawModel = JSON.parse(resolvedModel), value = reviveModel(chunk._response, {\n                \"\": rawModel\n            }, \"\", rawModel, rootReference);\n            if (null !== initializingChunkBlockedModel && 0 < initializingChunkBlockedModel.deps) initializingChunkBlockedModel.value = value, chunk.status = \"blocked\";\n            else {\n                var resolveListeners = chunk.value;\n                chunk.status = \"fulfilled\";\n                chunk.value = value;\n                null !== resolveListeners && wakeChunk(resolveListeners, value);\n            }\n        } catch (error) {\n            chunk.status = \"rejected\", chunk.reason = error;\n        } finally{\n            initializingChunk = prevChunk, initializingChunkBlockedModel = prevBlocked;\n        }\n    }\n    function reportGlobalError(response, error) {\n        response._closed = !0;\n        response._closedReason = error;\n        response._chunks.forEach(function(chunk) {\n            \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n        });\n    }\n    function getChunk(response, id) {\n        var chunks = response._chunks, chunk = chunks.get(id);\n        chunk || (chunk = response._formData.get(response._prefix + id), chunk = null != chunk ? new Chunk(\"resolved_model\", chunk, id, response) : response._closed ? new Chunk(\"rejected\", null, response._closedReason, response) : createPendingChunk(response), chunks.set(id, chunk));\n        return chunk;\n    }\n    function createModelResolver(chunk, parentObject, key, cyclic, response, map, path) {\n        if (initializingChunkBlockedModel) {\n            var blocked = initializingChunkBlockedModel;\n            cyclic || blocked.deps++;\n        } else blocked = initializingChunkBlockedModel = {\n            deps: cyclic ? 0 : 1,\n            value: null\n        };\n        return function(value) {\n            for(var i = 1; i < path.length; i++)value = value[path[i]];\n            parentObject[key] = map(response, value);\n            \"\" === key && null === blocked.value && (blocked.value = parentObject[key]);\n            blocked.deps--;\n            0 === blocked.deps && \"blocked\" === chunk.status && (value = chunk.value, chunk.status = \"fulfilled\", chunk.value = blocked.value, null !== value && wakeChunk(value, blocked.value));\n        };\n    }\n    function createModelReject(chunk) {\n        return function(error) {\n            return triggerErrorOnChunk(chunk, error);\n        };\n    }\n    function getOutlinedModel(response, reference, parentObject, key, map) {\n        reference = reference.split(\":\");\n        var id = parseInt(reference[0], 16);\n        id = getChunk(response, id);\n        switch(id.status){\n            case \"resolved_model\":\n                initializeModelChunk(id);\n        }\n        switch(id.status){\n            case \"fulfilled\":\n                parentObject = id.value;\n                for(key = 1; key < reference.length; key++)parentObject = parentObject[reference[key]];\n                return map(response, parentObject);\n            case \"pending\":\n            case \"blocked\":\n            case \"cyclic\":\n                var parentChunk = initializingChunk;\n                id.then(createModelResolver(parentChunk, parentObject, key, \"cyclic\" === id.status, response, map, reference), createModelReject(parentChunk));\n                return null;\n            default:\n                throw id.reason;\n        }\n    }\n    function createMap(response, model) {\n        return new Map(model);\n    }\n    function createSet(response, model) {\n        return new Set(model);\n    }\n    function extractIterator(response, model) {\n        return model[Symbol.iterator]();\n    }\n    function createModel(response, model) {\n        return model;\n    }\n    function parseTypedArray(response, reference, constructor, bytesPerElement, parentObject, parentKey) {\n        reference = parseInt(reference.slice(2), 16);\n        reference = response._formData.get(response._prefix + reference);\n        reference = constructor === ArrayBuffer ? reference.arrayBuffer() : reference.arrayBuffer().then(function(buffer) {\n            return new constructor(buffer);\n        });\n        bytesPerElement = initializingChunk;\n        reference.then(createModelResolver(bytesPerElement, parentObject, parentKey, !1, response, createModel, []), createModelReject(bytesPerElement));\n        return null;\n    }\n    function resolveStream(response, id, stream, controller) {\n        var chunks = response._chunks;\n        stream = new Chunk(\"fulfilled\", stream, controller, response);\n        chunks.set(id, stream);\n        response = response._formData.getAll(response._prefix + id);\n        for(id = 0; id < response.length; id++)chunks = response[id], \"C\" === chunks[0] ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)) : controller.enqueueModel(chunks);\n    }\n    function parseReadableStream(response, reference, type) {\n        reference = parseInt(reference.slice(2), 16);\n        var controller = null;\n        type = new ReadableStream({\n            type: type,\n            start: function(c) {\n                controller = c;\n            }\n        });\n        var previousBlockedChunk = null;\n        resolveStream(response, reference, type, {\n            enqueueModel: function(json) {\n                if (null === previousBlockedChunk) {\n                    var chunk = new Chunk(\"resolved_model\", json, -1, response);\n                    initializeModelChunk(chunk);\n                    \"fulfilled\" === chunk.status ? controller.enqueue(chunk.value) : (chunk.then(function(v) {\n                        return controller.enqueue(v);\n                    }, function(e) {\n                        return controller.error(e);\n                    }), previousBlockedChunk = chunk);\n                } else {\n                    chunk = previousBlockedChunk;\n                    var _chunk = createPendingChunk(response);\n                    _chunk.then(function(v) {\n                        return controller.enqueue(v);\n                    }, function(e) {\n                        return controller.error(e);\n                    });\n                    previousBlockedChunk = _chunk;\n                    chunk.then(function() {\n                        previousBlockedChunk === _chunk && (previousBlockedChunk = null);\n                        resolveModelChunk(_chunk, json, -1);\n                    });\n                }\n            },\n            close: function() {\n                if (null === previousBlockedChunk) controller.close();\n                else {\n                    var blockedChunk = previousBlockedChunk;\n                    previousBlockedChunk = null;\n                    blockedChunk.then(function() {\n                        return controller.close();\n                    });\n                }\n            },\n            error: function(error) {\n                if (null === previousBlockedChunk) controller.error(error);\n                else {\n                    var blockedChunk = previousBlockedChunk;\n                    previousBlockedChunk = null;\n                    blockedChunk.then(function() {\n                        return controller.error(error);\n                    });\n                }\n            }\n        });\n        return type;\n    }\n    function asyncIterator() {\n        return this;\n    }\n    function createIterator(next) {\n        next = {\n            next: next\n        };\n        next[ASYNC_ITERATOR] = asyncIterator;\n        return next;\n    }\n    function parseAsyncIterable(response, reference, iterator) {\n        reference = parseInt(reference.slice(2), 16);\n        var buffer = [], closed = !1, nextWriteIndex = 0, iterable = _defineProperty({}, ASYNC_ITERATOR, function() {\n            var nextReadIndex = 0;\n            return createIterator(function(arg) {\n                if (void 0 !== arg) throw Error(\"Values cannot be passed to next() of AsyncIterables passed to Client Components.\");\n                if (nextReadIndex === buffer.length) {\n                    if (closed) return new Chunk(\"fulfilled\", {\n                        done: !0,\n                        value: void 0\n                    }, null, response);\n                    buffer[nextReadIndex] = createPendingChunk(response);\n                }\n                return buffer[nextReadIndex++];\n            });\n        });\n        iterator = iterator ? iterable[ASYNC_ITERATOR]() : iterable;\n        resolveStream(response, reference, iterator, {\n            enqueueModel: function(value) {\n                nextWriteIndex === buffer.length ? buffer[nextWriteIndex] = createResolvedIteratorResultChunk(response, value, !1) : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n                nextWriteIndex++;\n            },\n            close: function(value) {\n                closed = !0;\n                nextWriteIndex === buffer.length ? buffer[nextWriteIndex] = createResolvedIteratorResultChunk(response, value, !0) : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n                for(nextWriteIndex++; nextWriteIndex < buffer.length;)resolveIteratorResultChunk(buffer[nextWriteIndex++], '\"$undefined\"', !0);\n            },\n            error: function(error) {\n                closed = !0;\n                for(nextWriteIndex === buffer.length && (buffer[nextWriteIndex] = createPendingChunk(response)); nextWriteIndex < buffer.length;)triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n            }\n        });\n        return iterator;\n    }\n    function parseModelString(response, obj, key, value, reference) {\n        if (\"$\" === value[0]) {\n            switch(value[1]){\n                case \"$\":\n                    return value.slice(1);\n                case \"@\":\n                    return obj = parseInt(value.slice(2), 16), getChunk(response, obj);\n                case \"F\":\n                    return value = value.slice(2), value = getOutlinedModel(response, value, obj, key, createModel), loadServerReference$1(response, value.id, value.bound, initializingChunk, obj, key);\n                case \"T\":\n                    if (void 0 === reference || void 0 === response._temporaryReferences) throw Error(\"Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.\");\n                    return createTemporaryReference(response._temporaryReferences, reference);\n                case \"Q\":\n                    return value = value.slice(2), getOutlinedModel(response, value, obj, key, createMap);\n                case \"W\":\n                    return value = value.slice(2), getOutlinedModel(response, value, obj, key, createSet);\n                case \"K\":\n                    obj = value.slice(2);\n                    var formPrefix = response._prefix + obj + \"_\", data = new FormData();\n                    response._formData.forEach(function(entry, entryKey) {\n                        entryKey.startsWith(formPrefix) && data.append(entryKey.slice(formPrefix.length), entry);\n                    });\n                    return data;\n                case \"i\":\n                    return value = value.slice(2), getOutlinedModel(response, value, obj, key, extractIterator);\n                case \"I\":\n                    return Infinity;\n                case \"-\":\n                    return \"$-0\" === value ? -0 : -Infinity;\n                case \"N\":\n                    return NaN;\n                case \"u\":\n                    return;\n                case \"D\":\n                    return new Date(Date.parse(value.slice(2)));\n                case \"n\":\n                    return BigInt(value.slice(2));\n            }\n            switch(value[1]){\n                case \"A\":\n                    return parseTypedArray(response, value, ArrayBuffer, 1, obj, key);\n                case \"O\":\n                    return parseTypedArray(response, value, Int8Array, 1, obj, key);\n                case \"o\":\n                    return parseTypedArray(response, value, Uint8Array, 1, obj, key);\n                case \"U\":\n                    return parseTypedArray(response, value, Uint8ClampedArray, 1, obj, key);\n                case \"S\":\n                    return parseTypedArray(response, value, Int16Array, 2, obj, key);\n                case \"s\":\n                    return parseTypedArray(response, value, Uint16Array, 2, obj, key);\n                case \"L\":\n                    return parseTypedArray(response, value, Int32Array, 4, obj, key);\n                case \"l\":\n                    return parseTypedArray(response, value, Uint32Array, 4, obj, key);\n                case \"G\":\n                    return parseTypedArray(response, value, Float32Array, 4, obj, key);\n                case \"g\":\n                    return parseTypedArray(response, value, Float64Array, 8, obj, key);\n                case \"M\":\n                    return parseTypedArray(response, value, BigInt64Array, 8, obj, key);\n                case \"m\":\n                    return parseTypedArray(response, value, BigUint64Array, 8, obj, key);\n                case \"V\":\n                    return parseTypedArray(response, value, DataView, 1, obj, key);\n                case \"B\":\n                    return obj = parseInt(value.slice(2), 16), response._formData.get(response._prefix + obj);\n            }\n            switch(value[1]){\n                case \"R\":\n                    return parseReadableStream(response, value, void 0);\n                case \"r\":\n                    return parseReadableStream(response, value, \"bytes\");\n                case \"X\":\n                    return parseAsyncIterable(response, value, !1);\n                case \"x\":\n                    return parseAsyncIterable(response, value, !0);\n            }\n            value = value.slice(1);\n            return getOutlinedModel(response, value, obj, key, createModel);\n        }\n        return value;\n    }\n    function createResponse(bundlerConfig, formFieldPrefix, temporaryReferences) {\n        var backingFormData = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : new FormData(), chunks = new Map();\n        return {\n            _bundlerConfig: bundlerConfig,\n            _prefix: formFieldPrefix,\n            _formData: backingFormData,\n            _chunks: chunks,\n            _closed: !1,\n            _closedReason: null,\n            _temporaryReferences: temporaryReferences\n        };\n    }\n    function close(response) {\n        reportGlobalError(response, Error(\"Connection closed.\"));\n    }\n    function loadServerReference(bundlerConfig, id, bound) {\n        var serverReference = resolveServerReference(bundlerConfig, id);\n        bundlerConfig = preloadModule(serverReference);\n        return bound ? Promise.all([\n            bound,\n            bundlerConfig\n        ]).then(function(_ref) {\n            _ref = _ref[0];\n            var fn = requireModule(serverReference);\n            return fn.bind.apply(fn, [\n                null\n            ].concat(_ref));\n        }) : bundlerConfig ? Promise.resolve(bundlerConfig).then(function() {\n            return requireModule(serverReference);\n        }) : Promise.resolve(requireModule(serverReference));\n    }\n    function decodeBoundActionMetaData(body, serverManifest, formFieldPrefix) {\n        body = createResponse(serverManifest, formFieldPrefix, void 0, body);\n        close(body);\n        body = getChunk(body, 0);\n        body.then(function() {});\n        if (\"fulfilled\" !== body.status) throw body.reason;\n        return body.value;\n    }\n    var ReactDOM = __webpack_require__(/*! react-dom */ \"(middleware)/./node_modules/next/dist/compiled/react-dom/react-dom.react-server.js\"), React = __webpack_require__(/*! react */ \"(middleware)/./node_modules/next/dist/compiled/react/react.react-server.js\"), REACT_LEGACY_ELEMENT_TYPE = Symbol.for(\"react.element\"), REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"), REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\");\n    Symbol.for(\"react.postpone\");\n    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, ASYNC_ITERATOR = Symbol.asyncIterator, LocalPromise = Promise, scheduleMicrotask = \"function\" === typeof queueMicrotask ? queueMicrotask : function(callback) {\n        LocalPromise.resolve(null).then(callback).catch(handleErrorInNextTick);\n    }, currentView = null, writtenBytes = 0, textEncoder = new TextEncoder(), CLIENT_REFERENCE_TAG$1 = Symbol.for(\"react.client.reference\"), SERVER_REFERENCE_TAG = Symbol.for(\"react.server.reference\"), FunctionBind = Function.prototype.bind, ArraySlice = Array.prototype.slice, PROMISE_PROTOTYPE = Promise.prototype, deepProxyHandlers = {\n        get: function(target, name) {\n            switch(name){\n                case \"$$typeof\":\n                    return target.$$typeof;\n                case \"$$id\":\n                    return target.$$id;\n                case \"$$async\":\n                    return target.$$async;\n                case \"name\":\n                    return target.name;\n                case \"displayName\":\n                    return;\n                case \"defaultProps\":\n                    return;\n                case \"toJSON\":\n                    return;\n                case Symbol.toPrimitive:\n                    return Object.prototype[Symbol.toPrimitive];\n                case Symbol.toStringTag:\n                    return Object.prototype[Symbol.toStringTag];\n                case \"Provider\":\n                    throw Error(\"Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.\");\n                case \"then\":\n                    throw Error(\"Cannot await or return from a thenable. You cannot await a client module from a server component.\");\n            }\n            throw Error(\"Cannot access \" + (String(target.name) + \".\" + String(name)) + \" on the server. You cannot dot into a client module from a server component. You can only pass the imported name through.\");\n        },\n        set: function() {\n            throw Error(\"Cannot assign to a client module from a server module.\");\n        }\n    }, proxyHandlers$1 = {\n        get: function(target, name) {\n            return getReference(target, name);\n        },\n        getOwnPropertyDescriptor: function(target, name) {\n            var descriptor = Object.getOwnPropertyDescriptor(target, name);\n            descriptor || (descriptor = {\n                value: getReference(target, name),\n                writable: !1,\n                configurable: !1,\n                enumerable: !1\n            }, Object.defineProperty(target, name, descriptor));\n            return descriptor;\n        },\n        getPrototypeOf: function() {\n            return PROMISE_PROTOTYPE;\n        },\n        set: function() {\n            throw Error(\"Cannot assign to a client module from a server module.\");\n        }\n    }, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, previousDispatcher = ReactDOMSharedInternals.d;\n    ReactDOMSharedInternals.d = {\n        f: previousDispatcher.f,\n        r: previousDispatcher.r,\n        D: function(href) {\n            if (\"string\" === typeof href && href) {\n                var request = resolveRequest();\n                if (request) {\n                    var hints = request.hints, key = \"D|\" + href;\n                    hints.has(key) || (hints.add(key), emitHint(request, \"D\", href));\n                } else previousDispatcher.D(href);\n            }\n        },\n        C: function(href, crossOrigin) {\n            if (\"string\" === typeof href) {\n                var request = resolveRequest();\n                if (request) {\n                    var hints = request.hints, key = \"C|\" + (null == crossOrigin ? \"null\" : crossOrigin) + \"|\" + href;\n                    hints.has(key) || (hints.add(key), \"string\" === typeof crossOrigin ? emitHint(request, \"C\", [\n                        href,\n                        crossOrigin\n                    ]) : emitHint(request, \"C\", href));\n                } else previousDispatcher.C(href, crossOrigin);\n            }\n        },\n        L: function(href, as, options) {\n            if (\"string\" === typeof href) {\n                var request = resolveRequest();\n                if (request) {\n                    var hints = request.hints, key = \"L\";\n                    if (\"image\" === as && options) {\n                        var imageSrcSet = options.imageSrcSet, imageSizes = options.imageSizes, uniquePart = \"\";\n                        \"string\" === typeof imageSrcSet && \"\" !== imageSrcSet ? (uniquePart += \"[\" + imageSrcSet + \"]\", \"string\" === typeof imageSizes && (uniquePart += \"[\" + imageSizes + \"]\")) : uniquePart += \"[][]\" + href;\n                        key += \"[image]\" + uniquePart;\n                    } else key += \"[\" + as + \"]\" + href;\n                    hints.has(key) || (hints.add(key), (options = trimOptions(options)) ? emitHint(request, \"L\", [\n                        href,\n                        as,\n                        options\n                    ]) : emitHint(request, \"L\", [\n                        href,\n                        as\n                    ]));\n                } else previousDispatcher.L(href, as, options);\n            }\n        },\n        m: function(href, options) {\n            if (\"string\" === typeof href) {\n                var request = resolveRequest();\n                if (request) {\n                    var hints = request.hints, key = \"m|\" + href;\n                    if (hints.has(key)) return;\n                    hints.add(key);\n                    return (options = trimOptions(options)) ? emitHint(request, \"m\", [\n                        href,\n                        options\n                    ]) : emitHint(request, \"m\", href);\n                }\n                previousDispatcher.m(href, options);\n            }\n        },\n        X: function(src, options) {\n            if (\"string\" === typeof src) {\n                var request = resolveRequest();\n                if (request) {\n                    var hints = request.hints, key = \"X|\" + src;\n                    if (hints.has(key)) return;\n                    hints.add(key);\n                    return (options = trimOptions(options)) ? emitHint(request, \"X\", [\n                        src,\n                        options\n                    ]) : emitHint(request, \"X\", src);\n                }\n                previousDispatcher.X(src, options);\n            }\n        },\n        S: function(href, precedence, options) {\n            if (\"string\" === typeof href) {\n                var request = resolveRequest();\n                if (request) {\n                    var hints = request.hints, key = \"S|\" + href;\n                    if (hints.has(key)) return;\n                    hints.add(key);\n                    return (options = trimOptions(options)) ? emitHint(request, \"S\", [\n                        href,\n                        \"string\" === typeof precedence ? precedence : 0,\n                        options\n                    ]) : \"string\" === typeof precedence ? emitHint(request, \"S\", [\n                        href,\n                        precedence\n                    ]) : emitHint(request, \"S\", href);\n                }\n                previousDispatcher.S(href, precedence, options);\n            }\n        },\n        M: function(src, options) {\n            if (\"string\" === typeof src) {\n                var request = resolveRequest();\n                if (request) {\n                    var hints = request.hints, key = \"M|\" + src;\n                    if (hints.has(key)) return;\n                    hints.add(key);\n                    return (options = trimOptions(options)) ? emitHint(request, \"M\", [\n                        src,\n                        options\n                    ]) : emitHint(request, \"M\", src);\n                }\n                previousDispatcher.M(src, options);\n            }\n        }\n    };\n    var frameRegExp = /^ {3} at (?:(.+) \\((?:(.+):(\\d+):(\\d+)|<anonymous>)\\)|(?:async )?(.+):(\\d+):(\\d+)|<anonymous>)$/, supportsRequestStorage = \"function\" === typeof AsyncLocalStorage, requestStorage = supportsRequestStorage ? new AsyncLocalStorage() : null, supportsComponentStorage = supportsRequestStorage, componentStorage = supportsComponentStorage ? new AsyncLocalStorage() : null;\n    \"object\" === typeof async_hooks ? async_hooks.createHook : function() {\n        return {\n            enable: function() {},\n            disable: function() {}\n        };\n    };\n    \"object\" === typeof async_hooks ? async_hooks.executionAsyncId : null;\n    var TEMPORARY_REFERENCE_TAG = Symbol.for(\"react.temporary.reference\"), proxyHandlers = {\n        get: function(target, name) {\n            switch(name){\n                case \"$$typeof\":\n                    return target.$$typeof;\n                case \"name\":\n                    return;\n                case \"displayName\":\n                    return;\n                case \"defaultProps\":\n                    return;\n                case \"toJSON\":\n                    return;\n                case Symbol.toPrimitive:\n                    return Object.prototype[Symbol.toPrimitive];\n                case Symbol.toStringTag:\n                    return Object.prototype[Symbol.toStringTag];\n                case \"Provider\":\n                    throw Error(\"Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.\");\n            }\n            throw Error(\"Cannot access \" + String(name) + \" on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client.\");\n        },\n        set: function() {\n            throw Error(\"Cannot assign to a temporary client reference from a server module.\");\n        }\n    }, SuspenseException = Error(\"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.\"), suspendedThenable = null, currentRequest$1 = null, thenableIndexCounter = 0, thenableState = null, currentComponentDebugInfo = null, HooksDispatcher = {\n        readContext: unsupportedContext,\n        use: function(usable) {\n            if (null !== usable && \"object\" === typeof usable || \"function\" === typeof usable) {\n                if (\"function\" === typeof usable.then) {\n                    var index = thenableIndexCounter;\n                    thenableIndexCounter += 1;\n                    null === thenableState && (thenableState = []);\n                    return trackUsedThenable(thenableState, usable, index);\n                }\n                usable.$$typeof === REACT_CONTEXT_TYPE && unsupportedContext();\n            }\n            if (isClientReference(usable)) {\n                if (null != usable.value && usable.value.$$typeof === REACT_CONTEXT_TYPE) throw Error(\"Cannot read a Client Context from a Server Component.\");\n                throw Error(\"Cannot use() an already resolved Client Reference.\");\n            }\n            throw Error(\"An unsupported type was passed to use(): \" + String(usable));\n        },\n        useCallback: function(callback) {\n            return callback;\n        },\n        useContext: unsupportedContext,\n        useEffect: unsupportedHook,\n        useImperativeHandle: unsupportedHook,\n        useLayoutEffect: unsupportedHook,\n        useInsertionEffect: unsupportedHook,\n        useMemo: function(nextCreate) {\n            return nextCreate();\n        },\n        useReducer: unsupportedHook,\n        useRef: unsupportedHook,\n        useState: unsupportedHook,\n        useDebugValue: function() {},\n        useDeferredValue: unsupportedHook,\n        useTransition: unsupportedHook,\n        useSyncExternalStore: unsupportedHook,\n        useId: function() {\n            if (null === currentRequest$1) throw Error(\"useId can only be used while React is rendering\");\n            var id = currentRequest$1.identifierCount++;\n            return \":\" + currentRequest$1.identifierPrefix + \"S\" + id.toString(32) + \":\";\n        },\n        useHostTransitionStatus: unsupportedHook,\n        useFormState: unsupportedHook,\n        useActionState: unsupportedHook,\n        useOptimistic: unsupportedHook,\n        useMemoCache: function(size) {\n            for(var data = Array(size), i = 0; i < size; i++)data[i] = REACT_MEMO_CACHE_SENTINEL;\n            return data;\n        },\n        useCacheRefresh: function() {\n            return unsupportedRefresh;\n        }\n    }, currentOwner = null, DefaultAsyncDispatcher = {\n        getCacheForType: function(resourceType) {\n            var cache = (cache = resolveRequest()) ? cache.cache : new Map();\n            var entry = cache.get(resourceType);\n            void 0 === entry && (entry = resourceType(), cache.set(resourceType, entry));\n            return entry;\n        }\n    };\n    DefaultAsyncDispatcher.getOwner = resolveOwner;\n    var ReactSharedInternalsServer = React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n    if (!ReactSharedInternalsServer) throw Error('The \"react\" package in this environment is not configured correctly. The \"react-server\" condition must be enabled in any environment that runs React Server Components.');\n    var prefix, suffix;\n    new (\"function\" === typeof WeakMap ? WeakMap : Map)();\n    var lastResetTime = 0;\n    if (\"object\" === typeof performance && \"function\" === typeof performance.now) {\n        var localPerformance = performance;\n        var getCurrentTime = function() {\n            return localPerformance.now();\n        };\n    } else {\n        var localDate = Date;\n        getCurrentTime = function() {\n            return localDate.now();\n        };\n    }\n    var callComponent = {\n        \"react-stack-bottom-frame\": function(Component, props, componentDebugInfo) {\n            currentOwner = componentDebugInfo;\n            try {\n                return Component(props, void 0);\n            } finally{\n                currentOwner = null;\n            }\n        }\n    }, callComponentInDEV = callComponent[\"react-stack-bottom-frame\"].bind(callComponent), callLazyInit = {\n        \"react-stack-bottom-frame\": function(lazy) {\n            var init = lazy._init;\n            return init(lazy._payload);\n        }\n    }, callLazyInitInDEV = callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit), callIterator = {\n        \"react-stack-bottom-frame\": function(iterator, progress, error) {\n            iterator.next().then(progress, error);\n        }\n    }, callIteratorInDEV = callIterator[\"react-stack-bottom-frame\"].bind(callIterator), isArrayImpl = Array.isArray, getPrototypeOf = Object.getPrototypeOf, jsxPropsParents = new WeakMap(), jsxChildrenParents = new WeakMap(), CLIENT_REFERENCE_TAG = Symbol.for(\"react.client.reference\"), doNotLimit = new WeakSet();\n    \"object\" === typeof console && null !== console && (patchConsole(console, \"assert\"), patchConsole(console, \"debug\"), patchConsole(console, \"dir\"), patchConsole(console, \"dirxml\"), patchConsole(console, \"error\"), patchConsole(console, \"group\"), patchConsole(console, \"groupCollapsed\"), patchConsole(console, \"groupEnd\"), patchConsole(console, \"info\"), patchConsole(console, \"log\"), patchConsole(console, \"table\"), patchConsole(console, \"trace\"), patchConsole(console, \"warn\"));\n    var ObjectPrototype = Object.prototype, stringify = JSON.stringify, PENDING$1 = 0, COMPLETED = 1, ABORTED = 3, ERRORED$1 = 4, RENDERING = 5, OPENING = 10, ABORTING = 12, CLOSING = 13, CLOSED = 14, PRERENDER = 21, currentRequest = null, debugID = null, modelRoot = !1, emptyRoot = {}, chunkCache = new Map(), hasOwnProperty = Object.prototype.hasOwnProperty;\n    Chunk.prototype = Object.create(Promise.prototype);\n    Chunk.prototype.then = function(resolve, reject) {\n        switch(this.status){\n            case \"resolved_model\":\n                initializeModelChunk(this);\n        }\n        switch(this.status){\n            case \"fulfilled\":\n                resolve(this.value);\n                break;\n            case \"pending\":\n            case \"blocked\":\n            case \"cyclic\":\n                resolve && (null === this.value && (this.value = []), this.value.push(resolve));\n                reject && (null === this.reason && (this.reason = []), this.reason.push(reject));\n                break;\n            default:\n                reject(this.reason);\n        }\n    };\n    var initializingChunk = null, initializingChunkBlockedModel = null;\n    exports.createClientModuleProxy = function(moduleId) {\n        moduleId = registerClientReferenceImpl({}, moduleId, !1);\n        return new Proxy(moduleId, proxyHandlers$1);\n    };\n    exports.createTemporaryReferenceSet = function() {\n        return new WeakMap();\n    };\n    exports.decodeAction = function(body, serverManifest) {\n        var formData = new FormData(), action = null;\n        body.forEach(function(value, key) {\n            key.startsWith(\"$ACTION_\") ? key.startsWith(\"$ACTION_REF_\") ? (value = \"$ACTION_\" + key.slice(12) + \":\", value = decodeBoundActionMetaData(body, serverManifest, value), action = loadServerReference(serverManifest, value.id, value.bound)) : key.startsWith(\"$ACTION_ID_\") && (value = key.slice(11), action = loadServerReference(serverManifest, value, null)) : formData.append(key, value);\n        });\n        return null === action ? null : action.then(function(fn) {\n            return fn.bind(null, formData);\n        });\n    };\n    exports.decodeFormState = function(actionResult, body, serverManifest) {\n        var keyPath = body.get(\"$ACTION_KEY\");\n        if (\"string\" !== typeof keyPath) return Promise.resolve(null);\n        var metaData = null;\n        body.forEach(function(value, key) {\n            key.startsWith(\"$ACTION_REF_\") && (value = \"$ACTION_\" + key.slice(12) + \":\", metaData = decodeBoundActionMetaData(body, serverManifest, value));\n        });\n        if (null === metaData) return Promise.resolve(null);\n        var referenceId = metaData.id;\n        return Promise.resolve(metaData.bound).then(function(bound) {\n            return null === bound ? null : [\n                actionResult,\n                keyPath,\n                referenceId,\n                bound.length - 1\n            ];\n        });\n    };\n    exports.decodeReply = function(body, webpackMap, options) {\n        if (\"string\" === typeof body) {\n            var form = new FormData();\n            form.append(\"0\", body);\n            body = form;\n        }\n        body = createResponse(webpackMap, \"\", options ? options.temporaryReferences : void 0, body);\n        webpackMap = getChunk(body, 0);\n        close(body);\n        return webpackMap;\n    };\n    exports.decodeReplyFromAsyncIterable = function(iterable, webpackMap, options) {\n        function progress(entry) {\n            if (entry.done) close(response$jscomp$0);\n            else {\n                entry = entry.value;\n                var name = entry[0];\n                entry = entry[1];\n                if (\"string\" === typeof entry) {\n                    var response = response$jscomp$0;\n                    response._formData.append(name, entry);\n                    var prefix = response._prefix;\n                    name.startsWith(prefix) && (response = response._chunks, name = +name.slice(prefix.length), (prefix = response.get(name)) && resolveModelChunk(prefix, entry, name));\n                } else response$jscomp$0._formData.append(name, entry);\n                iterator.next().then(progress, error);\n            }\n        }\n        function error(reason) {\n            reportGlobalError(response$jscomp$0, reason);\n            \"function\" === typeof iterator.throw && iterator.throw(reason).then(error, error);\n        }\n        var iterator = iterable[ASYNC_ITERATOR](), response$jscomp$0 = createResponse(webpackMap, \"\", options ? options.temporaryReferences : void 0);\n        iterator.next().then(progress, error);\n        return getChunk(response$jscomp$0, 0);\n    };\n    exports.registerClientReference = function(proxyImplementation, id, exportName) {\n        return registerClientReferenceImpl(proxyImplementation, id + \"#\" + exportName, !1);\n    };\n    exports.registerServerReference = function(reference, id, exportName) {\n        return Object.defineProperties(reference, {\n            $$typeof: {\n                value: SERVER_REFERENCE_TAG\n            },\n            $$id: {\n                value: null === exportName ? id : id + \"#\" + exportName,\n                configurable: !0\n            },\n            $$bound: {\n                value: null,\n                configurable: !0\n            },\n            $$location: {\n                value: Error(\"react-stack-top-frame\"),\n                configurable: !0\n            },\n            bind: {\n                value: bind,\n                configurable: !0\n            }\n        });\n    };\n    // This is a patch added by Next.js\n    const setTimeoutOrImmediate = typeof globalThis['set' + 'Immediate'] === 'function' && // edge runtime sandbox defines a stub for setImmediate\n    // (see 'addStub' in packages/next/src/server/web/sandbox/context.ts)\n    // but it's made non-enumerable, so we can detect it\n    globalThis.propertyIsEnumerable('setImmediate') ? globalThis['set' + 'Immediate'] : setTimeout;\n    exports.renderToReadableStream = function(model, webpackMap, options) {\n        var request = createRequest(model, webpackMap, options ? options.onError : void 0, options ? options.identifierPrefix : void 0, options ? options.onPostpone : void 0, options ? options.temporaryReferences : void 0, options ? options.environmentName : void 0, options ? options.filterStackFrame : void 0);\n        if (options && options.signal) {\n            var signal = options.signal;\n            if (signal.aborted) abort(request, signal.reason);\n            else {\n                var listener = function() {\n                    abort(request, signal.reason);\n                    signal.removeEventListener(\"abort\", listener);\n                };\n                signal.addEventListener(\"abort\", listener);\n            }\n        }\n        return new ReadableStream({\n            type: \"bytes\",\n            start: function() {\n                startWork(request);\n            },\n            pull: function(controller) {\n                startFlowing(request, controller);\n            },\n            cancel: function(reason) {\n                request.destination = null;\n                abort(request, reason);\n            }\n        }, {\n            highWaterMark: 0\n        });\n    };\n    exports.unstable_prerender = function(model, webpackMap, options) {\n        return new Promise(function(resolve, reject) {\n            var request = createPrerenderRequest(model, webpackMap, function() {\n                var stream = new ReadableStream({\n                    type: \"bytes\",\n                    start: function() {\n                        startWork(request);\n                    },\n                    pull: function(controller) {\n                        startFlowing(request, controller);\n                    },\n                    cancel: function(reason) {\n                        request.destination = null;\n                        abort(request, reason);\n                    }\n                }, {\n                    highWaterMark: 0\n                });\n                resolve({\n                    prelude: stream\n                });\n            }, reject, options ? options.onError : void 0, options ? options.identifierPrefix : void 0, options ? options.onPostpone : void 0, options ? options.temporaryReferences : void 0, options ? options.environmentName : void 0, options ? options.filterStackFrame : void 0);\n            if (options && options.signal) {\n                var signal = options.signal;\n                if (signal.aborted) abort(request, signal.reason);\n                else {\n                    var listener = function() {\n                        abort(request, signal.reason);\n                        signal.removeEventListener(\"abort\", listener);\n                    };\n                    signal.addEventListener(\"abort\", listener);\n                }\n            }\n            startWork(request);\n        });\n    };\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2pzL3JlYWN0LXNlcnZlci1kb20td2VicGFjay1zZXJ2ZXIuZWRnZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVZO0FBQ2IsS0F3ZitFLElBdmY3RTtJQUNFLFNBQVNBLGVBQWU7SUFDeEIsU0FBU0MsY0FBY0MsYUFBYTtRQUNsQyxJQUFJLFNBQVNBLGlCQUFpQixhQUFhLE9BQU9BLGVBQ2hELE9BQU87UUFDVEEsZ0JBQ0UseUJBQTBCQSxhQUFhLENBQUNDLHNCQUFzQixJQUM5REQsYUFBYSxDQUFDLGFBQWE7UUFDN0IsT0FBTyxlQUFlLE9BQU9BLGdCQUFnQkEsZ0JBQWdCO0lBQy9EO0lBQ0EsU0FBU0UsZ0JBQWdCQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztRQUN0Q0MsR0FBRyxJQUFJLFlBQVksT0FBT0YsT0FBT0EsS0FBSztZQUNwQyxJQUFJRyxJQUFJSCxHQUFHLENBQUNJLE9BQU9DLFdBQVcsQ0FBQztZQUMvQixJQUFJLEtBQUssTUFBTUYsR0FBRztnQkFDaEJILE1BQU1HLEVBQUVHLElBQUksQ0FBQ04sS0FBSztnQkFDbEIsSUFBSSxZQUFZLE9BQU9BLEtBQUssTUFBTUU7Z0JBQ2xDLE1BQU0sSUFBSUssVUFBVTtZQUN0QjtZQUNBUCxNQUFNUSxPQUFPUjtRQUNmO1FBQ0FBLE1BQU0sWUFBWSxPQUFPQSxNQUFNQSxNQUFNQSxNQUFNO1FBQzNDQSxPQUFPRCxNQUNIVSxPQUFPQyxjQUFjLENBQUNYLEtBQUtDLEtBQUs7WUFDOUJDLE9BQU9BO1lBQ1BVLFlBQVksQ0FBQztZQUNiQyxjQUFjLENBQUM7WUFDZkMsVUFBVSxDQUFDO1FBQ2IsS0FDQ2QsR0FBRyxDQUFDQyxJQUFJLEdBQUdDO1FBQ2hCLE9BQU9GO0lBQ1Q7SUFDQSxTQUFTZSxzQkFBc0JDLEtBQUs7UUFDbENDLHNC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bmV4dFxcZGlzdFxcY29tcGlsZWRcXHJlYWN0LXNlcnZlci1kb20td2VicGFja1xcY2pzXFxyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2stc2VydmVyLmVkZ2UuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrLXNlcnZlci5lZGdlLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHZvaWRIYW5kbGVyKCkge31cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICAgIGlmIChudWxsID09PSBtYXliZUl0ZXJhYmxlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIG1heWJlSXRlcmFibGUgPVxuICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgbWF5YmVJdGVyYWJsZVtcIkBAaXRlcmF0b3JcIl07XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSA/IG1heWJlSXRlcmFibGUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICBhOiBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2Yga2V5ICYmIGtleSkge1xuICAgICAgICB2YXIgZSA9IGtleVtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgICAgICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgICAgICAga2V5ID0gZS5jYWxsKGtleSwgXCJzdHJpbmdcIik7XG4gICAgICAgICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGtleSkgYnJlYWsgYTtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gU3RyaW5nKGtleSk7XG4gICAgICB9XG4gICAgICBrZXkgPSBcInN5bWJvbFwiID09IHR5cGVvZiBrZXkgPyBrZXkgOiBrZXkgKyBcIlwiO1xuICAgICAga2V5IGluIG9ialxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfSlcbiAgICAgICAgOiAob2JqW2tleV0gPSB2YWx1ZSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvckluTmV4dFRpY2soZXJyb3IpIHtcbiAgICAgIHNldFRpbWVvdXRPckltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNodW5rKSB7XG4gICAgICBpZiAoMCAhPT0gY2h1bmsuYnl0ZUxlbmd0aClcbiAgICAgICAgaWYgKDIwNDggPCBjaHVuay5ieXRlTGVuZ3RoKVxuICAgICAgICAgIDAgPCB3cml0dGVuQnl0ZXMgJiZcbiAgICAgICAgICAgIChkZXN0aW5hdGlvbi5lbnF1ZXVlKFxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShjdXJyZW50Vmlldy5idWZmZXIsIDAsIHdyaXR0ZW5CeXRlcylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheSgyMDQ4KSksXG4gICAgICAgICAgICAod3JpdHRlbkJ5dGVzID0gMCkpLFxuICAgICAgICAgICAgZGVzdGluYXRpb24uZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhbGxvd2FibGVCeXRlcyA9IGN1cnJlbnRWaWV3Lmxlbmd0aCAtIHdyaXR0ZW5CeXRlcztcbiAgICAgICAgICBhbGxvd2FibGVCeXRlcyA8IGNodW5rLmJ5dGVMZW5ndGggJiZcbiAgICAgICAgICAgICgwID09PSBhbGxvd2FibGVCeXRlc1xuICAgICAgICAgICAgICA/IGRlc3RpbmF0aW9uLmVucXVldWUoY3VycmVudFZpZXcpXG4gICAgICAgICAgICAgIDogKGN1cnJlbnRWaWV3LnNldChcbiAgICAgICAgICAgICAgICAgIGNodW5rLnN1YmFycmF5KDAsIGFsbG93YWJsZUJ5dGVzKSxcbiAgICAgICAgICAgICAgICAgIHdyaXR0ZW5CeXRlc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZW5xdWV1ZShjdXJyZW50VmlldyksXG4gICAgICAgICAgICAgICAgKGNodW5rID0gY2h1bmsuc3ViYXJyYXkoYWxsb3dhYmxlQnl0ZXMpKSksXG4gICAgICAgICAgICAoY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheSgyMDQ4KSksXG4gICAgICAgICAgICAod3JpdHRlbkJ5dGVzID0gMCkpO1xuICAgICAgICAgIGN1cnJlbnRWaWV3LnNldChjaHVuaywgd3JpdHRlbkJ5dGVzKTtcbiAgICAgICAgICB3cml0dGVuQnl0ZXMgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdUb0NodW5rKGNvbnRlbnQpIHtcbiAgICAgIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGhPZkNodW5rKGNodW5rKSB7XG4gICAgICByZXR1cm4gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvc2VXaXRoRXJyb3IoZGVzdGluYXRpb24sIGVycm9yKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBkZXN0aW5hdGlvbi5lcnJvclxuICAgICAgICA/IGRlc3RpbmF0aW9uLmVycm9yKGVycm9yKVxuICAgICAgICA6IGRlc3RpbmF0aW9uLmNsb3NlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ2xpZW50UmVmZXJlbmNlKHJlZmVyZW5jZSkge1xuICAgICAgcmV0dXJuIHJlZmVyZW5jZS4kJHR5cGVvZiA9PT0gQ0xJRU5UX1JFRkVSRU5DRV9UQUckMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJDbGllbnRSZWZlcmVuY2VJbXBsKHByb3h5SW1wbGVtZW50YXRpb24sIGlkLCBhc3luYykge1xuICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb3h5SW1wbGVtZW50YXRpb24sIHtcbiAgICAgICAgJCR0eXBlb2Y6IHsgdmFsdWU6IENMSUVOVF9SRUZFUkVOQ0VfVEFHJDEgfSxcbiAgICAgICAgJCRpZDogeyB2YWx1ZTogaWQgfSxcbiAgICAgICAgJCRhc3luYzogeyB2YWx1ZTogYXN5bmMgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgICB2YXIgbmV3Rm4gPSBGdW5jdGlvbkJpbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLiQkdHlwZW9mID09PSBTRVJWRVJfUkVGRVJFTkNFX1RBRykge1xuICAgICAgICBudWxsICE9IGFyZ3VtZW50c1swXSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQ2Fubm90IGJpbmQgXCJ0aGlzXCIgb2YgYSBTZXJ2ZXIgQWN0aW9uLiBQYXNzIG51bGwgb3IgdW5kZWZpbmVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byAuYmluZCgpLidcbiAgICAgICAgICApO1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICQkdHlwZW9mID0geyB2YWx1ZTogU0VSVkVSX1JFRkVSRU5DRV9UQUcgfSxcbiAgICAgICAgICAkJGlkID0geyB2YWx1ZTogdGhpcy4kJGlkIH07XG4gICAgICAgIGFyZ3MgPSB7IHZhbHVlOiB0aGlzLiQkYm91bmQgPyB0aGlzLiQkYm91bmQuY29uY2F0KGFyZ3MpIDogYXJncyB9O1xuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobmV3Rm4sIHtcbiAgICAgICAgICAkJHR5cGVvZjogJCR0eXBlb2YsXG4gICAgICAgICAgJCRpZDogJCRpZCxcbiAgICAgICAgICAkJGJvdW5kOiBhcmdzLFxuICAgICAgICAgICQkbG9jYXRpb246IHsgdmFsdWU6IHRoaXMuJCRsb2NhdGlvbiwgY29uZmlndXJhYmxlOiAhMCB9LFxuICAgICAgICAgIGJpbmQ6IHsgdmFsdWU6IGJpbmQsIGNvbmZpZ3VyYWJsZTogITAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdGbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmVmZXJlbmNlKHRhcmdldCwgbmFtZSkge1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgXCIkJHR5cGVvZlwiOlxuICAgICAgICAgIHJldHVybiB0YXJnZXQuJCR0eXBlb2Y7XG4gICAgICAgIGNhc2UgXCIkJGlkXCI6XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC4kJGlkO1xuICAgICAgICBjYXNlIFwiJCRhc3luY1wiOlxuICAgICAgICAgIHJldHVybiB0YXJnZXQuJCRhc3luYztcbiAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0Lm5hbWU7XG4gICAgICAgIGNhc2UgXCJkZWZhdWx0UHJvcHNcIjpcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJ0b0pTT05cIjpcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgU3ltYm9sLnRvUHJpbWl0aXZlOlxuICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gICAgICAgIGNhc2UgU3ltYm9sLnRvU3RyaW5nVGFnOlxuICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ107XG4gICAgICAgIGNhc2UgXCJfX2VzTW9kdWxlXCI6XG4gICAgICAgICAgdmFyIG1vZHVsZUlkID0gdGFyZ2V0LiQkaWQ7XG4gICAgICAgICAgdGFyZ2V0LmRlZmF1bHQgPSByZWdpc3RlckNsaWVudFJlZmVyZW5jZUltcGwoXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQXR0ZW1wdGVkIHRvIGNhbGwgdGhlIGRlZmF1bHQgZXhwb3J0IG9mIFwiICtcbiAgICAgICAgICAgICAgICAgIG1vZHVsZUlkICtcbiAgICAgICAgICAgICAgICAgIFwiIGZyb20gdGhlIHNlcnZlciBidXQgaXQncyBvbiB0aGUgY2xpZW50LiBJdCdzIG5vdCBwb3NzaWJsZSB0byBpbnZva2UgYSBjbGllbnQgZnVuY3Rpb24gZnJvbSB0aGUgc2VydmVyLCBpdCBjYW4gb25seSBiZSByZW5kZXJlZCBhcyBhIENvbXBvbmVudCBvciBwYXNzZWQgdG8gcHJvcHMgb2YgYSBDbGllbnQgQ29tcG9uZW50LlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGFyZ2V0LiQkaWQgKyBcIiNcIixcbiAgICAgICAgICAgIHRhcmdldC4kJGFzeW5jXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIGNhc2UgXCJ0aGVuXCI6XG4gICAgICAgICAgaWYgKHRhcmdldC50aGVuKSByZXR1cm4gdGFyZ2V0LnRoZW47XG4gICAgICAgICAgaWYgKHRhcmdldC4kJGFzeW5jKSByZXR1cm47XG4gICAgICAgICAgdmFyIGNsaWVudFJlZmVyZW5jZSA9IHJlZ2lzdGVyQ2xpZW50UmVmZXJlbmNlSW1wbChcbiAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgIHRhcmdldC4kJGlkLFxuICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHByb3h5ID0gbmV3IFByb3h5KGNsaWVudFJlZmVyZW5jZSwgcHJveHlIYW5kbGVycyQxKTtcbiAgICAgICAgICB0YXJnZXQuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgICAgICB0YXJnZXQudmFsdWUgPSBwcm94eTtcbiAgICAgICAgICByZXR1cm4gKHRhcmdldC50aGVuID0gcmVnaXN0ZXJDbGllbnRSZWZlcmVuY2VJbXBsKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNvbHZlKHByb3h5KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGFyZ2V0LiQkaWQgKyBcIiN0aGVuXCIsXG4gICAgICAgICAgICAhMVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgaWYgKFwic3ltYm9sXCIgPT09IHR5cGVvZiBuYW1lKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkNhbm5vdCByZWFkIFN5bWJvbCBleHBvcnRzLiBPbmx5IG5hbWVkIGV4cG9ydHMgYXJlIHN1cHBvcnRlZCBvbiBhIGNsaWVudCBtb2R1bGUgaW1wb3J0ZWQgb24gdGhlIHNlcnZlci5cIlxuICAgICAgICApO1xuICAgICAgY2xpZW50UmVmZXJlbmNlID0gdGFyZ2V0W25hbWVdO1xuICAgICAgY2xpZW50UmVmZXJlbmNlIHx8XG4gICAgICAgICgoY2xpZW50UmVmZXJlbmNlID0gcmVnaXN0ZXJDbGllbnRSZWZlcmVuY2VJbXBsKFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkF0dGVtcHRlZCB0byBjYWxsIFwiICtcbiAgICAgICAgICAgICAgICBTdHJpbmcobmFtZSkgK1xuICAgICAgICAgICAgICAgIFwiKCkgZnJvbSB0aGUgc2VydmVyIGJ1dCBcIiArXG4gICAgICAgICAgICAgICAgU3RyaW5nKG5hbWUpICtcbiAgICAgICAgICAgICAgICBcIiBpcyBvbiB0aGUgY2xpZW50LiBJdCdzIG5vdCBwb3NzaWJsZSB0byBpbnZva2UgYSBjbGllbnQgZnVuY3Rpb24gZnJvbSB0aGUgc2VydmVyLCBpdCBjYW4gb25seSBiZSByZW5kZXJlZCBhcyBhIENvbXBvbmVudCBvciBwYXNzZWQgdG8gcHJvcHMgb2YgYSBDbGllbnQgQ29tcG9uZW50LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGFyZ2V0LiQkaWQgKyBcIiNcIiArIG5hbWUsXG4gICAgICAgICAgdGFyZ2V0LiQkYXN5bmNcbiAgICAgICAgKSksXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGllbnRSZWZlcmVuY2UsIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lIH0pLFxuICAgICAgICAoY2xpZW50UmVmZXJlbmNlID0gdGFyZ2V0W25hbWVdID1cbiAgICAgICAgICBuZXcgUHJveHkoY2xpZW50UmVmZXJlbmNlLCBkZWVwUHJveHlIYW5kbGVycykpKTtcbiAgICAgIHJldHVybiBjbGllbnRSZWZlcmVuY2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyaW1PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChudWxsID09IG9wdGlvbnMpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGhhc1Byb3BlcnRpZXMgPSAhMSxcbiAgICAgICAgdHJpbW1lZCA9IHt9LFxuICAgICAgICBrZXk7XG4gICAgICBmb3IgKGtleSBpbiBvcHRpb25zKVxuICAgICAgICBudWxsICE9IG9wdGlvbnNba2V5XSAmJlxuICAgICAgICAgICgoaGFzUHJvcGVydGllcyA9ICEwKSwgKHRyaW1tZWRba2V5XSA9IG9wdGlvbnNba2V5XSkpO1xuICAgICAgcmV0dXJuIGhhc1Byb3BlcnRpZXMgPyB0cmltbWVkIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZVN0YWNrVHJhY2UoZXJyb3IsIHN0cnVjdHVyZWRTdGFja1RyYWNlKSB7XG4gICAgICBlcnJvciA9IChlcnJvci5uYW1lIHx8IFwiRXJyb3JcIikgKyBcIjogXCIgKyAoZXJyb3IubWVzc2FnZSB8fCBcIlwiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RydWN0dXJlZFN0YWNrVHJhY2UubGVuZ3RoOyBpKyspXG4gICAgICAgIGVycm9yICs9IFwiXFxuICAgIGF0IFwiICsgc3RydWN0dXJlZFN0YWNrVHJhY2VbaV0udG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VTdGFja1RyYWNlKGVycm9yLCBza2lwRnJhbWVzKSB7XG4gICAgICBhOiB7XG4gICAgICAgIHZhciBwcmV2aW91c1ByZXBhcmUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBTdHJpbmcoZXJyb3Iuc3RhY2spO1xuICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydHNXaXRoKFwiRXJyb3I6IHJlYWN0LXN0YWNrLXRvcC1mcmFtZVxcblwiKSAmJlxuICAgICAgICAoc3RhY2sgPSBzdGFjay5zbGljZSgyOSkpO1xuICAgICAgZXJyb3IgPSBzdGFjay5pbmRleE9mKFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCIpO1xuICAgICAgLTEgIT09IGVycm9yICYmIChlcnJvciA9IHN0YWNrLmxhc3RJbmRleE9mKFwiXFxuXCIsIGVycm9yKSk7XG4gICAgICAtMSAhPT0gZXJyb3IgJiYgKHN0YWNrID0gc3RhY2suc2xpY2UoMCwgZXJyb3IpKTtcbiAgICAgIHN0YWNrID0gc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICBmb3IgKGVycm9yID0gW107IHNraXBGcmFtZXMgPCBzdGFjay5sZW5ndGg7IHNraXBGcmFtZXMrKylcbiAgICAgICAgaWYgKChwcmV2aW91c1ByZXBhcmUgPSBmcmFtZVJlZ0V4cC5leGVjKHN0YWNrW3NraXBGcmFtZXNdKSkpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IHByZXZpb3VzUHJlcGFyZVsxXSB8fCBcIlwiO1xuICAgICAgICAgIFwiPGFub255bW91cz5cIiA9PT0gbmFtZSAmJiAobmFtZSA9IFwiXCIpO1xuICAgICAgICAgIHZhciBmaWxlbmFtZSA9IHByZXZpb3VzUHJlcGFyZVsyXSB8fCBwcmV2aW91c1ByZXBhcmVbNV0gfHwgXCJcIjtcbiAgICAgICAgICBcIjxhbm9ueW1vdXM+XCIgPT09IGZpbGVuYW1lICYmIChmaWxlbmFtZSA9IFwiXCIpO1xuICAgICAgICAgIGVycm9yLnB1c2goW1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgKyhwcmV2aW91c1ByZXBhcmVbM10gfHwgcHJldmlvdXNQcmVwYXJlWzZdKSxcbiAgICAgICAgICAgICsocHJldmlvdXNQcmVwYXJlWzRdIHx8IHByZXZpb3VzUHJlcGFyZVs3XSlcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVUZW1wb3JhcnlSZWZlcmVuY2UodGVtcG9yYXJ5UmVmZXJlbmNlcywgaWQpIHtcbiAgICAgIHZhciByZWZlcmVuY2UgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJBdHRlbXB0ZWQgdG8gY2FsbCBhIHRlbXBvcmFyeSBDbGllbnQgUmVmZXJlbmNlIGZyb20gdGhlIHNlcnZlciBidXQgaXQgaXMgb24gdGhlIGNsaWVudC4gSXQncyBub3QgcG9zc2libGUgdG8gaW52b2tlIGEgY2xpZW50IGZ1bmN0aW9uIGZyb20gdGhlIHNlcnZlciwgaXQgY2FuIG9ubHkgYmUgcmVuZGVyZWQgYXMgYSBDb21wb25lbnQgb3IgcGFzc2VkIHRvIHByb3BzIG9mIGEgQ2xpZW50IENvbXBvbmVudC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHsgJCR0eXBlb2Y6IHsgdmFsdWU6IFRFTVBPUkFSWV9SRUZFUkVOQ0VfVEFHIH0gfVxuICAgICAgKTtcbiAgICAgIHJlZmVyZW5jZSA9IG5ldyBQcm94eShyZWZlcmVuY2UsIHByb3h5SGFuZGxlcnMpO1xuICAgICAgdGVtcG9yYXJ5UmVmZXJlbmNlcy5zZXQocmVmZXJlbmNlLCBpZCk7XG4gICAgICByZXR1cm4gcmVmZXJlbmNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wJDEoKSB7fVxuICAgIGZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICAgICAgaW5kZXggPSB0aGVuYWJsZVN0YXRlW2luZGV4XTtcbiAgICAgIHZvaWQgMCA9PT0gaW5kZXhcbiAgICAgICAgPyB0aGVuYWJsZVN0YXRlLnB1c2godGhlbmFibGUpXG4gICAgICAgIDogaW5kZXggIT09IHRoZW5hYmxlICYmXG4gICAgICAgICAgKHRoZW5hYmxlLnRoZW4obm9vcCQxLCBub29wJDEpLCAodGhlbmFibGUgPSBpbmRleCkpO1xuICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGVuYWJsZS5zdGF0dXNcbiAgICAgICAgICAgID8gdGhlbmFibGUudGhlbihub29wJDEsIG5vb3AkMSlcbiAgICAgICAgICAgIDogKCh0aGVuYWJsZVN0YXRlID0gdGhlbmFibGUpLFxuICAgICAgICAgICAgICAodGhlbmFibGVTdGF0ZS5zdGF0dXMgPSBcInBlbmRpbmdcIiksXG4gICAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZnVsZmlsbGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS52YWx1ZSA9IGZ1bGZpbGxlZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgICAgICB0aHJvdyB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgdGhyb3cgU3VzcGVuc2VFeGNlcHRpb247XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkge1xuICAgICAgaWYgKG51bGwgPT09IHN1c3BlbmRlZFRoZW5hYmxlKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIGEgc3VzcGVuZGVkIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHRoZW5hYmxlID0gc3VzcGVuZGVkVGhlbmFibGU7XG4gICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRoZW5hYmxlU3RhdGVBZnRlclN1c3BlbmRpbmcoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGVuYWJsZVN0YXRlIHx8IFtdO1xuICAgICAgc3RhdGUuX2NvbXBvbmVudERlYnVnSW5mbyA9IGN1cnJlbnRDb21wb25lbnREZWJ1Z0luZm87XG4gICAgICB0aGVuYWJsZVN0YXRlID0gY3VycmVudENvbXBvbmVudERlYnVnSW5mbyA9IG51bGw7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3VwcG9ydGVkSG9vaygpIHtcbiAgICAgIHRocm93IEVycm9yKFwiVGhpcyBIb29rIGlzIG5vdCBzdXBwb3J0ZWQgaW4gU2VydmVyIENvbXBvbmVudHMuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN1cHBvcnRlZFJlZnJlc2goKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJSZWZyZXNoaW5nIHRoZSBjYWNoZSBpcyBub3Qgc3VwcG9ydGVkIGluIFNlcnZlciBDb21wb25lbnRzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnN1cHBvcnRlZENvbnRleHQoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCByZWFkIGEgQ2xpZW50IENvbnRleHQgZnJvbSBhIFNlcnZlciBDb21wb25lbnQuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlT3duZXIoKSB7XG4gICAgICBpZiAoY3VycmVudE93bmVyKSByZXR1cm4gY3VycmVudE93bmVyO1xuICAgICAgaWYgKHN1cHBvcnRzQ29tcG9uZW50U3RvcmFnZSkge1xuICAgICAgICB2YXIgb3duZXIgPSBjb21wb25lbnRTdG9yYWdlLmdldFN0b3JlKCk7XG4gICAgICAgIGlmIChvd25lcikgcmV0dXJuIG93bmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0T3duZXJTdGFja0xpbWl0KCkge1xuICAgICAgdmFyIG5vdyA9IGdldEN1cnJlbnRUaW1lKCk7XG4gICAgICAxZTMgPCBub3cgLSBsYXN0UmVzZXRUaW1lICYmXG4gICAgICAgICgoUmVhY3RTaGFyZWRJbnRlcm5hbHNTZXJ2ZXIucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MgPSAwKSxcbiAgICAgICAgKGxhc3RSZXNldFRpbWUgPSBub3cpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNPYmplY3RQcm90b3R5cGUob2JqZWN0KSB7XG4gICAgICBpZiAoIW9iamVjdCkgcmV0dXJuICExO1xuICAgICAgdmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgICBpZiAob2JqZWN0ID09PSBPYmplY3RQcm90b3R5cGUpIHJldHVybiAhMDtcbiAgICAgIGlmIChnZXRQcm90b3R5cGVPZihvYmplY3QpKSByZXR1cm4gITE7XG4gICAgICBvYmplY3QgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghKG9iamVjdFtpXSBpbiBPYmplY3RQcm90b3R5cGUpKSByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU2ltcGxlT2JqZWN0KG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdFByb3RvdHlwZShnZXRQcm90b3R5cGVPZihvYmplY3QpKSkgcmV0dXJuICExO1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSwgaSA9IDA7XG4gICAgICAgIGkgPCBuYW1lcy5sZW5ndGg7XG4gICAgICAgIGkrK1xuICAgICAgKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIG5hbWVzW2ldKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFkZXNjcmlwdG9yIHx8XG4gICAgICAgICAgKCFkZXNjcmlwdG9yLmVudW1lcmFibGUgJiZcbiAgICAgICAgICAgICgoXCJrZXlcIiAhPT0gbmFtZXNbaV0gJiYgXCJyZWZcIiAhPT0gbmFtZXNbaV0pIHx8XG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGRlc2NyaXB0b3IuZ2V0KSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gb2JqZWN0TmFtZShvYmplY3QpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICAgIC5jYWxsKG9iamVjdClcbiAgICAgICAgLnJlcGxhY2UoL15cXFtvYmplY3QgKC4qKVxcXSQvLCBmdW5jdGlvbiAobSwgcDApIHtcbiAgICAgICAgICByZXR1cm4gcDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZShrZXkpIHtcbiAgICAgIHZhciBlbmNvZGVkS2V5ID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgIHJldHVybiAnXCInICsga2V5ICsgJ1wiJyA9PT0gZW5jb2RlZEtleSA/IGtleSA6IGVuY29kZWRLZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UodmFsdWUpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAxMCA+PSB2YWx1ZS5sZW5ndGggPyB2YWx1ZSA6IHZhbHVlLnNsaWNlKDAsIDEwKSArIFwiLi4uXCJcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKHZhbHVlKSkgcmV0dXJuIFwiWy4uLl1cIjtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gdmFsdWUgJiYgdmFsdWUuJCR0eXBlb2YgPT09IENMSUVOVF9SRUZFUkVOQ0VfVEFHKVxuICAgICAgICAgICAgcmV0dXJuIFwiY2xpZW50XCI7XG4gICAgICAgICAgdmFsdWUgPSBvYmplY3ROYW1lKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdmFsdWUgPyBcInsuLi59XCIgOiB2YWx1ZTtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBDTElFTlRfUkVGRVJFTkNFX1RBR1xuICAgICAgICAgICAgPyBcImNsaWVudFwiXG4gICAgICAgICAgICA6ICh2YWx1ZSA9IHZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm5hbWUpXG4gICAgICAgICAgICAgID8gXCJmdW5jdGlvbiBcIiArIHZhbHVlXG4gICAgICAgICAgICAgIDogXCJmdW5jdGlvblwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlLnJlbmRlcik7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlLnR5cGUpO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKHBheWxvYWQpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShvYmplY3RPckFycmF5LCBleHBhbmRlZE5hbWUpIHtcbiAgICAgIHZhciBvYmpLaW5kID0gb2JqZWN0TmFtZShvYmplY3RPckFycmF5KTtcbiAgICAgIGlmIChcIk9iamVjdFwiICE9PSBvYmpLaW5kICYmIFwiQXJyYXlcIiAhPT0gb2JqS2luZCkgcmV0dXJuIG9iaktpbmQ7XG4gICAgICB2YXIgc3RhcnQgPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIGlmIChpc0FycmF5SW1wbChvYmplY3RPckFycmF5KSlcbiAgICAgICAgaWYgKGpzeENoaWxkcmVuUGFyZW50cy5oYXMob2JqZWN0T3JBcnJheSkpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGpzeENoaWxkcmVuUGFyZW50cy5nZXQob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgb2JqS2luZCA9IFwiPFwiICsgZGVzY3JpYmVFbGVtZW50VHlwZSh0eXBlKSArIFwiPlwiO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0T3JBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0T3JBcnJheVtpXTtcbiAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgICAgIDogXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmIG51bGwgIT09IHZhbHVlXG4gICAgICAgICAgICAgICAgICA/IFwie1wiICsgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCJ9XCJcbiAgICAgICAgICAgICAgICAgIDogXCJ7XCIgKyBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKHZhbHVlKSArIFwifVwiO1xuICAgICAgICAgICAgXCJcIiArIGkgPT09IGV4cGFuZGVkTmFtZVxuICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gdmFsdWUpKVxuICAgICAgICAgICAgICA6IChvYmpLaW5kID1cbiAgICAgICAgICAgICAgICAgIDE1ID4gdmFsdWUubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyB2YWx1ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBvYmpLaW5kICsgXCJ7Li4ufVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqS2luZCArPSBcIjwvXCIgKyBkZXNjcmliZUVsZW1lbnRUeXBlKHR5cGUpICsgXCI+XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqS2luZCA9IFwiW1wiO1xuICAgICAgICAgIGZvciAodHlwZSA9IDA7IHR5cGUgPCBvYmplY3RPckFycmF5Lmxlbmd0aDsgdHlwZSsrKVxuICAgICAgICAgICAgMCA8IHR5cGUgJiYgKG9iaktpbmQgKz0gXCIsIFwiKSxcbiAgICAgICAgICAgICAgKGkgPSBvYmplY3RPckFycmF5W3R5cGVdKSxcbiAgICAgICAgICAgICAgKGkgPVxuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBpICYmIG51bGwgIT09IGlcbiAgICAgICAgICAgICAgICAgID8gZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UoaSlcbiAgICAgICAgICAgICAgICAgIDogZGVzY3JpYmVWYWx1ZUZvckVycm9yTWVzc2FnZShpKSksXG4gICAgICAgICAgICAgIFwiXCIgKyB0eXBlID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgICA/ICgoc3RhcnQgPSBvYmpLaW5kLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAobGVuZ3RoID0gaS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKG9iaktpbmQgKz0gaSkpXG4gICAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAgIDEwID4gaS5sZW5ndGggJiYgNDAgPiBvYmpLaW5kLmxlbmd0aCArIGkubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgPyBvYmpLaW5kICsgaVxuICAgICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiLi4uXCIpO1xuICAgICAgICAgIG9iaktpbmQgKz0gXCJdXCI7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdE9yQXJyYXkuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSlcbiAgICAgICAgb2JqS2luZCA9IFwiPFwiICsgZGVzY3JpYmVFbGVtZW50VHlwZShvYmplY3RPckFycmF5LnR5cGUpICsgXCIvPlwiO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChvYmplY3RPckFycmF5LiQkdHlwZW9mID09PSBDTElFTlRfUkVGRVJFTkNFX1RBRykgcmV0dXJuIFwiY2xpZW50XCI7XG4gICAgICAgIGlmIChqc3hQcm9wc1BhcmVudHMuaGFzKG9iamVjdE9yQXJyYXkpKSB7XG4gICAgICAgICAgb2JqS2luZCA9IGpzeFByb3BzUGFyZW50cy5nZXQob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgb2JqS2luZCA9IFwiPFwiICsgKGRlc2NyaWJlRWxlbWVudFR5cGUob2JqS2luZCkgfHwgXCIuLi5cIik7XG4gICAgICAgICAgdHlwZSA9IE9iamVjdC5rZXlzKG9iamVjdE9yQXJyYXkpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0eXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvYmpLaW5kICs9IFwiIFwiO1xuICAgICAgICAgICAgdmFsdWUgPSB0eXBlW2ldO1xuICAgICAgICAgICAgb2JqS2luZCArPSBkZXNjcmliZUtleUZvckVycm9yTWVzc2FnZSh2YWx1ZSkgKyBcIj1cIjtcbiAgICAgICAgICAgIHZhciBfdmFsdWUyID0gb2JqZWN0T3JBcnJheVt2YWx1ZV07XG4gICAgICAgICAgICB2YXIgX3N1YnN0cjIgPVxuICAgICAgICAgICAgICB2YWx1ZSA9PT0gZXhwYW5kZWROYW1lICYmXG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBfdmFsdWUyICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IF92YWx1ZTJcbiAgICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpXG4gICAgICAgICAgICAgICAgOiBkZXNjcmliZVZhbHVlRm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpO1xuICAgICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIF92YWx1ZTIgJiYgKF9zdWJzdHIyID0gXCJ7XCIgKyBfc3Vic3RyMiArIFwifVwiKTtcbiAgICAgICAgICAgIHZhbHVlID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChsZW5ndGggPSBfc3Vic3RyMi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IF9zdWJzdHIyKSlcbiAgICAgICAgICAgICAgOiAob2JqS2luZCA9XG4gICAgICAgICAgICAgICAgICAxMCA+IF9zdWJzdHIyLmxlbmd0aCAmJiA0MCA+IG9iaktpbmQubGVuZ3RoICsgX3N1YnN0cjIubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIF9zdWJzdHIyXG4gICAgICAgICAgICAgICAgICAgIDogb2JqS2luZCArIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpLaW5kICs9IFwiPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iaktpbmQgPSBcIntcIjtcbiAgICAgICAgICB0eXBlID0gT2JqZWN0LmtleXMob2JqZWN0T3JBcnJheSk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAwIDwgaSAmJiAob2JqS2luZCArPSBcIiwgXCIpLFxuICAgICAgICAgICAgICAodmFsdWUgPSB0eXBlW2ldKSxcbiAgICAgICAgICAgICAgKG9iaktpbmQgKz0gZGVzY3JpYmVLZXlGb3JFcnJvck1lc3NhZ2UodmFsdWUpICsgXCI6IFwiKSxcbiAgICAgICAgICAgICAgKF92YWx1ZTIgPSBvYmplY3RPckFycmF5W3ZhbHVlXSksXG4gICAgICAgICAgICAgIChfdmFsdWUyID1cbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgX3ZhbHVlMiAmJiBudWxsICE9PSBfdmFsdWUyXG4gICAgICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKF92YWx1ZTIpXG4gICAgICAgICAgICAgICAgICA6IGRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UoX3ZhbHVlMikpLFxuICAgICAgICAgICAgICB2YWx1ZSA9PT0gZXhwYW5kZWROYW1lXG4gICAgICAgICAgICAgICAgPyAoKHN0YXJ0ID0gb2JqS2luZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgKGxlbmd0aCA9IF92YWx1ZTIubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIChvYmpLaW5kICs9IF92YWx1ZTIpKVxuICAgICAgICAgICAgICAgIDogKG9iaktpbmQgPVxuICAgICAgICAgICAgICAgICAgICAxMCA+IF92YWx1ZTIubGVuZ3RoICYmIDQwID4gb2JqS2luZC5sZW5ndGggKyBfdmFsdWUyLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgID8gb2JqS2luZCArIF92YWx1ZTJcbiAgICAgICAgICAgICAgICAgICAgICA6IG9iaktpbmQgKyBcIi4uLlwiKTtcbiAgICAgICAgICBvYmpLaW5kICs9IFwifVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBleHBhbmRlZE5hbWVcbiAgICAgICAgPyBvYmpLaW5kXG4gICAgICAgIDogLTEgPCBzdGFydCAmJiAwIDwgbGVuZ3RoXG4gICAgICAgICAgPyAoKG9iamVjdE9yQXJyYXkgPSBcIiBcIi5yZXBlYXQoc3RhcnQpICsgXCJeXCIucmVwZWF0KGxlbmd0aCkpLFxuICAgICAgICAgICAgXCJcXG4gIFwiICsgb2JqS2luZCArIFwiXFxuICBcIiArIG9iamVjdE9yQXJyYXkpXG4gICAgICAgICAgOiBcIlxcbiAgXCIgKyBvYmpLaW5kO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0RmlsdGVyU3RhY2tGcmFtZShmaWxlbmFtZSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgXCJcIiAhPT0gZmlsZW5hbWUgJiZcbiAgICAgICAgIWZpbGVuYW1lLnN0YXJ0c1dpdGgoXCJub2RlOlwiKSAmJlxuICAgICAgICAhZmlsZW5hbWUuaW5jbHVkZXMoXCJub2RlX21vZHVsZXNcIilcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbHRlclN0YWNrVHJhY2UocmVxdWVzdCwgZXJyb3IsIHNraXBGcmFtZXMpIHtcbiAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LmZpbHRlclN0YWNrRnJhbWU7XG4gICAgICBlcnJvciA9IHBhcnNlU3RhY2tUcmFjZShlcnJvciwgc2tpcEZyYW1lcyk7XG4gICAgICBmb3IgKHNraXBGcmFtZXMgPSAwOyBza2lwRnJhbWVzIDwgZXJyb3IubGVuZ3RoOyBza2lwRnJhbWVzKyspIHtcbiAgICAgICAgdmFyIGNhbGxzaXRlID0gZXJyb3Jbc2tpcEZyYW1lc10sXG4gICAgICAgICAgZnVuY3Rpb25OYW1lID0gY2FsbHNpdGVbMF0sXG4gICAgICAgICAgdXJsID0gY2FsbHNpdGVbMV07XG4gICAgICAgIGlmICh1cmwuc3RhcnRzV2l0aChcInJzYzovL1JlYWN0L1wiKSkge1xuICAgICAgICAgIHZhciBlbnZJZHggPSB1cmwuaW5kZXhPZihcIi9cIiwgMTIpLFxuICAgICAgICAgICAgc3VmZml4SWR4ID0gdXJsLmxhc3RJbmRleE9mKFwiP1wiKTtcbiAgICAgICAgICAtMSA8IGVudklkeCAmJlxuICAgICAgICAgICAgLTEgPCBzdWZmaXhJZHggJiZcbiAgICAgICAgICAgICh1cmwgPSBjYWxsc2l0ZVsxXSA9IHVybC5zbGljZShlbnZJZHggKyAxLCBzdWZmaXhJZHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0KHVybCwgZnVuY3Rpb25OYW1lKSB8fFxuICAgICAgICAgIChlcnJvci5zcGxpY2Uoc2tpcEZyYW1lcywgMSksIHNraXBGcmFtZXMtLSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdGNoQ29uc29sZShjb25zb2xlSW5zdCwgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbnNvbGVJbnN0LCBtZXRob2ROYW1lKTtcbiAgICAgIGlmIChcbiAgICAgICAgZGVzY3JpcHRvciAmJlxuICAgICAgICAoZGVzY3JpcHRvci5jb25maWd1cmFibGUgfHwgZGVzY3JpcHRvci53cml0YWJsZSkgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZVxuICAgICAgKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9yaWdpbmFsTWV0aG9kLCBcIm5hbWVcIik7XG4gICAgICAgIHZhciB3cmFwcGVyTWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcbiAgICAgICAgICBpZiAoKFwiYXNzZXJ0XCIgIT09IG1ldGhvZE5hbWUgfHwgIWFyZ3VtZW50c1swXSkgJiYgbnVsbCAhPT0gcmVxdWVzdCkge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gZmlsdGVyU3RhY2tUcmFjZShcbiAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIiksXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXF1ZXN0LnBlbmRpbmdDaHVua3MrKztcbiAgICAgICAgICAgIHZhciBvd25lciA9IHJlc29sdmVPd25lcigpO1xuICAgICAgICAgICAgZW1pdENvbnNvbGVDaHVuayhyZXF1ZXN0LCBtZXRob2ROYW1lLCBvd25lciwgc3RhY2ssIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBkZXNjcmlwdG9yICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3cmFwcGVyTWV0aG9kLCBcIm5hbWVcIiwgZGVzY3JpcHRvcik7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zb2xlSW5zdCwgbWV0aG9kTmFtZSwge1xuICAgICAgICAgIHZhbHVlOiB3cmFwcGVyTWV0aG9kXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50U3RhY2tJbkRFVigpIHtcbiAgICAgIHZhciBvd25lciA9IHJlc29sdmVPd25lcigpO1xuICAgICAgaWYgKG51bGwgPT09IG93bmVyKSByZXR1cm4gXCJcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpbmZvID0gXCJcIjtcbiAgICAgICAgaWYgKG93bmVyLm93bmVyIHx8IFwic3RyaW5nXCIgIT09IHR5cGVvZiBvd25lci5uYW1lKSB7XG4gICAgICAgICAgZm9yICg7IG93bmVyOyApIHtcbiAgICAgICAgICAgIHZhciBvd25lclN0YWNrID0gb3duZXIuZGVidWdTdGFjaztcbiAgICAgICAgICAgIGlmIChudWxsICE9IG93bmVyU3RhY2spIHtcbiAgICAgICAgICAgICAgaWYgKChvd25lciA9IG93bmVyLm93bmVyKSkge1xuICAgICAgICAgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBpbmZvO1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG93bmVyU3RhY2ssXG4gICAgICAgICAgICAgICAgICBwcmV2UHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgICAgICAgICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgICAgICAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldlByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgICAgICAgICAgIHN0YWNrLnN0YXJ0c1dpdGgoXCJFcnJvcjogcmVhY3Qtc3RhY2stdG9wLWZyYW1lXFxuXCIpICYmXG4gICAgICAgICAgICAgICAgICAoc3RhY2sgPSBzdGFjay5zbGljZSgyOSkpO1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBzdGFjay5pbmRleE9mKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIC0xICE9PSBpZHggJiYgKHN0YWNrID0gc3RhY2suc2xpY2UoaWR4ICsgMSkpO1xuICAgICAgICAgICAgICAgIGlkeCA9IHN0YWNrLmluZGV4T2YoXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIik7XG4gICAgICAgICAgICAgICAgLTEgIT09IGlkeCAmJiAoaWR4ID0gc3RhY2subGFzdEluZGV4T2YoXCJcXG5cIiwgaWR4KSk7XG4gICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAtMSAhPT0gaWR4ID8gKHN0YWNrID0gc3RhY2suc2xpY2UoMCwgaWR4KSkgOiBcIlwiO1xuICAgICAgICAgICAgICAgIGluZm8gPVxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0ICsgKFwiXFxuXCIgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBpbmZvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IG93bmVyLm5hbWU7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgKHByZWZpeCA9XG4gICAgICAgICAgICAgICAgKChlcnJvciA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLykpICYmIGVycm9yWzFdKSB8fFxuICAgICAgICAgICAgICAgIFwiXCIpLFxuICAgICAgICAgICAgICAgIChzdWZmaXggPVxuICAgICAgICAgICAgICAgICAgLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJcXG4gICAgYXRcIilcbiAgICAgICAgICAgICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICAgICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcbiAgICAgICAgICAgICAgICAgICAgICA/IFwiQHVua25vd246MDowXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgICBcIlxcblwiICsgcHJlZml4ICsgSlNDb21waWxlcl90ZW1wX2NvbnN0ICsgc3VmZml4O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdEVycm9ySGFuZGxlcihlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQb3N0cG9uZUhhbmRsZXIoKSB7fVxuICAgIGZ1bmN0aW9uIFJlcXVlc3RJbnN0YW5jZShcbiAgICAgIHR5cGUsXG4gICAgICBtb2RlbCxcbiAgICAgIGJ1bmRsZXJDb25maWcsXG4gICAgICBvbkVycm9yLFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIG9uUG9zdHBvbmUsXG4gICAgICB0ZW1wb3JhcnlSZWZlcmVuY2VzLFxuICAgICAgZW52aXJvbm1lbnROYW1lLFxuICAgICAgZmlsdGVyU3RhY2tGcmFtZSxcbiAgICAgIG9uQWxsUmVhZHksXG4gICAgICBvbkZhdGFsRXJyb3JcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHNTZXJ2ZXIuQSAmJlxuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFsc1NlcnZlci5BICE9PSBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyXG4gICAgICApXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQ3VycmVudGx5IFJlYWN0IG9ubHkgc3VwcG9ydHMgb25lIFJTQyByZW5kZXJlciBhdCBhIHRpbWUuXCJcbiAgICAgICAgKTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzU2VydmVyLkEgPSBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHNTZXJ2ZXIuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudFN0YWNrSW5ERVY7XG4gICAgICB2YXIgYWJvcnRTZXQgPSBuZXcgU2V0KCksXG4gICAgICAgIHBpbmdlZFRhc2tzID0gW10sXG4gICAgICAgIGhpbnRzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuc3RhdHVzID0gT1BFTklORztcbiAgICAgIHRoaXMuZmx1c2hTY2hlZHVsZWQgPSAhMTtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSB0aGlzLmZhdGFsRXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5idW5kbGVyQ29uZmlnID0gYnVuZGxlckNvbmZpZztcbiAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLnBlbmRpbmdDaHVua3MgPSB0aGlzLm5leHRDaHVua0lkID0gMDtcbiAgICAgIHRoaXMuaGludHMgPSBoaW50cztcbiAgICAgIHRoaXMuYWJvcnRMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmFib3J0YWJsZVRhc2tzID0gYWJvcnRTZXQ7XG4gICAgICB0aGlzLnBpbmdlZFRhc2tzID0gcGluZ2VkVGFza3M7XG4gICAgICB0aGlzLmNvbXBsZXRlZEltcG9ydENodW5rcyA9IFtdO1xuICAgICAgdGhpcy5jb21wbGV0ZWRIaW50Q2h1bmtzID0gW107XG4gICAgICB0aGlzLmNvbXBsZXRlZFJlZ3VsYXJDaHVua3MgPSBbXTtcbiAgICAgIHRoaXMuY29tcGxldGVkRXJyb3JDaHVua3MgPSBbXTtcbiAgICAgIHRoaXMud3JpdHRlblN5bWJvbHMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLndyaXR0ZW5DbGllbnRSZWZlcmVuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy53cml0dGVuU2VydmVyUmVmZXJlbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMud3JpdHRlbk9iamVjdHMgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgdGhpcy50ZW1wb3JhcnlSZWZlcmVuY2VzID0gdGVtcG9yYXJ5UmVmZXJlbmNlcztcbiAgICAgIHRoaXMuaWRlbnRpZmllclByZWZpeCA9IGlkZW50aWZpZXJQcmVmaXggfHwgXCJcIjtcbiAgICAgIHRoaXMuaWRlbnRpZmllckNvdW50ID0gMTtcbiAgICAgIHRoaXMudGFpbnRDbGVhbnVwUXVldWUgPSBbXTtcbiAgICAgIHRoaXMub25FcnJvciA9IHZvaWQgMCA9PT0gb25FcnJvciA/IGRlZmF1bHRFcnJvckhhbmRsZXIgOiBvbkVycm9yO1xuICAgICAgdGhpcy5vblBvc3Rwb25lID1cbiAgICAgICAgdm9pZCAwID09PSBvblBvc3Rwb25lID8gZGVmYXVsdFBvc3Rwb25lSGFuZGxlciA6IG9uUG9zdHBvbmU7XG4gICAgICB0aGlzLm9uQWxsUmVhZHkgPSBvbkFsbFJlYWR5O1xuICAgICAgdGhpcy5vbkZhdGFsRXJyb3IgPSBvbkZhdGFsRXJyb3I7XG4gICAgICB0aGlzLmVudmlyb25tZW50TmFtZSA9XG4gICAgICAgIHZvaWQgMCA9PT0gZW52aXJvbm1lbnROYW1lXG4gICAgICAgICAgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIlNlcnZlclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDogXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgZW52aXJvbm1lbnROYW1lXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW52aXJvbm1lbnROYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGVudmlyb25tZW50TmFtZTtcbiAgICAgIHRoaXMuZmlsdGVyU3RhY2tGcmFtZSA9XG4gICAgICAgIHZvaWQgMCA9PT0gZmlsdGVyU3RhY2tGcmFtZVxuICAgICAgICAgID8gZGVmYXVsdEZpbHRlclN0YWNrRnJhbWVcbiAgICAgICAgICA6IGZpbHRlclN0YWNrRnJhbWU7XG4gICAgICB0aGlzLmRpZFdhcm5Gb3JLZXkgPSBudWxsO1xuICAgICAgdHlwZSA9IGNyZWF0ZVRhc2sodGhpcywgbW9kZWwsIG51bGwsICExLCBhYm9ydFNldCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICBwaW5nZWRUYXNrcy5wdXNoKHR5cGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wKCkge31cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KFxuICAgICAgbW9kZWwsXG4gICAgICBidW5kbGVyQ29uZmlnLFxuICAgICAgb25FcnJvcixcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBvblBvc3Rwb25lLFxuICAgICAgdGVtcG9yYXJ5UmVmZXJlbmNlcyxcbiAgICAgIGVudmlyb25tZW50TmFtZSxcbiAgICAgIGZpbHRlclN0YWNrRnJhbWVcbiAgICApIHtcbiAgICAgIHJlc2V0T3duZXJTdGFja0xpbWl0KCk7XG4gICAgICByZXR1cm4gbmV3IFJlcXVlc3RJbnN0YW5jZShcbiAgICAgICAgMjAsXG4gICAgICAgIG1vZGVsLFxuICAgICAgICBidW5kbGVyQ29uZmlnLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgICBvblBvc3Rwb25lLFxuICAgICAgICB0ZW1wb3JhcnlSZWZlcmVuY2VzLFxuICAgICAgICBlbnZpcm9ubWVudE5hbWUsXG4gICAgICAgIGZpbHRlclN0YWNrRnJhbWUsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIG5vb3BcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVByZXJlbmRlclJlcXVlc3QoXG4gICAgICBtb2RlbCxcbiAgICAgIGJ1bmRsZXJDb25maWcsXG4gICAgICBvbkFsbFJlYWR5LFxuICAgICAgb25GYXRhbEVycm9yLFxuICAgICAgb25FcnJvcixcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBvblBvc3Rwb25lLFxuICAgICAgdGVtcG9yYXJ5UmVmZXJlbmNlcyxcbiAgICAgIGVudmlyb25tZW50TmFtZSxcbiAgICAgIGZpbHRlclN0YWNrRnJhbWVcbiAgICApIHtcbiAgICAgIHJlc2V0T3duZXJTdGFja0xpbWl0KCk7XG4gICAgICByZXR1cm4gbmV3IFJlcXVlc3RJbnN0YW5jZShcbiAgICAgICAgUFJFUkVOREVSLFxuICAgICAgICBtb2RlbCxcbiAgICAgICAgYnVuZGxlckNvbmZpZyxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgICAgb25Qb3N0cG9uZSxcbiAgICAgICAgdGVtcG9yYXJ5UmVmZXJlbmNlcyxcbiAgICAgICAgZW52aXJvbm1lbnROYW1lLFxuICAgICAgICBmaWx0ZXJTdGFja0ZyYW1lLFxuICAgICAgICBvbkFsbFJlYWR5LFxuICAgICAgICBvbkZhdGFsRXJyb3JcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVSZXF1ZXN0KCkge1xuICAgICAgaWYgKGN1cnJlbnRSZXF1ZXN0KSByZXR1cm4gY3VycmVudFJlcXVlc3Q7XG4gICAgICBpZiAoc3VwcG9ydHNSZXF1ZXN0U3RvcmFnZSkge1xuICAgICAgICB2YXIgc3RvcmUgPSByZXF1ZXN0U3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgICAgICBpZiAoc3RvcmUpIHJldHVybiBzdG9yZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXJpYWxpemVUaGVuYWJsZShyZXF1ZXN0LCB0YXNrLCB0aGVuYWJsZSkge1xuICAgICAgdmFyIG5ld1Rhc2sgPSBjcmVhdGVUYXNrKFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBudWxsLFxuICAgICAgICB0YXNrLmtleVBhdGgsXG4gICAgICAgIHRhc2suaW1wbGljaXRTbG90LFxuICAgICAgICByZXF1ZXN0LmFib3J0YWJsZVRhc2tzLFxuICAgICAgICB0YXNrLmRlYnVnT3duZXIsXG4gICAgICAgIHRhc2suZGVidWdTdGFjayxcbiAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgICAodGFzayA9IHRoZW5hYmxlLl9kZWJ1Z0luZm8pICYmXG4gICAgICAgIGZvcndhcmREZWJ1Z0luZm8ocmVxdWVzdCwgbmV3VGFzay5pZCwgdGFzayk7XG4gICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChuZXdUYXNrLm1vZGVsID0gdGhlbmFibGUudmFsdWUpLFxuICAgICAgICAgICAgcGluZ1Rhc2socmVxdWVzdCwgbmV3VGFzayksXG4gICAgICAgICAgICBuZXdUYXNrLmlkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgcmV0dXJuIGVycm9yZWRUYXNrKHJlcXVlc3QsIG5ld1Rhc2ssIHRoZW5hYmxlLnJlYXNvbiksIG5ld1Rhc2suaWQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSBBQk9SVElORylcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHJlcXVlc3QuYWJvcnRhYmxlVGFza3MuZGVsZXRlKG5ld1Rhc2spLFxuICAgICAgICAgICAgICAobmV3VGFzay5zdGF0dXMgPSBBQk9SVEVEKSxcbiAgICAgICAgICAgICAgKHRhc2sgPSBzdHJpbmdpZnkoc2VyaWFsaXplQnlWYWx1ZUlEKHJlcXVlc3QuZmF0YWxFcnJvcikpKSxcbiAgICAgICAgICAgICAgZW1pdE1vZGVsQ2h1bmsocmVxdWVzdCwgbmV3VGFzay5pZCwgdGFzayksXG4gICAgICAgICAgICAgIG5ld1Rhc2suaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHRoZW5hYmxlLnN0YXR1cyAmJlxuICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcInBlbmRpbmdcIiksXG4gICAgICAgICAgICB0aGVuYWJsZS50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZnVsZmlsbGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAoKHRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgKHRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWUpKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLCAodGhlbmFibGUucmVhc29uID0gZXJyb3IpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICB0aGVuYWJsZS50aGVuKFxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBuZXdUYXNrLm1vZGVsID0gdmFsdWU7XG4gICAgICAgICAgcGluZ1Rhc2socmVxdWVzdCwgbmV3VGFzayk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBuZXdUYXNrLnN0YXR1cyA9PT0gUEVORElORyQxICYmXG4gICAgICAgICAgICAoZXJyb3JlZFRhc2socmVxdWVzdCwgbmV3VGFzaywgcmVhc29uKSwgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXdUYXNrLmlkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXJpYWxpemVSZWFkYWJsZVN0cmVhbShyZXF1ZXN0LCB0YXNrLCBzdHJlYW0pIHtcbiAgICAgIGZ1bmN0aW9uIHByb2dyZXNzKGVudHJ5KSB7XG4gICAgICAgIGlmICghYWJvcnRlZClcbiAgICAgICAgICBpZiAoZW50cnkuZG9uZSlcbiAgICAgICAgICAgIHJlcXVlc3QuYWJvcnRMaXN0ZW5lcnMuZGVsZXRlKGFib3J0U3RyZWFtKSxcbiAgICAgICAgICAgICAgKGVudHJ5ID0gc3RyZWFtVGFzay5pZC50b1N0cmluZygxNikgKyBcIjpDXFxuXCIpLFxuICAgICAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZFJlZ3VsYXJDaHVua3MucHVzaChzdHJpbmdUb0NodW5rKGVudHJ5KSksXG4gICAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSxcbiAgICAgICAgICAgICAgKGFib3J0ZWQgPSAhMCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgKHN0cmVhbVRhc2subW9kZWwgPSBlbnRyeS52YWx1ZSksXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5wZW5kaW5nQ2h1bmtzKyssXG4gICAgICAgICAgICAgICAgdHJ5U3RyZWFtVGFzayhyZXF1ZXN0LCBzdHJlYW1UYXNrKSxcbiAgICAgICAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCksXG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKHByb2dyZXNzLCBlcnJvcik7XG4gICAgICAgICAgICB9IGNhdGNoICh4JDApIHtcbiAgICAgICAgICAgICAgZXJyb3IoeCQwKTtcbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVycm9yKHJlYXNvbikge1xuICAgICAgICBhYm9ydGVkIHx8XG4gICAgICAgICAgKChhYm9ydGVkID0gITApLFxuICAgICAgICAgIHJlcXVlc3QuYWJvcnRMaXN0ZW5lcnMuZGVsZXRlKGFib3J0U3RyZWFtKSxcbiAgICAgICAgICBlcnJvcmVkVGFzayhyZXF1ZXN0LCBzdHJlYW1UYXNrLCByZWFzb24pLFxuICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSxcbiAgICAgICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbikudGhlbihlcnJvciwgZXJyb3IpKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGFib3J0U3RyZWFtKHJlYXNvbikge1xuICAgICAgICBhYm9ydGVkIHx8XG4gICAgICAgICAgKChhYm9ydGVkID0gITApLFxuICAgICAgICAgIHJlcXVlc3QuYWJvcnRMaXN0ZW5lcnMuZGVsZXRlKGFib3J0U3RyZWFtKSxcbiAgICAgICAgICBlcnJvcmVkVGFzayhyZXF1ZXN0LCBzdHJlYW1UYXNrLCByZWFzb24pLFxuICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSxcbiAgICAgICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbikudGhlbihlcnJvciwgZXJyb3IpKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdXBwb3J0c0JZT0IgPSBzdHJlYW0uc3VwcG9ydHNCWU9CO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gc3VwcG9ydHNCWU9CKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0cmVhbS5nZXRSZWFkZXIoeyBtb2RlOiBcImJ5b2JcIiB9KS5yZWxlYXNlTG9jaygpLCAoc3VwcG9ydHNCWU9CID0gITApO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgc3VwcG9ydHNCWU9CID0gITE7XG4gICAgICAgIH1cbiAgICAgIHZhciByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCksXG4gICAgICAgIHN0cmVhbVRhc2sgPSBjcmVhdGVUYXNrKFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgdGFzay5tb2RlbCxcbiAgICAgICAgICB0YXNrLmtleVBhdGgsXG4gICAgICAgICAgdGFzay5pbXBsaWNpdFNsb3QsXG4gICAgICAgICAgcmVxdWVzdC5hYm9ydGFibGVUYXNrcyxcbiAgICAgICAgICB0YXNrLmRlYnVnT3duZXIsXG4gICAgICAgICAgdGFzay5kZWJ1Z1N0YWNrLFxuICAgICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICAgICk7XG4gICAgICByZXF1ZXN0LmFib3J0YWJsZVRhc2tzLmRlbGV0ZShzdHJlYW1UYXNrKTtcbiAgICAgIHJlcXVlc3QucGVuZGluZ0NodW5rcysrO1xuICAgICAgdGFzayA9XG4gICAgICAgIHN0cmVhbVRhc2suaWQudG9TdHJpbmcoMTYpICsgXCI6XCIgKyAoc3VwcG9ydHNCWU9CID8gXCJyXCIgOiBcIlJcIikgKyBcIlxcblwiO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSZWd1bGFyQ2h1bmtzLnB1c2goc3RyaW5nVG9DaHVuayh0YXNrKSk7XG4gICAgICB2YXIgYWJvcnRlZCA9ICExO1xuICAgICAgcmVxdWVzdC5hYm9ydExpc3RlbmVycy5hZGQoYWJvcnRTdHJlYW0pO1xuICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKHByb2dyZXNzLCBlcnJvcik7XG4gICAgICByZXR1cm4gc2VyaWFsaXplQnlWYWx1ZUlEKHN0cmVhbVRhc2suaWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXJpYWxpemVBc3luY0l0ZXJhYmxlKHJlcXVlc3QsIHRhc2ssIGl0ZXJhYmxlLCBpdGVyYXRvcikge1xuICAgICAgZnVuY3Rpb24gcHJvZ3Jlc3MoZW50cnkpIHtcbiAgICAgICAgaWYgKCFhYm9ydGVkKVxuICAgICAgICAgIGlmIChlbnRyeS5kb25lKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmFib3J0TGlzdGVuZXJzLmRlbGV0ZShhYm9ydEl0ZXJhYmxlKTtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGVudHJ5LnZhbHVlKVxuICAgICAgICAgICAgICB2YXIgZW5kU3RyZWFtUm93ID0gc3RyZWFtVGFzay5pZC50b1N0cmluZygxNikgKyBcIjpDXFxuXCI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGNodW5rSWQgPSBvdXRsaW5lTW9kZWwocmVxdWVzdCwgZW50cnkudmFsdWUpO1xuICAgICAgICAgICAgICAgIGVuZFN0cmVhbVJvdyA9XG4gICAgICAgICAgICAgICAgICBzdHJlYW1UYXNrLmlkLnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAgICAgICBcIjpDXCIgK1xuICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KHNlcmlhbGl6ZUJ5VmFsdWVJRChjaHVua0lkKSkgK1xuICAgICAgICAgICAgICAgICAgXCJcXG5cIjtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIGVycm9yKHgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSZWd1bGFyQ2h1bmtzLnB1c2goc3RyaW5nVG9DaHVuayhlbmRTdHJlYW1Sb3cpKTtcbiAgICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICAgIGFib3J0ZWQgPSAhMDtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIChzdHJlYW1UYXNrLm1vZGVsID0gZW50cnkudmFsdWUpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucGVuZGluZ0NodW5rcysrLFxuICAgICAgICAgICAgICAgIHRyeVN0cmVhbVRhc2socmVxdWVzdCwgc3RyZWFtVGFzayksXG4gICAgICAgICAgICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpLFxuICAgICAgICAgICAgICAgIGNhbGxJdGVyYXRvckluREVWKGl0ZXJhdG9yLCBwcm9ncmVzcywgZXJyb3IpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCQxKSB7XG4gICAgICAgICAgICAgIGVycm9yKHgkMSk7XG4gICAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlcnJvcihyZWFzb24pIHtcbiAgICAgICAgYWJvcnRlZCB8fFxuICAgICAgICAgICgoYWJvcnRlZCA9ICEwKSxcbiAgICAgICAgICByZXF1ZXN0LmFib3J0TGlzdGVuZXJzLmRlbGV0ZShhYm9ydEl0ZXJhYmxlKSxcbiAgICAgICAgICBlcnJvcmVkVGFzayhyZXF1ZXN0LCBzdHJlYW1UYXNrLCByZWFzb24pLFxuICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpdGVyYXRvci50aHJvdyAmJlxuICAgICAgICAgICAgaXRlcmF0b3IudGhyb3cocmVhc29uKS50aGVuKGVycm9yLCBlcnJvcikpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYWJvcnRJdGVyYWJsZShyZWFzb24pIHtcbiAgICAgICAgYWJvcnRlZCB8fFxuICAgICAgICAgICgoYWJvcnRlZCA9ICEwKSxcbiAgICAgICAgICByZXF1ZXN0LmFib3J0TGlzdGVuZXJzLmRlbGV0ZShhYm9ydEl0ZXJhYmxlKSxcbiAgICAgICAgICBlcnJvcmVkVGFzayhyZXF1ZXN0LCBzdHJlYW1UYXNrLCByZWFzb24pLFxuICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpdGVyYXRvci50aHJvdyAmJlxuICAgICAgICAgICAgaXRlcmF0b3IudGhyb3cocmVhc29uKS50aGVuKGVycm9yLCBlcnJvcikpO1xuICAgICAgfVxuICAgICAgdmFyIGlzSXRlcmF0b3IgPSBpdGVyYWJsZSA9PT0gaXRlcmF0b3IsXG4gICAgICAgIHN0cmVhbVRhc2sgPSBjcmVhdGVUYXNrKFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgdGFzay5tb2RlbCxcbiAgICAgICAgICB0YXNrLmtleVBhdGgsXG4gICAgICAgICAgdGFzay5pbXBsaWNpdFNsb3QsXG4gICAgICAgICAgcmVxdWVzdC5hYm9ydGFibGVUYXNrcyxcbiAgICAgICAgICB0YXNrLmRlYnVnT3duZXIsXG4gICAgICAgICAgdGFzay5kZWJ1Z1N0YWNrLFxuICAgICAgICAgIHRhc2suZGVidWdUYXNrXG4gICAgICAgICk7XG4gICAgICByZXF1ZXN0LmFib3J0YWJsZVRhc2tzLmRlbGV0ZShzdHJlYW1UYXNrKTtcbiAgICAgIHJlcXVlc3QucGVuZGluZ0NodW5rcysrO1xuICAgICAgdGFzayA9IHN0cmVhbVRhc2suaWQudG9TdHJpbmcoMTYpICsgXCI6XCIgKyAoaXNJdGVyYXRvciA/IFwieFwiIDogXCJYXCIpICsgXCJcXG5cIjtcbiAgICAgIHJlcXVlc3QuY29tcGxldGVkUmVndWxhckNodW5rcy5wdXNoKHN0cmluZ1RvQ2h1bmsodGFzaykpO1xuICAgICAgKGl0ZXJhYmxlID0gaXRlcmFibGUuX2RlYnVnSW5mbykgJiZcbiAgICAgICAgZm9yd2FyZERlYnVnSW5mbyhyZXF1ZXN0LCBzdHJlYW1UYXNrLmlkLCBpdGVyYWJsZSk7XG4gICAgICB2YXIgYWJvcnRlZCA9ICExO1xuICAgICAgcmVxdWVzdC5hYm9ydExpc3RlbmVycy5hZGQoYWJvcnRJdGVyYWJsZSk7XG4gICAgICBjYWxsSXRlcmF0b3JJbkRFVihpdGVyYXRvciwgcHJvZ3Jlc3MsIGVycm9yKTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVCeVZhbHVlSUQoc3RyZWFtVGFzay5pZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtaXRIaW50KHJlcXVlc3QsIGNvZGUsIG1vZGVsKSB7XG4gICAgICBtb2RlbCA9IHN0cmluZ2lmeShtb2RlbCk7XG4gICAgICBjb2RlID0gc3RyaW5nVG9DaHVuayhcIjpIXCIgKyBjb2RlICsgbW9kZWwgKyBcIlxcblwiKTtcbiAgICAgIHJlcXVlc3QuY29tcGxldGVkSGludENodW5rcy5wdXNoKGNvZGUpO1xuICAgICAgZW5xdWV1ZUZsdXNoKHJlcXVlc3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICAgIGlmIChcImZ1bGZpbGxlZFwiID09PSB0aGVuYWJsZS5zdGF0dXMpIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgIGlmIChcInJlamVjdGVkXCIgPT09IHRoZW5hYmxlLnN0YXR1cykgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgdGhyb3cgdGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxhenlXcmFwcGVyQXJvdW5kV2FrZWFibGUod2FrZWFibGUpIHtcbiAgICAgIHN3aXRjaCAod2FrZWFibGUuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHdha2VhYmxlLnN0YXR1cyAmJlxuICAgICAgICAgICAgKCh3YWtlYWJsZS5zdGF0dXMgPSBcInBlbmRpbmdcIiksXG4gICAgICAgICAgICB3YWtlYWJsZS50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZnVsZmlsbGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBcInBlbmRpbmdcIiA9PT0gd2FrZWFibGUuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAoKHdha2VhYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIpLFxuICAgICAgICAgICAgICAgICAgKHdha2VhYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWUpKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgXCJwZW5kaW5nXCIgPT09IHdha2VhYmxlLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgKCh3YWtlYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLCAod2FrZWFibGUucmVhc29uID0gZXJyb3IpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICB2YXIgbGF6eVR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgICAgIF9wYXlsb2FkOiB3YWtlYWJsZSxcbiAgICAgICAgX2luaXQ6IHJlYWRUaGVuYWJsZVxuICAgICAgfTtcbiAgICAgIGxhenlUeXBlLl9kZWJ1Z0luZm8gPSB3YWtlYWJsZS5fZGVidWdJbmZvIHx8IFtdO1xuICAgICAgcmV0dXJuIGxhenlUeXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsV2l0aERlYnVnQ29udGV4dEluREVWKHJlcXVlc3QsIHRhc2ssIGNhbGxiYWNrLCBhcmcpIHtcbiAgICAgIHZhciBjb21wb25lbnREZWJ1Z0luZm8gPSB7XG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIGVudjogdGFzay5lbnZpcm9ubWVudE5hbWUsXG4gICAgICAgIGtleTogbnVsbCxcbiAgICAgICAgb3duZXI6IHRhc2suZGVidWdPd25lclxuICAgICAgfTtcbiAgICAgIGNvbXBvbmVudERlYnVnSW5mby5zdGFjayA9XG4gICAgICAgIG51bGwgPT09IHRhc2suZGVidWdTdGFja1xuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogZmlsdGVyU3RhY2tUcmFjZShyZXF1ZXN0LCB0YXNrLmRlYnVnU3RhY2ssIDEpO1xuICAgICAgY29tcG9uZW50RGVidWdJbmZvLmRlYnVnU3RhY2sgPSB0YXNrLmRlYnVnU3RhY2s7XG4gICAgICByZXF1ZXN0ID0gY29tcG9uZW50RGVidWdJbmZvLmRlYnVnVGFzayA9IHRhc2suZGVidWdUYXNrO1xuICAgICAgY3VycmVudE93bmVyID0gY29tcG9uZW50RGVidWdJbmZvO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3QgPyByZXF1ZXN0LnJ1bihjYWxsYmFjay5iaW5kKG51bGwsIGFyZykpIDogY2FsbGJhY2soYXJnKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGN1cnJlbnRPd25lciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTZXJ2ZXJDb21wb25lbnRSZXR1cm5WYWx1ZShcbiAgICAgIHJlcXVlc3QsXG4gICAgICB0YXNrLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcmVzdWx0XG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiByZXN1bHQgfHxcbiAgICAgICAgbnVsbCA9PT0gcmVzdWx0IHx8XG4gICAgICAgIGlzQ2xpZW50UmVmZXJlbmNlKHJlc3VsdClcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXN1bHQudGhlbilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICByZXN1bHQudGhlbihmdW5jdGlvbiAocmVzb2x2ZWRWYWx1ZSkge1xuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJlc29sdmVkVmFsdWUgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcmVzb2x2ZWRWYWx1ZSAmJlxuICAgICAgICAgICAgICByZXNvbHZlZFZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgJiZcbiAgICAgICAgICAgICAgKHJlc29sdmVkVmFsdWUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgICAgICAgIH0sIHZvaWRIYW5kbGVyKSxcbiAgICAgICAgICBcImZ1bGZpbGxlZFwiID09PSByZXN1bHQuc3RhdHVzXG4gICAgICAgICAgICA/IHJlc3VsdC52YWx1ZVxuICAgICAgICAgICAgOiBjcmVhdGVMYXp5V3JhcHBlckFyb3VuZFdha2VhYmxlKHJlc3VsdClcbiAgICAgICAgKTtcbiAgICAgIHJlc3VsdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmIChyZXN1bHQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHJlc3VsdCk7XG4gICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICB2YXIgbXVsdGlTaG90ID0gX2RlZmluZVByb3BlcnR5KHt9LCBTeW1ib2wuaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocmVzdWx0KTtcbiAgICAgICAgICBpdGVyYXRvciAhPT0gcmVzdWx0IHx8XG4gICAgICAgICAgICAoXCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwiID09PVxuICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQ29tcG9uZW50KSAmJlxuICAgICAgICAgICAgICBcIltvYmplY3QgR2VuZXJhdG9yXVwiID09PVxuICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXN1bHQpKSB8fFxuICAgICAgICAgICAgY2FsbFdpdGhEZWJ1Z0NvbnRleHRJbkRFVihyZXF1ZXN0LCB0YXNrLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJSZXR1cm5pbmcgYW4gSXRlcmF0b3IgZnJvbSBhIFNlcnZlciBDb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZCBzaW5jZSBpdCBjYW5ub3QgYmUgbG9vcGVkIG92ZXIgbW9yZSB0aGFuIG9uY2UuIFwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgIH0pO1xuICAgICAgICBtdWx0aVNob3QuX2RlYnVnSW5mbyA9IHJlc3VsdC5fZGVidWdJbmZvO1xuICAgICAgICByZXR1cm4gbXVsdGlTaG90O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHJlc3VsdFtBU1lOQ19JVEVSQVRPUl0gfHxcbiAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFJlYWRhYmxlU3RyZWFtICYmXG4gICAgICAgICAgcmVzdWx0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pXG4gICAgICAgID8gcmVzdWx0XG4gICAgICAgIDogKChtdWx0aVNob3QgPSBfZGVmaW5lUHJvcGVydHkoe30sIEFTWU5DX0lURVJBVE9SLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSByZXN1bHRbQVNZTkNfSVRFUkFUT1JdKCk7XG4gICAgICAgICAgICBpdGVyYXRvciAhPT0gcmVzdWx0IHx8XG4gICAgICAgICAgICAgIChcIltvYmplY3QgQXN5bmNHZW5lcmF0b3JGdW5jdGlvbl1cIiA9PT1cbiAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQ29tcG9uZW50KSAmJlxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBBc3luY0dlbmVyYXRvcl1cIiA9PT1cbiAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXN1bHQpKSB8fFxuICAgICAgICAgICAgICBjYWxsV2l0aERlYnVnQ29udGV4dEluREVWKHJlcXVlc3QsIHRhc2ssIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJSZXR1cm5pbmcgYW4gQXN5bmNJdGVyYXRvciBmcm9tIGEgU2VydmVyIENvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkIHNpbmNlIGl0IGNhbm5vdCBiZSBsb29wZWQgb3ZlciBtb3JlIHRoYW4gb25jZS4gXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICB9KSksXG4gICAgICAgICAgKG11bHRpU2hvdC5fZGVidWdJbmZvID0gcmVzdWx0Ll9kZWJ1Z0luZm8pLFxuICAgICAgICAgIG11bHRpU2hvdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRhc2ssXG4gICAgICBrZXksXG4gICAgICBDb21wb25lbnQsXG4gICAgICBwcm9wcyxcbiAgICAgIHZhbGlkYXRlZFxuICAgICkge1xuICAgICAgdmFyIHByZXZUaGVuYWJsZVN0YXRlID0gdGFzay50aGVuYWJsZVN0YXRlO1xuICAgICAgdGFzay50aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgICAgIGlmIChudWxsID09PSBkZWJ1Z0lEKSByZXR1cm4gb3V0bGluZVRhc2socmVxdWVzdCwgdGFzayk7XG4gICAgICBpZiAobnVsbCAhPT0gcHJldlRoZW5hYmxlU3RhdGUpXG4gICAgICAgIHZhciBjb21wb25lbnREZWJ1Z0luZm8gPSBwcmV2VGhlbmFibGVTdGF0ZS5fY29tcG9uZW50RGVidWdJbmZvO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBjb21wb25lbnREZWJ1Z0lEID0gZGVidWdJRDtcbiAgICAgICAgY29tcG9uZW50RGVidWdJbmZvID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8IFwiXCI7XG4gICAgICAgIHZhciBjb21wb25lbnRFbnYgPSAoMCwgcmVxdWVzdC5lbnZpcm9ubWVudE5hbWUpKCk7XG4gICAgICAgIHJlcXVlc3QucGVuZGluZ0NodW5rcysrO1xuICAgICAgICBjb21wb25lbnREZWJ1Z0luZm8gPSB7XG4gICAgICAgICAgbmFtZTogY29tcG9uZW50RGVidWdJbmZvLFxuICAgICAgICAgIGVudjogY29tcG9uZW50RW52LFxuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIG93bmVyOiB0YXNrLmRlYnVnT3duZXJcbiAgICAgICAgfTtcbiAgICAgICAgY29tcG9uZW50RGVidWdJbmZvLnN0YWNrID1cbiAgICAgICAgICBudWxsID09PSB0YXNrLmRlYnVnU3RhY2tcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBmaWx0ZXJTdGFja1RyYWNlKHJlcXVlc3QsIHRhc2suZGVidWdTdGFjaywgMSk7XG4gICAgICAgIGNvbXBvbmVudERlYnVnSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICBjb21wb25lbnREZWJ1Z0luZm8uZGVidWdTdGFjayA9IHRhc2suZGVidWdTdGFjaztcbiAgICAgICAgY29tcG9uZW50RGVidWdJbmZvLmRlYnVnVGFzayA9IHRhc2suZGVidWdUYXNrO1xuICAgICAgICBvdXRsaW5lQ29tcG9uZW50SW5mbyhyZXF1ZXN0LCBjb21wb25lbnREZWJ1Z0luZm8pO1xuICAgICAgICBlbWl0RGVidWdDaHVuayhyZXF1ZXN0LCBjb21wb25lbnREZWJ1Z0lELCBjb21wb25lbnREZWJ1Z0luZm8pO1xuICAgICAgICB0YXNrLmVudmlyb25tZW50TmFtZSA9IGNvbXBvbmVudEVudjtcbiAgICAgICAgMiA9PT0gdmFsaWRhdGVkICYmXG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkocmVxdWVzdCwga2V5LCBjb21wb25lbnREZWJ1Z0luZm8sIHRhc2suZGVidWdUYXNrKTtcbiAgICAgIH1cbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBwcmV2VGhlbmFibGVTdGF0ZTtcbiAgICAgIGN1cnJlbnRDb21wb25lbnREZWJ1Z0luZm8gPSBjb21wb25lbnREZWJ1Z0luZm87XG4gICAgICBwcm9wcyA9IHN1cHBvcnRzQ29tcG9uZW50U3RvcmFnZVxuICAgICAgICA/IHRhc2suZGVidWdUYXNrXG4gICAgICAgICAgPyB0YXNrLmRlYnVnVGFzay5ydW4oXG4gICAgICAgICAgICAgIGNvbXBvbmVudFN0b3JhZ2UucnVuLmJpbmQoXG4gICAgICAgICAgICAgICAgY29tcG9uZW50U3RvcmFnZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnREZWJ1Z0luZm8sXG4gICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudEluREVWLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnREZWJ1Z0luZm9cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29tcG9uZW50U3RvcmFnZS5ydW4oXG4gICAgICAgICAgICAgIGNvbXBvbmVudERlYnVnSW5mbyxcbiAgICAgICAgICAgICAgY2FsbENvbXBvbmVudEluREVWLFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBjb21wb25lbnREZWJ1Z0luZm9cbiAgICAgICAgICAgIClcbiAgICAgICAgOiB0YXNrLmRlYnVnVGFza1xuICAgICAgICAgID8gdGFzay5kZWJ1Z1Rhc2sucnVuKFxuICAgICAgICAgICAgICBjYWxsQ29tcG9uZW50SW5ERVYuYmluZChcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICBjb21wb25lbnREZWJ1Z0luZm9cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY2FsbENvbXBvbmVudEluREVWKENvbXBvbmVudCwgcHJvcHMsIGNvbXBvbmVudERlYnVnSW5mbyk7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IEFCT1JUSU5HKVxuICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBwcm9wcyB8fFxuICAgICAgICAgICAgbnVsbCA9PT0gcHJvcHMgfHxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHByb3BzLnRoZW4gfHxcbiAgICAgICAgICAgIGlzQ2xpZW50UmVmZXJlbmNlKHByb3BzKSB8fFxuICAgICAgICAgICAgcHJvcHMudGhlbih2b2lkSGFuZGxlciwgdm9pZEhhbmRsZXIpLFxuICAgICAgICAgIG51bGwpXG4gICAgICAgICk7XG4gICAgICBwcm9wcyA9IHByb2Nlc3NTZXJ2ZXJDb21wb25lbnRSZXR1cm5WYWx1ZShcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgdGFzayxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBwcm9wc1xuICAgICAgKTtcbiAgICAgIENvbXBvbmVudCA9IHRhc2sua2V5UGF0aDtcbiAgICAgIHZhbGlkYXRlZCA9IHRhc2suaW1wbGljaXRTbG90O1xuICAgICAgbnVsbCAhPT0ga2V5XG4gICAgICAgID8gKHRhc2sua2V5UGF0aCA9IG51bGwgPT09IENvbXBvbmVudCA/IGtleSA6IENvbXBvbmVudCArIFwiLFwiICsga2V5KVxuICAgICAgICA6IG51bGwgPT09IENvbXBvbmVudCAmJiAodGFzay5pbXBsaWNpdFNsb3QgPSAhMCk7XG4gICAgICByZXF1ZXN0ID0gcmVuZGVyTW9kZWxEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBlbXB0eVJvb3QsIFwiXCIsIHByb3BzKTtcbiAgICAgIHRhc2sua2V5UGF0aCA9IENvbXBvbmVudDtcbiAgICAgIHRhc2suaW1wbGljaXRTbG90ID0gdmFsaWRhdGVkO1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5Gb3JNaXNzaW5nS2V5KHJlcXVlc3QsIGtleSwgY29tcG9uZW50RGVidWdJbmZvLCBkZWJ1Z1Rhc2spIHtcbiAgICAgIGZ1bmN0aW9uIGxvZ0tleUVycm9yKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBcIlwiLFxuICAgICAgICAgIFwiXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGtleSA9IHJlcXVlc3QuZGlkV2FybkZvcktleTtcbiAgICAgIG51bGwgPT0ga2V5ICYmIChrZXkgPSByZXF1ZXN0LmRpZFdhcm5Gb3JLZXkgPSBuZXcgV2Vha1NldCgpKTtcbiAgICAgIHJlcXVlc3QgPSBjb21wb25lbnREZWJ1Z0luZm8ub3duZXI7XG4gICAgICBpZiAobnVsbCAhPSByZXF1ZXN0KSB7XG4gICAgICAgIGlmIChrZXkuaGFzKHJlcXVlc3QpKSByZXR1cm47XG4gICAgICAgIGtleS5hZGQocmVxdWVzdCk7XG4gICAgICB9XG4gICAgICBzdXBwb3J0c0NvbXBvbmVudFN0b3JhZ2VcbiAgICAgICAgPyBkZWJ1Z1Rhc2tcbiAgICAgICAgICA/IGRlYnVnVGFzay5ydW4oXG4gICAgICAgICAgICAgIGNvbXBvbmVudFN0b3JhZ2UucnVuLmJpbmQoXG4gICAgICAgICAgICAgICAgY29tcG9uZW50U3RvcmFnZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnREZWJ1Z0luZm8sXG4gICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudEluREVWLFxuICAgICAgICAgICAgICAgIGxvZ0tleUVycm9yLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50RGVidWdJbmZvXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbXBvbmVudFN0b3JhZ2UucnVuKFxuICAgICAgICAgICAgICBjb21wb25lbnREZWJ1Z0luZm8sXG4gICAgICAgICAgICAgIGNhbGxDb21wb25lbnRJbkRFVixcbiAgICAgICAgICAgICAgbG9nS2V5RXJyb3IsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGNvbXBvbmVudERlYnVnSW5mb1xuICAgICAgICAgICAgKVxuICAgICAgICA6IGRlYnVnVGFza1xuICAgICAgICAgID8gZGVidWdUYXNrLnJ1bihcbiAgICAgICAgICAgICAgY2FsbENvbXBvbmVudEluREVWLmJpbmQoXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBsb2dLZXlFcnJvcixcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudERlYnVnSW5mb1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBjYWxsQ29tcG9uZW50SW5ERVYobG9nS2V5RXJyb3IsIG51bGwsIGNvbXBvbmVudERlYnVnSW5mbyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckZyYWdtZW50KHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBudWxsID09PSBjaGlsZCB8fFxuICAgICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBjaGlsZCB8fFxuICAgICAgICAgIGNoaWxkLiQkdHlwZW9mICE9PSBSRUFDVF9FTEVNRU5UX1RZUEUgfHxcbiAgICAgICAgICBudWxsICE9PSBjaGlsZC5rZXkgfHxcbiAgICAgICAgICBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8XG4gICAgICAgICAgKGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChudWxsICE9PSB0YXNrLmtleVBhdGgpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHJlcXVlc3QgPSBbXG4gICAgICAgICAgICBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuICAgICAgICAgICAgdGFzay5rZXlQYXRoLFxuICAgICAgICAgICAgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgMFxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHRhc2suaW1wbGljaXRTbG90ID8gW3JlcXVlc3RdIDogcmVxdWVzdFxuICAgICAgICApO1xuICAgICAgaWYgKChpID0gY2hpbGRyZW4uX2RlYnVnSW5mbykpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGRlYnVnSUQpIHJldHVybiBvdXRsaW5lVGFzayhyZXF1ZXN0LCB0YXNrKTtcbiAgICAgICAgZm9yd2FyZERlYnVnSW5mbyhyZXF1ZXN0LCBkZWJ1Z0lELCBpKTtcbiAgICAgICAgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyQXN5bmNGcmFnbWVudChyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbiwgZ2V0QXN5bmNJdGVyYXRvcikge1xuICAgICAgaWYgKG51bGwgIT09IHRhc2sua2V5UGF0aClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAocmVxdWVzdCA9IFtcbiAgICAgICAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUsXG4gICAgICAgICAgICB0YXNrLmtleVBhdGgsXG4gICAgICAgICAgICB7IGNoaWxkcmVuOiBjaGlsZHJlbiB9LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAwXG4gICAgICAgICAgXSksXG4gICAgICAgICAgdGFzay5pbXBsaWNpdFNsb3QgPyBbcmVxdWVzdF0gOiByZXF1ZXN0XG4gICAgICAgICk7XG4gICAgICBnZXRBc3luY0l0ZXJhdG9yID0gZ2V0QXN5bmNJdGVyYXRvci5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVBc3luY0l0ZXJhYmxlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuLCBnZXRBc3luY0l0ZXJhdG9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb3V0bGluZVRhc2socmVxdWVzdCwgdGFzaykge1xuICAgICAgdGFzayA9IGNyZWF0ZVRhc2soXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIHRhc2subW9kZWwsXG4gICAgICAgIHRhc2sua2V5UGF0aCxcbiAgICAgICAgdGFzay5pbXBsaWNpdFNsb3QsXG4gICAgICAgIHJlcXVlc3QuYWJvcnRhYmxlVGFza3MsXG4gICAgICAgIHRhc2suZGVidWdPd25lcixcbiAgICAgICAgdGFzay5kZWJ1Z1N0YWNrLFxuICAgICAgICB0YXNrLmRlYnVnVGFza1xuICAgICAgKTtcbiAgICAgIHJldHJ5VGFzayhyZXF1ZXN0LCB0YXNrKTtcbiAgICAgIHJldHVybiB0YXNrLnN0YXR1cyA9PT0gQ09NUExFVEVEXG4gICAgICAgID8gc2VyaWFsaXplQnlWYWx1ZUlEKHRhc2suaWQpXG4gICAgICAgIDogXCIkTFwiICsgdGFzay5pZC50b1N0cmluZygxNik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywgdHlwZSwga2V5LCByZWYsIHByb3BzLCB2YWxpZGF0ZWQpIHtcbiAgICAgIGlmIChudWxsICE9PSByZWYgJiYgdm9pZCAwICE9PSByZWYpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiUmVmcyBjYW5ub3QgYmUgdXNlZCBpbiBTZXJ2ZXIgQ29tcG9uZW50cywgbm9yIHBhc3NlZCB0byBDbGllbnQgQ29tcG9uZW50cy5cIlxuICAgICAgICApO1xuICAgICAganN4UHJvcHNQYXJlbnRzLnNldChwcm9wcywgdHlwZSk7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gJiZcbiAgICAgICAgbnVsbCAhPT0gcHJvcHMuY2hpbGRyZW4gJiZcbiAgICAgICAganN4Q2hpbGRyZW5QYXJlbnRzLnNldChwcm9wcy5jaGlsZHJlbiwgdHlwZSk7XG4gICAgICBpZiAoXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHR5cGUgfHxcbiAgICAgICAgaXNDbGllbnRSZWZlcmVuY2UodHlwZSkgfHxcbiAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gVEVNUE9SQVJZX1JFRkVSRU5DRV9UQUdcbiAgICAgICkge1xuICAgICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBudWxsID09PSBrZXkpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDIgPT09IHZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgICAoKHZhbGlkYXRlZCA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgZW52OiAoMCwgcmVxdWVzdC5lbnZpcm9ubWVudE5hbWUpKCksXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgb3duZXI6IHRhc2suZGVidWdPd25lcixcbiAgICAgICAgICAgICAgICBzdGFjazpcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IHRhc2suZGVidWdTdGFja1xuICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiBmaWx0ZXJTdGFja1RyYWNlKHJlcXVlc3QsIHRhc2suZGVidWdTdGFjaywgMSksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgIGRlYnVnU3RhY2s6IHRhc2suZGVidWdTdGFjayxcbiAgICAgICAgICAgICAgICBkZWJ1Z1Rhc2s6IHRhc2suZGVidWdUYXNrXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShyZXF1ZXN0LCBrZXksIHZhbGlkYXRlZCwgdGFzay5kZWJ1Z1Rhc2spKSxcbiAgICAgICAgICAgICh2YWxpZGF0ZWQgPSB0YXNrLmltcGxpY2l0U2xvdCksXG4gICAgICAgICAgICBudWxsID09PSB0YXNrLmtleVBhdGggJiYgKHRhc2suaW1wbGljaXRTbG90ID0gITApLFxuICAgICAgICAgICAgKHJlcXVlc3QgPSByZW5kZXJNb2RlbERlc3RydWN0aXZlKFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICBlbXB0eVJvb3QsXG4gICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgICh0YXNrLmltcGxpY2l0U2xvdCA9IHZhbGlkYXRlZCksXG4gICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG51bGwgIT0gdHlwZSAmJlxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgIWlzQ2xpZW50UmVmZXJlbmNlKHR5cGUpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICB0eXBlID0gY2FsbExhenlJbml0SW5ERVYodHlwZSk7XG4gICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gQUJPUlRJTkcpIHRocm93IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybiByZW5kZXJFbGVtZW50KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVkXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiByZW5kZXJGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHR5cGUucmVuZGVyLFxuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRlZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiByZW5kZXJFbGVtZW50KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgdGFzayxcbiAgICAgICAgICAgICAgICB0eXBlLnR5cGUsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZWRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICB0eXBlLl9zdG9yZS52YWxpZGF0ZWQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gcmVuZGVyRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICB0YXNrLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIHZhbGlkYXRlZFxuICAgICAgICApO1xuICAgICAgcmVmID0gdGFzay5rZXlQYXRoO1xuICAgICAgbnVsbCA9PT0ga2V5ID8gKGtleSA9IHJlZikgOiBudWxsICE9PSByZWYgJiYgKGtleSA9IHJlZiArIFwiLFwiICsga2V5KTtcbiAgICAgIG51bGwgIT09IHRhc2suZGVidWdPd25lciAmJlxuICAgICAgICBvdXRsaW5lQ29tcG9uZW50SW5mbyhyZXF1ZXN0LCB0YXNrLmRlYnVnT3duZXIpO1xuICAgICAgcmVxdWVzdCA9IFtcbiAgICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlLFxuICAgICAgICBrZXksXG4gICAgICAgIHByb3BzLFxuICAgICAgICB0YXNrLmRlYnVnT3duZXIsXG4gICAgICAgIG51bGwgPT09IHRhc2suZGVidWdTdGFja1xuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogZmlsdGVyU3RhY2tUcmFjZShyZXF1ZXN0LCB0YXNrLmRlYnVnU3RhY2ssIDEpLFxuICAgICAgICB2YWxpZGF0ZWRcbiAgICAgIF07XG4gICAgICB0YXNrID0gdGFzay5pbXBsaWNpdFNsb3QgJiYgbnVsbCAhPT0ga2V5ID8gW3JlcXVlc3RdIDogcmVxdWVzdDtcbiAgICAgIHJldHVybiB0YXNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKSB7XG4gICAgICB2YXIgcGluZ2VkVGFza3MgPSByZXF1ZXN0LnBpbmdlZFRhc2tzO1xuICAgICAgcGluZ2VkVGFza3MucHVzaCh0YXNrKTtcbiAgICAgIDEgPT09IHBpbmdlZFRhc2tzLmxlbmd0aCAmJlxuICAgICAgICAoKHJlcXVlc3QuZmx1c2hTY2hlZHVsZWQgPSBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uKSxcbiAgICAgICAgcmVxdWVzdC50eXBlID09PSBQUkVSRU5ERVIgfHwgcmVxdWVzdC5zdGF0dXMgPT09IE9QRU5JTkdcbiAgICAgICAgICA/IHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBlcmZvcm1Xb3JrKHJlcXVlc3QpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IHNldFRpbWVvdXRPckltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwZXJmb3JtV29yayhyZXF1ZXN0KTtcbiAgICAgICAgICAgIH0sIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVGFzayhcbiAgICAgIHJlcXVlc3QsXG4gICAgICBtb2RlbCxcbiAgICAgIGtleVBhdGgsXG4gICAgICBpbXBsaWNpdFNsb3QsXG4gICAgICBhYm9ydFNldCxcbiAgICAgIGRlYnVnT3duZXIsXG4gICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICByZXF1ZXN0LnBlbmRpbmdDaHVua3MrKztcbiAgICAgIHZhciBpZCA9IHJlcXVlc3QubmV4dENodW5rSWQrKztcbiAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBtb2RlbCB8fFxuICAgICAgICBudWxsID09PSBtb2RlbCB8fFxuICAgICAgICBudWxsICE9PSBrZXlQYXRoIHx8XG4gICAgICAgIGltcGxpY2l0U2xvdCB8fFxuICAgICAgICByZXF1ZXN0LndyaXR0ZW5PYmplY3RzLnNldChtb2RlbCwgc2VyaWFsaXplQnlWYWx1ZUlEKGlkKSk7XG4gICAgICB2YXIgdGFzayA9IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBzdGF0dXM6IFBFTkRJTkckMSxcbiAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICBrZXlQYXRoOiBrZXlQYXRoLFxuICAgICAgICBpbXBsaWNpdFNsb3Q6IGltcGxpY2l0U2xvdCxcbiAgICAgICAgcGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9KU09OOiBmdW5jdGlvbiAocGFyZW50UHJvcGVydHlOYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLFxuICAgICAgICAgICAgb3JpZ2luYWxWYWx1ZSA9IHBhcmVudFtwYXJlbnRQcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvcmlnaW5hbFZhbHVlIHx8XG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlID09PSB2YWx1ZSB8fFxuICAgICAgICAgICAgb3JpZ2luYWxWYWx1ZSBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgICAgICAgIGNhbGxXaXRoRGVidWdDb250ZXh0SW5ERVYocmVxdWVzdCwgdGFzaywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBcIk9iamVjdFwiICE9PSBvYmplY3ROYW1lKG9yaWdpbmFsVmFsdWUpXG4gICAgICAgICAgICAgICAgPyBcInN0cmluZ1wiID09PSB0eXBlb2YganN4Q2hpbGRyZW5QYXJlbnRzLmdldChwYXJlbnQpXG4gICAgICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCIlcyBvYmplY3RzIGNhbm5vdCBiZSByZW5kZXJlZCBhcyB0ZXh0IGNoaWxkcmVuLiBUcnkgZm9ybWF0dGluZyBpdCB1c2luZyB0b1N0cmluZygpLiVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgb2JqZWN0TmFtZShvcmlnaW5hbFZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShwYXJlbnQsIHBhcmVudFByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiT25seSBwbGFpbiBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdG8gQ2xpZW50IENvbXBvbmVudHMgZnJvbSBTZXJ2ZXIgQ29tcG9uZW50cy4gJXMgb2JqZWN0cyBhcmUgbm90IHN1cHBvcnRlZC4lc1wiLFxuICAgICAgICAgICAgICAgICAgICAgIG9iamVjdE5hbWUob3JpZ2luYWxWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UocGFyZW50LCBwYXJlbnRQcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiT25seSBwbGFpbiBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdG8gQ2xpZW50IENvbXBvbmVudHMgZnJvbSBTZXJ2ZXIgQ29tcG9uZW50cy4gT2JqZWN0cyB3aXRoIHRvSlNPTiBtZXRob2RzIGFyZSBub3Qgc3VwcG9ydGVkLiBDb252ZXJ0IGl0IG1hbnVhbGx5IHRvIGEgc2ltcGxlIHZhbHVlIGJlZm9yZSBwYXNzaW5nIGl0IHRvIHByb3BzLiVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHBhcmVudCwgcGFyZW50UHJvcGVydHlOYW1lKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZW5kZXJNb2RlbChyZXF1ZXN0LCB0YXNrLCBwYXJlbnQsIHBhcmVudFByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICB0aGVuYWJsZVN0YXRlOiBudWxsXG4gICAgICB9O1xuICAgICAgdGFzay5lbnZpcm9ubWVudE5hbWUgPSByZXF1ZXN0LmVudmlyb25tZW50TmFtZSgpO1xuICAgICAgdGFzay5kZWJ1Z093bmVyID0gZGVidWdPd25lcjtcbiAgICAgIHRhc2suZGVidWdTdGFjayA9IGRlYnVnU3RhY2s7XG4gICAgICB0YXNrLmRlYnVnVGFzayA9IGRlYnVnVGFzaztcbiAgICAgIGFib3J0U2V0LmFkZCh0YXNrKTtcbiAgICAgIHJldHVybiB0YXNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXJpYWxpemVCeVZhbHVlSUQoaWQpIHtcbiAgICAgIHJldHVybiBcIiRcIiArIGlkLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplTnVtYmVyKG51bWJlcikge1xuICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXG4gICAgICAgID8gMCA9PT0gbnVtYmVyICYmIC1JbmZpbml0eSA9PT0gMSAvIG51bWJlclxuICAgICAgICAgID8gXCIkLTBcIlxuICAgICAgICAgIDogbnVtYmVyXG4gICAgICAgIDogSW5maW5pdHkgPT09IG51bWJlclxuICAgICAgICAgID8gXCIkSW5maW5pdHlcIlxuICAgICAgICAgIDogLUluZmluaXR5ID09PSBudW1iZXJcbiAgICAgICAgICAgID8gXCIkLUluZmluaXR5XCJcbiAgICAgICAgICAgIDogXCIkTmFOXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZVJlZmVyZW5jZUNodW5rKHJlcXVlc3QsIGlkLCByZWZlcmVuY2UpIHtcbiAgICAgIHJlcXVlc3QgPSBzdHJpbmdpZnkocmVmZXJlbmNlKTtcbiAgICAgIGlkID0gaWQudG9TdHJpbmcoMTYpICsgXCI6XCIgKyByZXF1ZXN0ICsgXCJcXG5cIjtcbiAgICAgIHJldHVybiBzdHJpbmdUb0NodW5rKGlkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplQ2xpZW50UmVmZXJlbmNlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHBhcmVudCxcbiAgICAgIHBhcmVudFByb3BlcnR5TmFtZSxcbiAgICAgIGNsaWVudFJlZmVyZW5jZVxuICAgICkge1xuICAgICAgdmFyIGNsaWVudFJlZmVyZW5jZUtleSA9IGNsaWVudFJlZmVyZW5jZS4kJGFzeW5jXG4gICAgICAgICAgPyBjbGllbnRSZWZlcmVuY2UuJCRpZCArIFwiI2FzeW5jXCJcbiAgICAgICAgICA6IGNsaWVudFJlZmVyZW5jZS4kJGlkLFxuICAgICAgICB3cml0dGVuQ2xpZW50UmVmZXJlbmNlcyA9IHJlcXVlc3Qud3JpdHRlbkNsaWVudFJlZmVyZW5jZXMsXG4gICAgICAgIGV4aXN0aW5nSWQgPSB3cml0dGVuQ2xpZW50UmVmZXJlbmNlcy5nZXQoY2xpZW50UmVmZXJlbmNlS2V5KTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGV4aXN0aW5nSWQpXG4gICAgICAgIHJldHVybiBwYXJlbnRbMF0gPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJiBcIjFcIiA9PT0gcGFyZW50UHJvcGVydHlOYW1lXG4gICAgICAgICAgPyBcIiRMXCIgKyBleGlzdGluZ0lkLnRvU3RyaW5nKDE2KVxuICAgICAgICAgIDogc2VyaWFsaXplQnlWYWx1ZUlEKGV4aXN0aW5nSWQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHJlcXVlc3QuYnVuZGxlckNvbmZpZyxcbiAgICAgICAgICBtb2R1bGVQYXRoID0gY2xpZW50UmVmZXJlbmNlLiQkaWQ7XG4gICAgICAgIGV4aXN0aW5nSWQgPSBcIlwiO1xuICAgICAgICB2YXIgcmVzb2x2ZWRNb2R1bGVEYXRhID0gY29uZmlnW21vZHVsZVBhdGhdO1xuICAgICAgICBpZiAocmVzb2x2ZWRNb2R1bGVEYXRhKSBleGlzdGluZ0lkID0gcmVzb2x2ZWRNb2R1bGVEYXRhLm5hbWU7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBpZHggPSBtb2R1bGVQYXRoLmxhc3RJbmRleE9mKFwiI1wiKTtcbiAgICAgICAgICAtMSAhPT0gaWR4ICYmXG4gICAgICAgICAgICAoKGV4aXN0aW5nSWQgPSBtb2R1bGVQYXRoLnNsaWNlKGlkeCArIDEpKSxcbiAgICAgICAgICAgIChyZXNvbHZlZE1vZHVsZURhdGEgPSBjb25maWdbbW9kdWxlUGF0aC5zbGljZSgwLCBpZHgpXSkpO1xuICAgICAgICAgIGlmICghcmVzb2x2ZWRNb2R1bGVEYXRhKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICdDb3VsZCBub3QgZmluZCB0aGUgbW9kdWxlIFwiJyArXG4gICAgICAgICAgICAgICAgbW9kdWxlUGF0aCArXG4gICAgICAgICAgICAgICAgJ1wiIGluIHRoZSBSZWFjdCBDbGllbnQgTWFuaWZlc3QuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gdGhlIFJlYWN0IFNlcnZlciBDb21wb25lbnRzIGJ1bmRsZXIuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoITAgPT09IHJlc29sdmVkTW9kdWxlRGF0YS5hc3luYyAmJiAhMCA9PT0gY2xpZW50UmVmZXJlbmNlLiQkYXN5bmMpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIG1vZHVsZSBcIicgK1xuICAgICAgICAgICAgICBtb2R1bGVQYXRoICtcbiAgICAgICAgICAgICAgJ1wiIGlzIG1hcmtlZCBhcyBhbiBhc3luYyBFU00gbW9kdWxlIGJ1dCB3YXMgbG9hZGVkIGFzIGEgQ0pTIHByb3h5LiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIHRoZSBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50cyBidW5kbGVyLidcbiAgICAgICAgICApO1xuICAgICAgICB2YXIgY2xpZW50UmVmZXJlbmNlTWV0YWRhdGEgPVxuICAgICAgICAgICEwID09PSByZXNvbHZlZE1vZHVsZURhdGEuYXN5bmMgfHwgITAgPT09IGNsaWVudFJlZmVyZW5jZS4kJGFzeW5jXG4gICAgICAgICAgICA/IFtyZXNvbHZlZE1vZHVsZURhdGEuaWQsIHJlc29sdmVkTW9kdWxlRGF0YS5jaHVua3MsIGV4aXN0aW5nSWQsIDFdXG4gICAgICAgICAgICA6IFtyZXNvbHZlZE1vZHVsZURhdGEuaWQsIHJlc29sdmVkTW9kdWxlRGF0YS5jaHVua3MsIGV4aXN0aW5nSWRdO1xuICAgICAgICByZXF1ZXN0LnBlbmRpbmdDaHVua3MrKztcbiAgICAgICAgdmFyIGltcG9ydElkID0gcmVxdWVzdC5uZXh0Q2h1bmtJZCsrLFxuICAgICAgICAgIGpzb24gPSBzdHJpbmdpZnkoY2xpZW50UmVmZXJlbmNlTWV0YWRhdGEpLFxuICAgICAgICAgIHJvdyA9IGltcG9ydElkLnRvU3RyaW5nKDE2KSArIFwiOklcIiArIGpzb24gKyBcIlxcblwiLFxuICAgICAgICAgIHByb2Nlc3NlZENodW5rID0gc3RyaW5nVG9DaHVuayhyb3cpO1xuICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZEltcG9ydENodW5rcy5wdXNoKHByb2Nlc3NlZENodW5rKTtcbiAgICAgICAgd3JpdHRlbkNsaWVudFJlZmVyZW5jZXMuc2V0KGNsaWVudFJlZmVyZW5jZUtleSwgaW1wb3J0SWQpO1xuICAgICAgICByZXR1cm4gcGFyZW50WzBdID09PSBSRUFDVF9FTEVNRU5UX1RZUEUgJiYgXCIxXCIgPT09IHBhcmVudFByb3BlcnR5TmFtZVxuICAgICAgICAgID8gXCIkTFwiICsgaW1wb3J0SWQudG9TdHJpbmcoMTYpXG4gICAgICAgICAgOiBzZXJpYWxpemVCeVZhbHVlSUQoaW1wb3J0SWQpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHJlcXVlc3QucGVuZGluZ0NodW5rcysrLFxuICAgICAgICAgIChwYXJlbnQgPSByZXF1ZXN0Lm5leHRDaHVua0lkKyspLFxuICAgICAgICAgIChwYXJlbnRQcm9wZXJ0eU5hbWUgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIHgsIG51bGwpKSxcbiAgICAgICAgICBlbWl0RXJyb3JDaHVuayhyZXF1ZXN0LCBwYXJlbnQsIHBhcmVudFByb3BlcnR5TmFtZSwgeCksXG4gICAgICAgICAgc2VyaWFsaXplQnlWYWx1ZUlEKHBhcmVudClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb3V0bGluZU1vZGVsKHJlcXVlc3QsIHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IGNyZWF0ZVRhc2soXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBudWxsLFxuICAgICAgICAhMSxcbiAgICAgICAgcmVxdWVzdC5hYm9ydGFibGVUYXNrcyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICAgIHJldHJ5VGFzayhyZXF1ZXN0LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWUuaWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZVNlcnZlclJlZmVyZW5jZShyZXF1ZXN0LCBzZXJ2ZXJSZWZlcmVuY2UpIHtcbiAgICAgIHZhciB3cml0dGVuU2VydmVyUmVmZXJlbmNlcyA9IHJlcXVlc3Qud3JpdHRlblNlcnZlclJlZmVyZW5jZXMsXG4gICAgICAgIGV4aXN0aW5nSWQgPSB3cml0dGVuU2VydmVyUmVmZXJlbmNlcy5nZXQoc2VydmVyUmVmZXJlbmNlKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGV4aXN0aW5nSWQpIHJldHVybiBcIiRGXCIgKyBleGlzdGluZ0lkLnRvU3RyaW5nKDE2KTtcbiAgICAgIGV4aXN0aW5nSWQgPSBzZXJ2ZXJSZWZlcmVuY2UuJCRib3VuZDtcbiAgICAgIGV4aXN0aW5nSWQgPSBudWxsID09PSBleGlzdGluZ0lkID8gbnVsbCA6IFByb21pc2UucmVzb2x2ZShleGlzdGluZ0lkKTtcbiAgICAgIHZhciBpZCA9IHNlcnZlclJlZmVyZW5jZS4kJGlkLFxuICAgICAgICBsb2NhdGlvbiA9IG51bGwsXG4gICAgICAgIGVycm9yID0gc2VydmVyUmVmZXJlbmNlLiQkbG9jYXRpb247XG4gICAgICBlcnJvciAmJlxuICAgICAgICAoKGVycm9yID0gcGFyc2VTdGFja1RyYWNlKGVycm9yLCAxKSksXG4gICAgICAgIDAgPCBlcnJvci5sZW5ndGggJiYgKGxvY2F0aW9uID0gZXJyb3JbMF0pKTtcbiAgICAgIGV4aXN0aW5nSWQgPVxuICAgICAgICBudWxsICE9PSBsb2NhdGlvblxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIGJvdW5kOiBleGlzdGluZ0lkLFxuICAgICAgICAgICAgICBuYW1lOlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHNlcnZlclJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgPyBzZXJ2ZXJSZWZlcmVuY2UubmFtZVxuICAgICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgICBlbnY6ICgwLCByZXF1ZXN0LmVudmlyb25tZW50TmFtZSkoKSxcbiAgICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7IGlkOiBpZCwgYm91bmQ6IGV4aXN0aW5nSWQgfTtcbiAgICAgIHJlcXVlc3QgPSBvdXRsaW5lTW9kZWwocmVxdWVzdCwgZXhpc3RpbmdJZCk7XG4gICAgICB3cml0dGVuU2VydmVyUmVmZXJlbmNlcy5zZXQoc2VydmVyUmVmZXJlbmNlLCByZXF1ZXN0KTtcbiAgICAgIHJldHVybiBcIiRGXCIgKyByZXF1ZXN0LnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplTGFyZ2VUZXh0U3RyaW5nKHJlcXVlc3QsIHRleHQpIHtcbiAgICAgIHJlcXVlc3QucGVuZGluZ0NodW5rcysrO1xuICAgICAgdmFyIHRleHRJZCA9IHJlcXVlc3QubmV4dENodW5rSWQrKztcbiAgICAgIGVtaXRUZXh0Q2h1bmsocmVxdWVzdCwgdGV4dElkLCB0ZXh0KTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVCeVZhbHVlSUQodGV4dElkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplTWFwKHJlcXVlc3QsIG1hcCkge1xuICAgICAgbWFwID0gQXJyYXkuZnJvbShtYXApO1xuICAgICAgcmV0dXJuIFwiJFFcIiArIG91dGxpbmVNb2RlbChyZXF1ZXN0LCBtYXApLnRvU3RyaW5nKDE2KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplRm9ybURhdGEocmVxdWVzdCwgZm9ybURhdGEpIHtcbiAgICAgIGZvcm1EYXRhID0gQXJyYXkuZnJvbShmb3JtRGF0YS5lbnRyaWVzKCkpO1xuICAgICAgcmV0dXJuIFwiJEtcIiArIG91dGxpbmVNb2RlbChyZXF1ZXN0LCBmb3JtRGF0YSkudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXJpYWxpemVTZXQocmVxdWVzdCwgc2V0KSB7XG4gICAgICBzZXQgPSBBcnJheS5mcm9tKHNldCk7XG4gICAgICByZXR1cm4gXCIkV1wiICsgb3V0bGluZU1vZGVsKHJlcXVlc3QsIHNldCkudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXJpYWxpemVUeXBlZEFycmF5KHJlcXVlc3QsIHRhZywgdHlwZWRBcnJheSkge1xuICAgICAgcmVxdWVzdC5wZW5kaW5nQ2h1bmtzKys7XG4gICAgICB2YXIgYnVmZmVySWQgPSByZXF1ZXN0Lm5leHRDaHVua0lkKys7XG4gICAgICBlbWl0VHlwZWRBcnJheUNodW5rKHJlcXVlc3QsIGJ1ZmZlcklkLCB0YWcsIHR5cGVkQXJyYXkpO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZUJ5VmFsdWVJRChidWZmZXJJZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZUJsb2IocmVxdWVzdCwgYmxvYikge1xuICAgICAgZnVuY3Rpb24gcHJvZ3Jlc3MoZW50cnkpIHtcbiAgICAgICAgaWYgKCFhYm9ydGVkKVxuICAgICAgICAgIGlmIChlbnRyeS5kb25lKVxuICAgICAgICAgICAgcmVxdWVzdC5hYm9ydExpc3RlbmVycy5kZWxldGUoYWJvcnRCbG9iKSxcbiAgICAgICAgICAgICAgKGFib3J0ZWQgPSAhMCksXG4gICAgICAgICAgICAgIHBpbmdUYXNrKHJlcXVlc3QsIG5ld1Rhc2spO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIG1vZGVsLnB1c2goZW50cnkudmFsdWUpLCByZWFkZXIucmVhZCgpLnRoZW4ocHJvZ3Jlc3MpLmNhdGNoKGVycm9yKVxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVycm9yKHJlYXNvbikge1xuICAgICAgICBhYm9ydGVkIHx8XG4gICAgICAgICAgKChhYm9ydGVkID0gITApLFxuICAgICAgICAgIHJlcXVlc3QuYWJvcnRMaXN0ZW5lcnMuZGVsZXRlKGFib3J0QmxvYiksXG4gICAgICAgICAgZXJyb3JlZFRhc2socmVxdWVzdCwgbmV3VGFzaywgcmVhc29uKSxcbiAgICAgICAgICBlbnF1ZXVlRmx1c2gocmVxdWVzdCksXG4gICAgICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pLnRoZW4oZXJyb3IsIGVycm9yKSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhYm9ydEJsb2IocmVhc29uKSB7XG4gICAgICAgIGFib3J0ZWQgfHxcbiAgICAgICAgICAoKGFib3J0ZWQgPSAhMCksXG4gICAgICAgICAgcmVxdWVzdC5hYm9ydExpc3RlbmVycy5kZWxldGUoYWJvcnRCbG9iKSxcbiAgICAgICAgICBlcnJvcmVkVGFzayhyZXF1ZXN0LCBuZXdUYXNrLCByZWFzb24pLFxuICAgICAgICAgIGVucXVldWVGbHVzaChyZXF1ZXN0KSxcbiAgICAgICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbikudGhlbihlcnJvciwgZXJyb3IpKTtcbiAgICAgIH1cbiAgICAgIHZhciBtb2RlbCA9IFtibG9iLnR5cGVdLFxuICAgICAgICBuZXdUYXNrID0gY3JlYXRlVGFzayhcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgITEsXG4gICAgICAgICAgcmVxdWVzdC5hYm9ydGFibGVUYXNrcyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApLFxuICAgICAgICByZWFkZXIgPSBibG9iLnN0cmVhbSgpLmdldFJlYWRlcigpLFxuICAgICAgICBhYm9ydGVkID0gITE7XG4gICAgICByZXF1ZXN0LmFib3J0TGlzdGVuZXJzLmFkZChhYm9ydEJsb2IpO1xuICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKHByb2dyZXNzKS5jYXRjaChlcnJvcik7XG4gICAgICByZXR1cm4gXCIkQlwiICsgbmV3VGFzay5pZC50b1N0cmluZygxNik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlck1vZGVsKHJlcXVlc3QsIHRhc2ssIHBhcmVudCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHByZXZLZXlQYXRoID0gdGFzay5rZXlQYXRoLFxuICAgICAgICBwcmV2SW1wbGljaXRTbG90ID0gdGFzay5pbXBsaWNpdFNsb3Q7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVuZGVyTW9kZWxEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBwYXJlbnQsIGtleSwgdmFsdWUpO1xuICAgICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgICAgcGFyZW50ID0gdGFzay5tb2RlbDtcbiAgICAgICAgcGFyZW50ID1cbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcGFyZW50ICYmXG4gICAgICAgICAgbnVsbCAhPT0gcGFyZW50ICYmXG4gICAgICAgICAgKHBhcmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFIHx8XG4gICAgICAgICAgICBwYXJlbnQuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSk7XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gQUJPUlRJTkcpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0YXNrLnN0YXR1cyA9IEFCT1JURUQpLFxuICAgICAgICAgICAgKHRhc2sgPSByZXF1ZXN0LmZhdGFsRXJyb3IpLFxuICAgICAgICAgICAgcGFyZW50ID8gXCIkTFwiICsgdGFzay50b1N0cmluZygxNikgOiBzZXJpYWxpemVCeVZhbHVlSUQodGFzaylcbiAgICAgICAgICApO1xuICAgICAgICBrZXkgPVxuICAgICAgICAgIHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvblxuICAgICAgICAgICAgPyBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpXG4gICAgICAgICAgICA6IHRocm93blZhbHVlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGtleSAmJlxuICAgICAgICAgIG51bGwgIT09IGtleSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGtleS50aGVuXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJlcXVlc3QgPSBjcmVhdGVUYXNrKFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICB0YXNrLm1vZGVsLFxuICAgICAgICAgICAgICB0YXNrLmtleVBhdGgsXG4gICAgICAgICAgICAgIHRhc2suaW1wbGljaXRTbG90LFxuICAgICAgICAgICAgICByZXF1ZXN0LmFib3J0YWJsZVRhc2tzLFxuICAgICAgICAgICAgICB0YXNrLmRlYnVnT3duZXIsXG4gICAgICAgICAgICAgIHRhc2suZGVidWdTdGFjayxcbiAgICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2tcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHZhbHVlID0gcmVxdWVzdC5waW5nKSxcbiAgICAgICAgICAgIGtleS50aGVuKHZhbHVlLCB2YWx1ZSksXG4gICAgICAgICAgICAocmVxdWVzdC50aGVuYWJsZVN0YXRlID0gZ2V0VGhlbmFibGVTdGF0ZUFmdGVyU3VzcGVuZGluZygpKSxcbiAgICAgICAgICAgICh0YXNrLmtleVBhdGggPSBwcmV2S2V5UGF0aCksXG4gICAgICAgICAgICAodGFzay5pbXBsaWNpdFNsb3QgPSBwcmV2SW1wbGljaXRTbG90KSxcbiAgICAgICAgICAgIHBhcmVudFxuICAgICAgICAgICAgICA/IFwiJExcIiArIHJlcXVlc3QuaWQudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgIDogc2VyaWFsaXplQnlWYWx1ZUlEKHJlcXVlc3QuaWQpXG4gICAgICAgICAgKTtcbiAgICAgICAgdGFzay5rZXlQYXRoID0gcHJldktleVBhdGg7XG4gICAgICAgIHRhc2suaW1wbGljaXRTbG90ID0gcHJldkltcGxpY2l0U2xvdDtcbiAgICAgICAgcmVxdWVzdC5wZW5kaW5nQ2h1bmtzKys7XG4gICAgICAgIHByZXZLZXlQYXRoID0gcmVxdWVzdC5uZXh0Q2h1bmtJZCsrO1xuICAgICAgICB0YXNrID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBrZXksIHRhc2spO1xuICAgICAgICBlbWl0RXJyb3JDaHVuayhyZXF1ZXN0LCBwcmV2S2V5UGF0aCwgdGFzaywga2V5KTtcbiAgICAgICAgcmV0dXJuIHBhcmVudFxuICAgICAgICAgID8gXCIkTFwiICsgcHJldktleVBhdGgudG9TdHJpbmcoMTYpXG4gICAgICAgICAgOiBzZXJpYWxpemVCeVZhbHVlSUQocHJldktleVBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJNb2RlbERlc3RydWN0aXZlKFxuICAgICAgcmVxdWVzdCxcbiAgICAgIHRhc2ssXG4gICAgICBwYXJlbnQsXG4gICAgICBwYXJlbnRQcm9wZXJ0eU5hbWUsXG4gICAgICB2YWx1ZVxuICAgICkge1xuICAgICAgdGFzay5tb2RlbCA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHJldHVybiBcIiRcIjtcbiAgICAgIGlmIChudWxsID09PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgIHZhciBlbGVtZW50UmVmZXJlbmNlID0gbnVsbCxcbiAgICAgICAgICAgICAgX3dyaXR0ZW5PYmplY3RzID0gcmVxdWVzdC53cml0dGVuT2JqZWN0cztcbiAgICAgICAgICAgIGlmIChudWxsID09PSB0YXNrLmtleVBhdGggJiYgIXRhc2suaW1wbGljaXRTbG90KSB7XG4gICAgICAgICAgICAgIHZhciBfZXhpc3RpbmdSZWZlcmVuY2UgPSBfd3JpdHRlbk9iamVjdHMuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gX2V4aXN0aW5nUmVmZXJlbmNlKVxuICAgICAgICAgICAgICAgIGlmIChtb2RlbFJvb3QgPT09IHZhbHVlKSBtb2RlbFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIF9leGlzdGluZ1JlZmVyZW5jZTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC0xID09PSBwYXJlbnRQcm9wZXJ0eU5hbWUuaW5kZXhPZihcIjpcIikgJiZcbiAgICAgICAgICAgICAgICAgICgoX2V4aXN0aW5nUmVmZXJlbmNlID0gX3dyaXR0ZW5PYmplY3RzLmdldChwYXJlbnQpKSxcbiAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gX2V4aXN0aW5nUmVmZXJlbmNlICYmXG4gICAgICAgICAgICAgICAgICAgICgoZWxlbWVudFJlZmVyZW5jZSA9XG4gICAgICAgICAgICAgICAgICAgICAgX2V4aXN0aW5nUmVmZXJlbmNlICsgXCI6XCIgKyBwYXJlbnRQcm9wZXJ0eU5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBfd3JpdHRlbk9iamVjdHMuc2V0KHZhbHVlLCBlbGVtZW50UmVmZXJlbmNlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChfZXhpc3RpbmdSZWZlcmVuY2UgPSB2YWx1ZS5fZGVidWdJbmZvKSkge1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gZGVidWdJRCkgcmV0dXJuIG91dGxpbmVUYXNrKHJlcXVlc3QsIHRhc2spO1xuICAgICAgICAgICAgICBmb3J3YXJkRGVidWdJbmZvKHJlcXVlc3QsIGRlYnVnSUQsIF9leGlzdGluZ1JlZmVyZW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZXhpc3RpbmdSZWZlcmVuY2UgPSB2YWx1ZS5wcm9wcztcbiAgICAgICAgICAgIHZhciByZWZQcm9wID0gX2V4aXN0aW5nUmVmZXJlbmNlLnJlZjtcbiAgICAgICAgICAgIHRhc2suZGVidWdPd25lciA9IHZhbHVlLl9vd25lcjtcbiAgICAgICAgICAgIHRhc2suZGVidWdTdGFjayA9IHZhbHVlLl9kZWJ1Z1N0YWNrO1xuICAgICAgICAgICAgdGFzay5kZWJ1Z1Rhc2sgPSB2YWx1ZS5fZGVidWdUYXNrO1xuICAgICAgICAgICAgcmVxdWVzdCA9IHJlbmRlckVsZW1lbnQoXG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgIHZhbHVlLnR5cGUsXG4gICAgICAgICAgICAgIHZhbHVlLmtleSxcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSByZWZQcm9wID8gcmVmUHJvcCA6IG51bGwsXG4gICAgICAgICAgICAgIF9leGlzdGluZ1JlZmVyZW5jZSxcbiAgICAgICAgICAgICAgdmFsdWUuX3N0b3JlLnZhbGlkYXRlZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXF1ZXN0ICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHJlcXVlc3QgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZWxlbWVudFJlZmVyZW5jZSAmJlxuICAgICAgICAgICAgICAoX3dyaXR0ZW5PYmplY3RzLmhhcyhyZXF1ZXN0KSB8fFxuICAgICAgICAgICAgICAgIF93cml0dGVuT2JqZWN0cy5zZXQocmVxdWVzdCwgZWxlbWVudFJlZmVyZW5jZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB0YXNrLnRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgZWxlbWVudFJlZmVyZW5jZSA9IGNhbGxMYXp5SW5pdEluREVWKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gQUJPUlRJTkcpIHRocm93IG51bGw7XG4gICAgICAgICAgICBpZiAoKF93cml0dGVuT2JqZWN0cyA9IHZhbHVlLl9kZWJ1Z0luZm8pKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSBkZWJ1Z0lEKSByZXR1cm4gb3V0bGluZVRhc2socmVxdWVzdCwgdGFzayk7XG4gICAgICAgICAgICAgIGZvcndhcmREZWJ1Z0luZm8ocmVxdWVzdCwgZGVidWdJRCwgX3dyaXR0ZW5PYmplY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW5kZXJNb2RlbERlc3RydWN0aXZlKFxuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICBlbXB0eVJvb3QsXG4gICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICAgIGVsZW1lbnRSZWZlcmVuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICdBIFJlYWN0IEVsZW1lbnQgZnJvbSBhbiBvbGRlciB2ZXJzaW9uIG9mIFJlYWN0IHdhcyByZW5kZXJlZC4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJdCBjYW4gaGFwcGVuIGlmOlxcbi0gTXVsdGlwbGUgY29waWVzIG9mIHRoZSBcInJlYWN0XCIgcGFja2FnZSBpcyB1c2VkLlxcbi0gQSBsaWJyYXJ5IHByZS1idW5kbGVkIGFuIG9sZCBjb3B5IG9mIFwicmVhY3RcIiBvciBcInJlYWN0L2pzeC1ydW50aW1lXCIuXFxuLSBBIGNvbXBpbGVyIHRyaWVzIHRvIFwiaW5saW5lXCIgSlNYIGluc3RlYWQgb2YgdXNpbmcgdGhlIHJ1bnRpbWUuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDbGllbnRSZWZlcmVuY2UodmFsdWUpKVxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVDbGllbnRSZWZlcmVuY2UoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgcGFyZW50UHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdm9pZCAwICE9PSByZXF1ZXN0LnRlbXBvcmFyeVJlZmVyZW5jZXMgJiZcbiAgICAgICAgICAoKGVsZW1lbnRSZWZlcmVuY2UgPSByZXF1ZXN0LnRlbXBvcmFyeVJlZmVyZW5jZXMuZ2V0KHZhbHVlKSksXG4gICAgICAgICAgdm9pZCAwICE9PSBlbGVtZW50UmVmZXJlbmNlKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIFwiJFRcIiArIGVsZW1lbnRSZWZlcmVuY2U7XG4gICAgICAgIGVsZW1lbnRSZWZlcmVuY2UgPSByZXF1ZXN0LndyaXR0ZW5PYmplY3RzO1xuICAgICAgICBfd3JpdHRlbk9iamVjdHMgPSBlbGVtZW50UmVmZXJlbmNlLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50aGVuKSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gX3dyaXR0ZW5PYmplY3RzKSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gdGFzay5rZXlQYXRoIHx8IHRhc2suaW1wbGljaXRTbG90KVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIFwiJEBcIiArIHNlcmlhbGl6ZVRoZW5hYmxlKHJlcXVlc3QsIHRhc2ssIHZhbHVlKS50b1N0cmluZygxNilcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChtb2RlbFJvb3QgPT09IHZhbHVlKSBtb2RlbFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gX3dyaXR0ZW5PYmplY3RzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXF1ZXN0ID0gXCIkQFwiICsgc2VyaWFsaXplVGhlbmFibGUocmVxdWVzdCwgdGFzaywgdmFsdWUpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICBlbGVtZW50UmVmZXJlbmNlLnNldCh2YWx1ZSwgcmVxdWVzdCk7XG4gICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gX3dyaXR0ZW5PYmplY3RzKVxuICAgICAgICAgIGlmIChtb2RlbFJvb3QgPT09IHZhbHVlKSBtb2RlbFJvb3QgPSBudWxsO1xuICAgICAgICAgIGVsc2UgcmV0dXJuIF93cml0dGVuT2JqZWN0cztcbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgLTEgPT09IHBhcmVudFByb3BlcnR5TmFtZS5pbmRleE9mKFwiOlwiKSAmJlxuICAgICAgICAgICgoX3dyaXR0ZW5PYmplY3RzID0gZWxlbWVudFJlZmVyZW5jZS5nZXQocGFyZW50KSksXG4gICAgICAgICAgdm9pZCAwICE9PSBfd3JpdHRlbk9iamVjdHMpXG4gICAgICAgICkge1xuICAgICAgICAgIF9leGlzdGluZ1JlZmVyZW5jZSA9IHBhcmVudFByb3BlcnR5TmFtZTtcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwocGFyZW50KSAmJiBwYXJlbnRbMF0gPT09IFJFQUNUX0VMRU1FTlRfVFlQRSlcbiAgICAgICAgICAgIHN3aXRjaCAocGFyZW50UHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgICAgICAgX2V4aXN0aW5nUmVmZXJlbmNlID0gXCJ0eXBlXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgICAgICAgICAgX2V4aXN0aW5nUmVmZXJlbmNlID0gXCJrZXlcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgICAgICAgICBfZXhpc3RpbmdSZWZlcmVuY2UgPSBcInByb3BzXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgICAgICAgX2V4aXN0aW5nUmVmZXJlbmNlID0gXCJfb3duZXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50UmVmZXJlbmNlLnNldChcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgX3dyaXR0ZW5PYmplY3RzICsgXCI6XCIgKyBfZXhpc3RpbmdSZWZlcmVuY2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5SW1wbCh2YWx1ZSkpIHJldHVybiByZW5kZXJGcmFnbWVudChyZXF1ZXN0LCB0YXNrLCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkgcmV0dXJuIHNlcmlhbGl6ZU1hcChyZXF1ZXN0LCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkgcmV0dXJuIHNlcmlhbGl6ZVNldChyZXF1ZXN0LCB2YWx1ZSk7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBGb3JtRGF0YSAmJiB2YWx1ZSBpbnN0YW5jZW9mIEZvcm1EYXRhKVxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVGb3JtRGF0YShyZXF1ZXN0LCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gc2VyaWFsaXplRXJyb3JWYWx1ZShyZXF1ZXN0LCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KHJlcXVlc3QsIFwiQVwiLCBuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkocmVxdWVzdCwgXCJPXCIsIHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZWRBcnJheShyZXF1ZXN0LCBcIm9cIiwgdmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSlcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZWRBcnJheShyZXF1ZXN0LCBcIlVcIiwgdmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnQxNkFycmF5KVxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KHJlcXVlc3QsIFwiU1wiLCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KVxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KHJlcXVlc3QsIFwic1wiLCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludDMyQXJyYXkpXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkocmVxdWVzdCwgXCJMXCIsIHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDMyQXJyYXkpXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGVkQXJyYXkocmVxdWVzdCwgXCJsXCIsIHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KVxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KHJlcXVlc3QsIFwiR1wiLCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSlcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZWRBcnJheShyZXF1ZXN0LCBcImdcIiwgdmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdJbnQ2NEFycmF5KVxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KHJlcXVlc3QsIFwiTVwiLCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpZ1VpbnQ2NEFycmF5KVxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KHJlcXVlc3QsIFwibVwiLCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3KVxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUeXBlZEFycmF5KHJlcXVlc3QsIFwiVlwiLCB2YWx1ZSk7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBCbG9iICYmIHZhbHVlIGluc3RhbmNlb2YgQmxvYilcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplQmxvYihyZXF1ZXN0LCB2YWx1ZSk7XG4gICAgICAgIGlmICgoZWxlbWVudFJlZmVyZW5jZSA9IGdldEl0ZXJhdG9yRm4odmFsdWUpKSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGVsZW1lbnRSZWZlcmVuY2UgPSBlbGVtZW50UmVmZXJlbmNlLmNhbGwodmFsdWUpKSxcbiAgICAgICAgICAgIGVsZW1lbnRSZWZlcmVuY2UgPT09IHZhbHVlXG4gICAgICAgICAgICAgID8gXCIkaVwiICtcbiAgICAgICAgICAgICAgICBvdXRsaW5lTW9kZWwocmVxdWVzdCwgQXJyYXkuZnJvbShlbGVtZW50UmVmZXJlbmNlKSkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgIDogcmVuZGVyRnJhZ21lbnQocmVxdWVzdCwgdGFzaywgQXJyYXkuZnJvbShlbGVtZW50UmVmZXJlbmNlKSlcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgUmVhZGFibGVTdHJlYW0gJiZcbiAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplUmVhZGFibGVTdHJlYW0ocmVxdWVzdCwgdGFzaywgdmFsdWUpO1xuICAgICAgICBlbGVtZW50UmVmZXJlbmNlID0gdmFsdWVbQVNZTkNfSVRFUkFUT1JdO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZWxlbWVudFJlZmVyZW5jZSlcbiAgICAgICAgICByZXR1cm4gcmVuZGVyQXN5bmNGcmFnbWVudChyZXF1ZXN0LCB0YXNrLCB2YWx1ZSwgZWxlbWVudFJlZmVyZW5jZSk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBcIiREXCIgKyB2YWx1ZS50b0pTT04oKTtcbiAgICAgICAgZWxlbWVudFJlZmVyZW5jZSA9IGdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGVsZW1lbnRSZWZlcmVuY2UgIT09IE9iamVjdFByb3RvdHlwZSAmJlxuICAgICAgICAgIChudWxsID09PSBlbGVtZW50UmVmZXJlbmNlIHx8XG4gICAgICAgICAgICBudWxsICE9PSBnZXRQcm90b3R5cGVPZihlbGVtZW50UmVmZXJlbmNlKSlcbiAgICAgICAgKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJPbmx5IHBsYWluIG9iamVjdHMsIGFuZCBhIGZldyBidWlsdC1pbnMsIGNhbiBiZSBwYXNzZWQgdG8gQ2xpZW50IENvbXBvbmVudHMgZnJvbSBTZXJ2ZXIgQ29tcG9uZW50cy4gQ2xhc3NlcyBvciBudWxsIHByb3RvdHlwZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXCIgK1xuICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShwYXJlbnQsIHBhcmVudFByb3BlcnR5TmFtZSlcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoXCJPYmplY3RcIiAhPT0gb2JqZWN0TmFtZSh2YWx1ZSkpXG4gICAgICAgICAgY2FsbFdpdGhEZWJ1Z0NvbnRleHRJbkRFVihyZXF1ZXN0LCB0YXNrLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIk9ubHkgcGxhaW4gb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHRvIENsaWVudCBDb21wb25lbnRzIGZyb20gU2VydmVyIENvbXBvbmVudHMuICVzIG9iamVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQuJXNcIixcbiAgICAgICAgICAgICAgb2JqZWN0TmFtZSh2YWx1ZSksXG4gICAgICAgICAgICAgIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHBhcmVudCwgcGFyZW50UHJvcGVydHlOYW1lKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgZWxzZSBpZiAoIWlzU2ltcGxlT2JqZWN0KHZhbHVlKSlcbiAgICAgICAgICBjYWxsV2l0aERlYnVnQ29udGV4dEluREVWKHJlcXVlc3QsIHRhc2ssIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiT25seSBwbGFpbiBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdG8gQ2xpZW50IENvbXBvbmVudHMgZnJvbSBTZXJ2ZXIgQ29tcG9uZW50cy4gQ2xhc3NlcyBvciBvdGhlciBvYmplY3RzIHdpdGggbWV0aG9kcyBhcmUgbm90IHN1cHBvcnRlZC4lc1wiLFxuICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShwYXJlbnQsIHBhcmVudFByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpO1xuICAgICAgICAgIDAgPCBzeW1ib2xzLmxlbmd0aCAmJlxuICAgICAgICAgICAgY2FsbFdpdGhEZWJ1Z0NvbnRleHRJbkRFVihyZXF1ZXN0LCB0YXNrLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJPbmx5IHBsYWluIG9iamVjdHMgY2FuIGJlIHBhc3NlZCB0byBDbGllbnQgQ29tcG9uZW50cyBmcm9tIFNlcnZlciBDb21wb25lbnRzLiBPYmplY3RzIHdpdGggc3ltYm9sIHByb3BlcnRpZXMgbGlrZSAlcyBhcmUgbm90IHN1cHBvcnRlZC4lc1wiLFxuICAgICAgICAgICAgICAgIHN5bWJvbHNbMF0uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UocGFyZW50LCBwYXJlbnRQcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHZhbHVlKVxuICAgICAgICByZXR1cm4gXCJaXCIgPT09IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICYmXG4gICAgICAgICAgcGFyZW50W3BhcmVudFByb3BlcnR5TmFtZV0gaW5zdGFuY2VvZiBEYXRlXG4gICAgICAgICAgPyBcIiREXCIgKyB2YWx1ZVxuICAgICAgICAgIDogMTAyNCA8PSB2YWx1ZS5sZW5ndGggJiYgbnVsbCAhPT0gYnl0ZUxlbmd0aE9mQ2h1bmtcbiAgICAgICAgICAgID8gc2VyaWFsaXplTGFyZ2VUZXh0U3RyaW5nKHJlcXVlc3QsIHZhbHVlKVxuICAgICAgICAgICAgOiBcIiRcIiA9PT0gdmFsdWVbMF1cbiAgICAgICAgICAgICAgPyBcIiRcIiArIHZhbHVlXG4gICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICBpZiAoXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZSkgcmV0dXJuIHZhbHVlO1xuICAgICAgaWYgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSkgcmV0dXJuIHNlcmlhbGl6ZU51bWJlcih2YWx1ZSk7XG4gICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHZhbHVlKSByZXR1cm4gXCIkdW5kZWZpbmVkXCI7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQ2xpZW50UmVmZXJlbmNlKHZhbHVlKSlcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplQ2xpZW50UmVmZXJlbmNlKFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIHBhcmVudFByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mID09PSBTRVJWRVJfUkVGRVJFTkNFX1RBRylcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplU2VydmVyUmVmZXJlbmNlKHJlcXVlc3QsIHZhbHVlKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHZvaWQgMCAhPT0gcmVxdWVzdC50ZW1wb3JhcnlSZWZlcmVuY2VzICYmXG4gICAgICAgICAgKChyZXF1ZXN0ID0gcmVxdWVzdC50ZW1wb3JhcnlSZWZlcmVuY2VzLmdldCh2YWx1ZSkpLFxuICAgICAgICAgIHZvaWQgMCAhPT0gcmVxdWVzdClcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiBcIiRUXCIgKyByZXF1ZXN0O1xuICAgICAgICBpZiAodmFsdWUuJCR0eXBlb2YgPT09IFRFTVBPUkFSWV9SRUZFUkVOQ0VfVEFHKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJDb3VsZCBub3QgcmVmZXJlbmNlIGFuIG9wYXF1ZSB0ZW1wb3JhcnkgcmVmZXJlbmNlLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gbWlzY29uZmlndXJpbmcgdGhlIHRlbXBvcmFyeVJlZmVyZW5jZXMgb3B0aW9ucyBvbiB0aGUgc2VydmVyLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKC9eb25bQS1aXS8udGVzdChwYXJlbnRQcm9wZXJ0eU5hbWUpKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFdmVudCBoYW5kbGVycyBjYW5ub3QgYmUgcGFzc2VkIHRvIENsaWVudCBDb21wb25lbnQgcHJvcHMuXCIgK1xuICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShwYXJlbnQsIHBhcmVudFByb3BlcnR5TmFtZSkgK1xuICAgICAgICAgICAgICBcIlxcbklmIHlvdSBuZWVkIGludGVyYWN0aXZpdHksIGNvbnNpZGVyIGNvbnZlcnRpbmcgcGFydCBvZiB0aGlzIHRvIGEgQ2xpZW50IENvbXBvbmVudC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBqc3hDaGlsZHJlblBhcmVudHMuaGFzKHBhcmVudCkgfHxcbiAgICAgICAgICAoanN4UHJvcHNQYXJlbnRzLmhhcyhwYXJlbnQpICYmIFwiY2hpbGRyZW5cIiA9PT0gcGFyZW50UHJvcGVydHlOYW1lKVxuICAgICAgICApXG4gICAgICAgICAgdGhyb3cgKFxuICAgICAgICAgICAgKChyZXF1ZXN0ID0gdmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubmFtZSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICBcIkZ1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgY2hpbGQgb2YgQ2xpZW50IENvbXBvbmVudHMuIFRoaXMgbWF5IGhhcHBlbiBpZiB5b3UgcmV0dXJuIFwiICtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ICtcbiAgICAgICAgICAgICAgICBcIiBpbnN0ZWFkIG9mIDxcIiArXG4gICAgICAgICAgICAgICAgcmVxdWVzdCArXG4gICAgICAgICAgICAgICAgXCIgLz4gZnJvbSByZW5kZXIuIE9yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LlwiICtcbiAgICAgICAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShwYXJlbnQsIHBhcmVudFByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgJ0Z1bmN0aW9ucyBjYW5ub3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIENsaWVudCBDb21wb25lbnRzIHVubGVzcyB5b3UgZXhwbGljaXRseSBleHBvc2UgaXQgYnkgbWFya2luZyBpdCB3aXRoIFwidXNlIHNlcnZlclwiLiBPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nICtcbiAgICAgICAgICAgIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHBhcmVudCwgcGFyZW50UHJvcGVydHlOYW1lKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICB0YXNrID0gcmVxdWVzdC53cml0dGVuU3ltYm9scztcbiAgICAgICAgZWxlbWVudFJlZmVyZW5jZSA9IHRhc2suZ2V0KHZhbHVlKTtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gZWxlbWVudFJlZmVyZW5jZSlcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplQnlWYWx1ZUlEKGVsZW1lbnRSZWZlcmVuY2UpO1xuICAgICAgICBlbGVtZW50UmVmZXJlbmNlID0gdmFsdWUuZGVzY3JpcHRpb247XG4gICAgICAgIGlmIChTeW1ib2wuZm9yKGVsZW1lbnRSZWZlcmVuY2UpICE9PSB2YWx1ZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiT25seSBnbG9iYWwgc3ltYm9scyByZWNlaXZlZCBmcm9tIFN5bWJvbC5mb3IoLi4uKSBjYW4gYmUgcGFzc2VkIHRvIENsaWVudCBDb21wb25lbnRzLiBUaGUgc3ltYm9sIFN5bWJvbC5mb3IoXCIgK1xuICAgICAgICAgICAgICAodmFsdWUuZGVzY3JpcHRpb24gKyBcIikgY2Fubm90IGJlIGZvdW5kIGFtb25nIGdsb2JhbCBzeW1ib2xzLlwiKSArXG4gICAgICAgICAgICAgIGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKHBhcmVudCwgcGFyZW50UHJvcGVydHlOYW1lKVxuICAgICAgICAgICk7XG4gICAgICAgIHJlcXVlc3QucGVuZGluZ0NodW5rcysrO1xuICAgICAgICBfd3JpdHRlbk9iamVjdHMgPSByZXF1ZXN0Lm5leHRDaHVua0lkKys7XG4gICAgICAgIGVtaXRTeW1ib2xDaHVuayhyZXF1ZXN0LCBfd3JpdHRlbk9iamVjdHMsIGVsZW1lbnRSZWZlcmVuY2UpO1xuICAgICAgICB0YXNrLnNldCh2YWx1ZSwgX3dyaXR0ZW5PYmplY3RzKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUJ5VmFsdWVJRChfd3JpdHRlbk9iamVjdHMpO1xuICAgICAgfVxuICAgICAgaWYgKFwiYmlnaW50XCIgPT09IHR5cGVvZiB2YWx1ZSkgcmV0dXJuIFwiJG5cIiArIHZhbHVlLnRvU3RyaW5nKDEwKTtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIlR5cGUgXCIgK1xuICAgICAgICAgIHR5cGVvZiB2YWx1ZSArXG4gICAgICAgICAgXCIgaXMgbm90IHN1cHBvcnRlZCBpbiBDbGllbnQgQ29tcG9uZW50IHByb3BzLlwiICtcbiAgICAgICAgICBkZXNjcmliZU9iamVjdEZvckVycm9yTWVzc2FnZShwYXJlbnQsIHBhcmVudFByb3BlcnR5TmFtZSlcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IsIHRhc2spIHtcbiAgICAgIHZhciBwcmV2UmVxdWVzdCA9IGN1cnJlbnRSZXF1ZXN0O1xuICAgICAgY3VycmVudFJlcXVlc3QgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG9uRXJyb3IgPSByZXF1ZXN0Lm9uRXJyb3I7XG4gICAgICAgIHZhciBlcnJvckRpZ2VzdCA9XG4gICAgICAgICAgbnVsbCAhPT0gdGFza1xuICAgICAgICAgICAgPyBzdXBwb3J0c1JlcXVlc3RTdG9yYWdlXG4gICAgICAgICAgICAgID8gcmVxdWVzdFN0b3JhZ2UucnVuKFxuICAgICAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgY2FsbFdpdGhEZWJ1Z0NvbnRleHRJbkRFVixcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICB0YXNrLFxuICAgICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNhbGxXaXRoRGVidWdDb250ZXh0SW5ERVYocmVxdWVzdCwgdGFzaywgb25FcnJvciwgZXJyb3IpXG4gICAgICAgICAgICA6IHN1cHBvcnRzUmVxdWVzdFN0b3JhZ2VcbiAgICAgICAgICAgICAgPyByZXF1ZXN0U3RvcmFnZS5ydW4odm9pZCAwLCBvbkVycm9yLCBlcnJvcilcbiAgICAgICAgICAgICAgOiBvbkVycm9yKGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGN1cnJlbnRSZXF1ZXN0ID0gcHJldlJlcXVlc3Q7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPSBlcnJvckRpZ2VzdCAmJiBcInN0cmluZ1wiICE9PSB0eXBlb2YgZXJyb3JEaWdlc3QpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdvbkVycm9yIHJldHVybmVkIHNvbWV0aGluZyB3aXRoIGEgdHlwZSBvdGhlciB0aGFuIFwic3RyaW5nXCIuIG9uRXJyb3Igc2hvdWxkIHJldHVybiBhIHN0cmluZyBhbmQgbWF5IHJldHVybiBudWxsIG9yIHVuZGVmaW5lZCBidXQgbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGVsc2UuIEl0IHJlY2VpdmVkIHNvbWV0aGluZyBvZiB0eXBlIFwiJyArXG4gICAgICAgICAgICB0eXBlb2YgZXJyb3JEaWdlc3QgK1xuICAgICAgICAgICAgJ1wiIGluc3RlYWQnXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gZXJyb3JEaWdlc3QgfHwgXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcikge1xuICAgICAgdmFyIG9uRmF0YWxFcnJvciA9IHJlcXVlc3Qub25GYXRhbEVycm9yO1xuICAgICAgb25GYXRhbEVycm9yKGVycm9yKTtcbiAgICAgIG51bGwgIT09IHJlcXVlc3QuZGVzdGluYXRpb25cbiAgICAgICAgPyAoKHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEKSxcbiAgICAgICAgICBjbG9zZVdpdGhFcnJvcihyZXF1ZXN0LmRlc3RpbmF0aW9uLCBlcnJvcikpXG4gICAgICAgIDogKChyZXF1ZXN0LnN0YXR1cyA9IENMT1NJTkcpLCAocmVxdWVzdC5mYXRhbEVycm9yID0gZXJyb3IpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplRXJyb3JWYWx1ZShyZXF1ZXN0LCBlcnJvcikge1xuICAgICAgdmFyIG5hbWUgPSBcIkVycm9yXCIsXG4gICAgICAgIGVudiA9ICgwLCByZXF1ZXN0LmVudmlyb25tZW50TmFtZSkoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5hbWUgPSBlcnJvci5uYW1lO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFN0cmluZyhlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgdmFyIHN0YWNrID0gZmlsdGVyU3RhY2tUcmFjZShyZXF1ZXN0LCBlcnJvciwgMCk7XG4gICAgICAgIHZhciBlcnJvckVudiA9IGVycm9yLmVudmlyb25tZW50TmFtZTtcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yRW52ICYmIChlbnYgPSBlcnJvckVudik7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIChtZXNzYWdlID1cbiAgICAgICAgICBcIkFuIGVycm9yIG9jY3VycmVkIGJ1dCBzZXJpYWxpemluZyB0aGUgZXJyb3IgbWVzc2FnZSBmYWlsZWQuXCIpLFxuICAgICAgICAgIChzdGFjayA9IFtdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgIFwiJFpcIiArXG4gICAgICAgIG91dGxpbmVNb2RlbChyZXF1ZXN0LCB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgIHN0YWNrOiBzdGFjayxcbiAgICAgICAgICBlbnY6IGVudlxuICAgICAgICB9KS50b1N0cmluZygxNilcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtaXRFcnJvckNodW5rKHJlcXVlc3QsIGlkLCBkaWdlc3QsIGVycm9yKSB7XG4gICAgICB2YXIgbmFtZSA9IFwiRXJyb3JcIixcbiAgICAgICAgZW52ID0gKDAsIHJlcXVlc3QuZW52aXJvbm1lbnROYW1lKSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBuYW1lID0gZXJyb3IubmFtZTtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IFN0cmluZyhlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBmaWx0ZXJTdGFja1RyYWNlKHJlcXVlc3QsIGVycm9yLCAwKTtcbiAgICAgICAgICB2YXIgZXJyb3JFbnYgPSBlcnJvci5lbnZpcm9ubWVudE5hbWU7XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yRW52ICYmIChlbnYgPSBlcnJvckVudik7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIChtZXNzYWdlID1cbiAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJiBudWxsICE9PSBlcnJvclxuICAgICAgICAgICAgICA/IGRlc2NyaWJlT2JqZWN0Rm9yRXJyb3JNZXNzYWdlKGVycm9yKVxuICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvcikpLFxuICAgICAgICAgICAgKHN0YWNrID0gW10pO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAobWVzc2FnZSA9XG4gICAgICAgICAgXCJBbiBlcnJvciBvY2N1cnJlZCBidXQgc2VyaWFsaXppbmcgdGhlIGVycm9yIG1lc3NhZ2UgZmFpbGVkLlwiKSxcbiAgICAgICAgICAoc3RhY2sgPSBbXSk7XG4gICAgICB9XG4gICAgICBkaWdlc3QgPSB7XG4gICAgICAgIGRpZ2VzdDogZGlnZXN0LFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBzdGFjazogc3RhY2ssXG4gICAgICAgIGVudjogZW52XG4gICAgICB9O1xuICAgICAgaWQgPSBpZC50b1N0cmluZygxNikgKyBcIjpFXCIgKyBzdHJpbmdpZnkoZGlnZXN0KSArIFwiXFxuXCI7XG4gICAgICBpZCA9IHN0cmluZ1RvQ2h1bmsoaWQpO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRFcnJvckNodW5rcy5wdXNoKGlkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW1pdFN5bWJvbENodW5rKHJlcXVlc3QsIGlkLCBuYW1lKSB7XG4gICAgICBpZCA9IGVuY29kZVJlZmVyZW5jZUNodW5rKHJlcXVlc3QsIGlkLCBcIiRTXCIgKyBuYW1lKTtcbiAgICAgIHJlcXVlc3QuY29tcGxldGVkSW1wb3J0Q2h1bmtzLnB1c2goaWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbWl0TW9kZWxDaHVuayhyZXF1ZXN0LCBpZCwganNvbikge1xuICAgICAgaWQgPSBpZC50b1N0cmluZygxNikgKyBcIjpcIiArIGpzb24gKyBcIlxcblwiO1xuICAgICAgaWQgPSBzdHJpbmdUb0NodW5rKGlkKTtcbiAgICAgIHJlcXVlc3QuY29tcGxldGVkUmVndWxhckNodW5rcy5wdXNoKGlkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW1pdERlYnVnQ2h1bmsocmVxdWVzdCwgaWQsIGRlYnVnSW5mbykge1xuICAgICAgdmFyIGNvdW50ZXIgPSB7IG9iamVjdExpbWl0OiA1MDAgfTtcbiAgICAgIGRlYnVnSW5mbyA9IHN0cmluZ2lmeShkZWJ1Z0luZm8sIGZ1bmN0aW9uIChwYXJlbnRQcm9wZXJ0eU5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJDb25zb2xlVmFsdWUoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBjb3VudGVyLFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgcGFyZW50UHJvcGVydHlOYW1lLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIGlkID0gaWQudG9TdHJpbmcoMTYpICsgXCI6RFwiICsgZGVidWdJbmZvICsgXCJcXG5cIjtcbiAgICAgIGlkID0gc3RyaW5nVG9DaHVuayhpZCk7XG4gICAgICByZXF1ZXN0LmNvbXBsZXRlZFJlZ3VsYXJDaHVua3MucHVzaChpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG91dGxpbmVDb21wb25lbnRJbmZvKHJlcXVlc3QsIGNvbXBvbmVudEluZm8pIHtcbiAgICAgIGlmICghcmVxdWVzdC53cml0dGVuT2JqZWN0cy5oYXMoY29tcG9uZW50SW5mbykpIHtcbiAgICAgICAgbnVsbCAhPSBjb21wb25lbnRJbmZvLm93bmVyICYmXG4gICAgICAgICAgb3V0bGluZUNvbXBvbmVudEluZm8ocmVxdWVzdCwgY29tcG9uZW50SW5mby5vd25lcik7XG4gICAgICAgIHZhciBvYmplY3RMaW1pdCA9IDEwO1xuICAgICAgICBudWxsICE9IGNvbXBvbmVudEluZm8uc3RhY2sgJiZcbiAgICAgICAgICAob2JqZWN0TGltaXQgKz0gY29tcG9uZW50SW5mby5zdGFjay5sZW5ndGgpO1xuICAgICAgICBvYmplY3RMaW1pdCA9IHsgb2JqZWN0TGltaXQ6IG9iamVjdExpbWl0IH07XG4gICAgICAgIHZhciBjb21wb25lbnREZWJ1Z0luZm8gPSB7XG4gICAgICAgICAgbmFtZTogY29tcG9uZW50SW5mby5uYW1lLFxuICAgICAgICAgIGVudjogY29tcG9uZW50SW5mby5lbnYsXG4gICAgICAgICAga2V5OiBjb21wb25lbnRJbmZvLmtleSxcbiAgICAgICAgICBvd25lcjogY29tcG9uZW50SW5mby5vd25lclxuICAgICAgICB9O1xuICAgICAgICBjb21wb25lbnREZWJ1Z0luZm8uc3RhY2sgPSBjb21wb25lbnRJbmZvLnN0YWNrO1xuICAgICAgICBjb21wb25lbnREZWJ1Z0luZm8ucHJvcHMgPSBjb21wb25lbnRJbmZvLnByb3BzO1xuICAgICAgICBvYmplY3RMaW1pdCA9IG91dGxpbmVDb25zb2xlVmFsdWUoXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBvYmplY3RMaW1pdCxcbiAgICAgICAgICBjb21wb25lbnREZWJ1Z0luZm9cbiAgICAgICAgKTtcbiAgICAgICAgcmVxdWVzdC53cml0dGVuT2JqZWN0cy5zZXQoXG4gICAgICAgICAgY29tcG9uZW50SW5mbyxcbiAgICAgICAgICBzZXJpYWxpemVCeVZhbHVlSUQob2JqZWN0TGltaXQpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtaXRUeXBlZEFycmF5Q2h1bmsocmVxdWVzdCwgaWQsIHRhZywgdHlwZWRBcnJheSkge1xuICAgICAgcmVxdWVzdC5wZW5kaW5nQ2h1bmtzKys7XG4gICAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgIHR5cGVkQXJyYXkuYnVmZmVyLFxuICAgICAgICB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsXG4gICAgICAgIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aFxuICAgICAgKTtcbiAgICAgIHR5cGVkQXJyYXkgPSAyMDQ4IDwgdHlwZWRBcnJheS5ieXRlTGVuZ3RoID8gYnVmZmVyLnNsaWNlKCkgOiBidWZmZXI7XG4gICAgICBidWZmZXIgPSB0eXBlZEFycmF5LmJ5dGVMZW5ndGg7XG4gICAgICBpZCA9IGlkLnRvU3RyaW5nKDE2KSArIFwiOlwiICsgdGFnICsgYnVmZmVyLnRvU3RyaW5nKDE2KSArIFwiLFwiO1xuICAgICAgaWQgPSBzdHJpbmdUb0NodW5rKGlkKTtcbiAgICAgIHJlcXVlc3QuY29tcGxldGVkUmVndWxhckNodW5rcy5wdXNoKGlkLCB0eXBlZEFycmF5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW1pdFRleHRDaHVuayhyZXF1ZXN0LCBpZCwgdGV4dCkge1xuICAgICAgaWYgKG51bGwgPT09IGJ5dGVMZW5ndGhPZkNodW5rKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4aXN0ZW5jZSBvZiBieXRlTGVuZ3RoT2ZDaHVuayBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gY2hlY2tlZC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgcmVxdWVzdC5wZW5kaW5nQ2h1bmtzKys7XG4gICAgICB0ZXh0ID0gc3RyaW5nVG9DaHVuayh0ZXh0KTtcbiAgICAgIHZhciBiaW5hcnlMZW5ndGggPSB0ZXh0LmJ5dGVMZW5ndGg7XG4gICAgICBpZCA9IGlkLnRvU3RyaW5nKDE2KSArIFwiOlRcIiArIGJpbmFyeUxlbmd0aC50b1N0cmluZygxNikgKyBcIixcIjtcbiAgICAgIGlkID0gc3RyaW5nVG9DaHVuayhpZCk7XG4gICAgICByZXF1ZXN0LmNvbXBsZXRlZFJlZ3VsYXJDaHVua3MucHVzaChpZCwgdGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckNvbnNvbGVWYWx1ZShcbiAgICAgIHJlcXVlc3QsXG4gICAgICBjb3VudGVyLFxuICAgICAgcGFyZW50LFxuICAgICAgcGFyZW50UHJvcGVydHlOYW1lLFxuICAgICAgdmFsdWVcbiAgICApIHtcbiAgICAgIGlmIChudWxsID09PSB2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodmFsdWUgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkgcmV0dXJuIFwiJFwiO1xuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNDbGllbnRSZWZlcmVuY2UodmFsdWUpKVxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemVDbGllbnRSZWZlcmVuY2UoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgcGFyZW50UHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdm9pZCAwICE9PSByZXF1ZXN0LnRlbXBvcmFyeVJlZmVyZW5jZXMgJiZcbiAgICAgICAgICAoKHBhcmVudCA9IHJlcXVlc3QudGVtcG9yYXJ5UmVmZXJlbmNlcy5nZXQodmFsdWUpKSwgdm9pZCAwICE9PSBwYXJlbnQpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gXCIkVFwiICsgcGFyZW50O1xuICAgICAgICBwYXJlbnQgPSByZXF1ZXN0LndyaXR0ZW5PYmplY3RzLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmICh2b2lkIDAgIT09IHBhcmVudCkgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgaWYgKDAgPj0gY291bnRlci5vYmplY3RMaW1pdCAmJiAhZG9Ob3RMaW1pdC5oYXModmFsdWUpKSByZXR1cm4gXCIkWVwiO1xuICAgICAgICBjb3VudGVyLm9iamVjdExpbWl0LS07XG4gICAgICAgIHN3aXRjaCAodmFsdWUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICAgIG51bGwgIT0gdmFsdWUuX293bmVyICYmIG91dGxpbmVDb21wb25lbnRJbmZvKHJlcXVlc3QsIHZhbHVlLl9vd25lcik7XG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUudHlwZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSB2YWx1ZS50eXBlICYmXG4gICAgICAgICAgICAgIGRvTm90TGltaXQuYWRkKHZhbHVlLnR5cGUpO1xuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlLmtleSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSB2YWx1ZS5rZXkgJiZcbiAgICAgICAgICAgICAgZG9Ob3RMaW1pdC5hZGQodmFsdWUua2V5KTtcbiAgICAgICAgICAgIGRvTm90TGltaXQuYWRkKHZhbHVlLnByb3BzKTtcbiAgICAgICAgICAgIG51bGwgIT09IHZhbHVlLl9vd25lciAmJiBkb05vdExpbWl0LmFkZCh2YWx1ZS5fb3duZXIpO1xuICAgICAgICAgICAgY291bnRlciA9IG51bGw7XG4gICAgICAgICAgICBpZiAobnVsbCAhPSB2YWx1ZS5fZGVidWdTdGFjaylcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBjb3VudGVyID0gZmlsdGVyU3RhY2tUcmFjZShyZXF1ZXN0LCB2YWx1ZS5fZGVidWdTdGFjaywgMSksXG4gICAgICAgICAgICAgICAgICBkb05vdExpbWl0LmFkZChjb3VudGVyKSxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSAwO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPCBjb3VudGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXF1ZXN0KytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGRvTm90TGltaXQuYWRkKGNvdW50ZXJbcmVxdWVzdF0pO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICAgICAgICB2YWx1ZS50eXBlLFxuICAgICAgICAgICAgICB2YWx1ZS5rZXksXG4gICAgICAgICAgICAgIHZhbHVlLnByb3BzLFxuICAgICAgICAgICAgICB2YWx1ZS5fb3duZXIsXG4gICAgICAgICAgICAgIGNvdW50ZXIsXG4gICAgICAgICAgICAgIHZhbHVlLl9zdG9yZS52YWxpZGF0ZWRcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlLnRoZW4pIHtcbiAgICAgICAgICBzd2l0Y2ggKHZhbHVlLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIFwiJEBcIiArXG4gICAgICAgICAgICAgICAgb3V0bGluZUNvbnNvbGVWYWx1ZShyZXF1ZXN0LCBjb3VudGVyLCB2YWx1ZS52YWx1ZSkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoY291bnRlciA9IHZhbHVlLnJlYXNvbiksXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5wZW5kaW5nQ2h1bmtzKyssXG4gICAgICAgICAgICAgICAgKHZhbHVlID0gcmVxdWVzdC5uZXh0Q2h1bmtJZCsrKSxcbiAgICAgICAgICAgICAgICBlbWl0RXJyb3JDaHVuayhyZXF1ZXN0LCB2YWx1ZSwgXCJcIiwgY291bnRlciksXG4gICAgICAgICAgICAgICAgXCIkQFwiICsgdmFsdWUudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcIiRAXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXlJbXBsKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICB2YWx1ZSA9IEFycmF5LmZyb20odmFsdWUpO1xuICAgICAgICAgIGNvdW50ZXIub2JqZWN0TGltaXQrKztcbiAgICAgICAgICBmb3IgKHBhcmVudCA9IDA7IHBhcmVudCA8IHZhbHVlLmxlbmd0aDsgcGFyZW50KyspIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHZhbHVlW3BhcmVudF07XG4gICAgICAgICAgICBkb05vdExpbWl0LmFkZChlbnRyeSk7XG4gICAgICAgICAgICBwYXJlbnRQcm9wZXJ0eU5hbWUgPSBlbnRyeVswXTtcbiAgICAgICAgICAgIGVudHJ5ID0gZW50cnlbMV07XG4gICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcGFyZW50UHJvcGVydHlOYW1lICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHBhcmVudFByb3BlcnR5TmFtZSAmJlxuICAgICAgICAgICAgICBkb05vdExpbWl0LmFkZChwYXJlbnRQcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVudHJ5ICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGVudHJ5ICYmXG4gICAgICAgICAgICAgIGRvTm90TGltaXQuYWRkKGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFwiJFFcIiArIG91dGxpbmVDb25zb2xlVmFsdWUocmVxdWVzdCwgY291bnRlciwgdmFsdWUpLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgdmFsdWUgPSBBcnJheS5mcm9tKHZhbHVlKTtcbiAgICAgICAgICBjb3VudGVyLm9iamVjdExpbWl0Kys7XG4gICAgICAgICAgZm9yIChwYXJlbnQgPSAwOyBwYXJlbnQgPCB2YWx1ZS5sZW5ndGg7IHBhcmVudCsrKVxuICAgICAgICAgICAgKHBhcmVudFByb3BlcnR5TmFtZSA9IHZhbHVlW3BhcmVudF0pLFxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcGFyZW50UHJvcGVydHlOYW1lICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcGFyZW50UHJvcGVydHlOYW1lICYmXG4gICAgICAgICAgICAgICAgZG9Ob3RMaW1pdC5hZGQocGFyZW50UHJvcGVydHlOYW1lKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgXCIkV1wiICsgb3V0bGluZUNvbnNvbGVWYWx1ZShyZXF1ZXN0LCBjb3VudGVyLCB2YWx1ZSkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRm9ybURhdGEgJiYgdmFsdWUgaW5zdGFuY2VvZiBGb3JtRGF0YVxuICAgICAgICAgID8gc2VyaWFsaXplRm9ybURhdGEocmVxdWVzdCwgdmFsdWUpXG4gICAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgICAgICA/IHNlcmlhbGl6ZUVycm9yVmFsdWUocmVxdWVzdCwgdmFsdWUpXG4gICAgICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJcbiAgICAgICAgICAgICAgPyBzZXJpYWxpemVUeXBlZEFycmF5KHJlcXVlc3QsIFwiQVwiLCBuZXcgVWludDhBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBJbnQ4QXJyYXlcbiAgICAgICAgICAgICAgICA/IHNlcmlhbGl6ZVR5cGVkQXJyYXkocmVxdWVzdCwgXCJPXCIsIHZhbHVlKVxuICAgICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgICAgICAgICAgICAgICA/IHNlcmlhbGl6ZVR5cGVkQXJyYXkocmVxdWVzdCwgXCJvXCIsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5XG4gICAgICAgICAgICAgICAgICAgID8gc2VyaWFsaXplVHlwZWRBcnJheShyZXF1ZXN0LCBcIlVcIiwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBJbnQxNkFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgPyBzZXJpYWxpemVUeXBlZEFycmF5KHJlcXVlc3QsIFwiU1wiLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgVWludDE2QXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VyaWFsaXplVHlwZWRBcnJheShyZXF1ZXN0LCBcInNcIiwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgSW50MzJBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlcmlhbGl6ZVR5cGVkQXJyYXkocmVxdWVzdCwgXCJMXCIsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgVWludDMyQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlcmlhbGl6ZVR5cGVkQXJyYXkocmVxdWVzdCwgXCJsXCIsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VyaWFsaXplVHlwZWRBcnJheShyZXF1ZXN0LCBcIkdcIiwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VyaWFsaXplVHlwZWRBcnJheShyZXF1ZXN0LCBcImdcIiwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBCaWdJbnQ2NEFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZXJpYWxpemVUeXBlZEFycmF5KHJlcXVlc3QsIFwiTVwiLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgQmlnVWludDY0QXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VyaWFsaXplVHlwZWRBcnJheShyZXF1ZXN0LCBcIm1cIiwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZXJpYWxpemVUeXBlZEFycmF5KHJlcXVlc3QsIFwiVlwiLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBCbG9iICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEJsb2JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlcmlhbGl6ZUJsb2IocmVxdWVzdCwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBnZXRJdGVyYXRvckZuKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBBcnJheS5mcm9tKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUpXG4gICAgICAgIHJldHVybiBcIlpcIiA9PT0gdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gJiZcbiAgICAgICAgICBwYXJlbnRbcGFyZW50UHJvcGVydHlOYW1lXSBpbnN0YW5jZW9mIERhdGVcbiAgICAgICAgICA/IFwiJERcIiArIHZhbHVlXG4gICAgICAgICAgOiAxMDI0IDw9IHZhbHVlLmxlbmd0aFxuICAgICAgICAgICAgPyBzZXJpYWxpemVMYXJnZVRleHRTdHJpbmcocmVxdWVzdCwgdmFsdWUpXG4gICAgICAgICAgICA6IFwiJFwiID09PSB2YWx1ZVswXVxuICAgICAgICAgICAgICA/IFwiJFwiICsgdmFsdWVcbiAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgIGlmIChcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHZhbHVlKSByZXR1cm4gdmFsdWU7XG4gICAgICBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHZhbHVlKSByZXR1cm4gc2VyaWFsaXplTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgdmFsdWUpIHJldHVybiBcIiR1bmRlZmluZWRcIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZSlcbiAgICAgICAgcmV0dXJuIGlzQ2xpZW50UmVmZXJlbmNlKHZhbHVlKVxuICAgICAgICAgID8gc2VyaWFsaXplQ2xpZW50UmVmZXJlbmNlKHJlcXVlc3QsIHBhcmVudCwgcGFyZW50UHJvcGVydHlOYW1lLCB2YWx1ZSlcbiAgICAgICAgICA6IHZvaWQgMCAhPT0gcmVxdWVzdC50ZW1wb3JhcnlSZWZlcmVuY2VzICYmXG4gICAgICAgICAgICAgICgocmVxdWVzdCA9IHJlcXVlc3QudGVtcG9yYXJ5UmVmZXJlbmNlcy5nZXQodmFsdWUpKSxcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSByZXF1ZXN0KVxuICAgICAgICAgICAgPyBcIiRUXCIgKyByZXF1ZXN0XG4gICAgICAgICAgICA6IFwiJEUoXCIgKyAoRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgXCIpXCIpO1xuICAgICAgaWYgKFwic3ltYm9sXCIgPT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjb3VudGVyID0gcmVxdWVzdC53cml0dGVuU3ltYm9scy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAodm9pZCAwICE9PSBjb3VudGVyKSByZXR1cm4gc2VyaWFsaXplQnlWYWx1ZUlEKGNvdW50ZXIpO1xuICAgICAgICBjb3VudGVyID0gdmFsdWUuZGVzY3JpcHRpb247XG4gICAgICAgIHJlcXVlc3QucGVuZGluZ0NodW5rcysrO1xuICAgICAgICB2YWx1ZSA9IHJlcXVlc3QubmV4dENodW5rSWQrKztcbiAgICAgICAgZW1pdFN5bWJvbENodW5rKHJlcXVlc3QsIHZhbHVlLCBjb3VudGVyKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUJ5VmFsdWVJRCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHZhbHVlXG4gICAgICAgID8gXCIkblwiICsgdmFsdWUudG9TdHJpbmcoMTApXG4gICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRlXG4gICAgICAgICAgPyBcIiREXCIgKyB2YWx1ZS50b0pTT04oKVxuICAgICAgICAgIDogXCJ1bmtub3duIHR5cGUgXCIgKyB0eXBlb2YgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG91dGxpbmVDb25zb2xlVmFsdWUocmVxdWVzdCwgY291bnRlciwgbW9kZWwpIHtcbiAgICAgIGZ1bmN0aW9uIHJlcGxhY2VyKHBhcmVudFByb3BlcnR5TmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVuZGVyQ29uc29sZVZhbHVlKFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIGNvdW50ZXIsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgcGFyZW50UHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFwiVW5rbm93biBWYWx1ZTogUmVhY3QgY291bGQgbm90IHNlbmQgaXQgZnJvbSB0aGUgc2VydmVyLlxcblwiICtcbiAgICAgICAgICAgIHgubWVzc2FnZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBtb2RlbCAmJiBudWxsICE9PSBtb2RlbCAmJiBkb05vdExpbWl0LmFkZChtb2RlbCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIganNvbiA9IHN0cmluZ2lmeShtb2RlbCwgcmVwbGFjZXIpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBqc29uID0gc3RyaW5naWZ5KFxuICAgICAgICAgIFwiVW5rbm93biBWYWx1ZTogUmVhY3QgY291bGQgbm90IHNlbmQgaXQgZnJvbSB0aGUgc2VydmVyLlxcblwiICtcbiAgICAgICAgICAgIHgubWVzc2FnZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVxdWVzdC5wZW5kaW5nQ2h1bmtzKys7XG4gICAgICBtb2RlbCA9IHJlcXVlc3QubmV4dENodW5rSWQrKztcbiAgICAgIGpzb24gPSBtb2RlbC50b1N0cmluZygxNikgKyBcIjpcIiArIGpzb24gKyBcIlxcblwiO1xuICAgICAganNvbiA9IHN0cmluZ1RvQ2h1bmsoanNvbik7XG4gICAgICByZXF1ZXN0LmNvbXBsZXRlZFJlZ3VsYXJDaHVua3MucHVzaChqc29uKTtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW1pdENvbnNvbGVDaHVuayhyZXF1ZXN0LCBtZXRob2ROYW1lLCBvd25lciwgc3RhY2tUcmFjZSwgYXJncykge1xuICAgICAgZnVuY3Rpb24gcmVwbGFjZXIocGFyZW50UHJvcGVydHlOYW1lLCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJDb25zb2xlVmFsdWUoXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgY291bnRlcixcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBwYXJlbnRQcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgXCJVbmtub3duIFZhbHVlOiBSZWFjdCBjb3VsZCBub3Qgc2VuZCBpdCBmcm9tIHRoZSBzZXJ2ZXIuXFxuXCIgK1xuICAgICAgICAgICAgeC5tZXNzYWdlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNvdW50ZXIgPSB7IG9iamVjdExpbWl0OiA1MDAgfTtcbiAgICAgIG51bGwgIT0gb3duZXIgJiYgb3V0bGluZUNvbXBvbmVudEluZm8ocmVxdWVzdCwgb3duZXIpO1xuICAgICAgdmFyIGVudiA9ICgwLCByZXF1ZXN0LmVudmlyb25tZW50TmFtZSkoKSxcbiAgICAgICAgcGF5bG9hZCA9IFttZXRob2ROYW1lLCBzdGFja1RyYWNlLCBvd25lciwgZW52XTtcbiAgICAgIHBheWxvYWQucHVzaC5hcHBseShwYXlsb2FkLCBhcmdzKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBqc29uID0gc3RyaW5naWZ5KHBheWxvYWQsIHJlcGxhY2VyKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAganNvbiA9IHN0cmluZ2lmeShcbiAgICAgICAgICBbXG4gICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgc3RhY2tUcmFjZSxcbiAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgZW52LFxuICAgICAgICAgICAgXCJVbmtub3duIFZhbHVlOiBSZWFjdCBjb3VsZCBub3Qgc2VuZCBpdCBmcm9tIHRoZSBzZXJ2ZXIuXCIsXG4gICAgICAgICAgICB4XG4gICAgICAgICAgXSxcbiAgICAgICAgICByZXBsYWNlclxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbWV0aG9kTmFtZSA9IHN0cmluZ1RvQ2h1bmsoXCI6V1wiICsganNvbiArIFwiXFxuXCIpO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSZWd1bGFyQ2h1bmtzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcndhcmREZWJ1Z0luZm8ocmVxdWVzdCwgaWQsIGRlYnVnSW5mbykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWJ1Z0luZm8ubGVuZ3RoOyBpKyspXG4gICAgICAgIFwibnVtYmVyXCIgIT09IHR5cGVvZiBkZWJ1Z0luZm9baV0udGltZSAmJlxuICAgICAgICAgIChyZXF1ZXN0LnBlbmRpbmdDaHVua3MrKyxcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZGVidWdJbmZvW2ldLm5hbWUgJiZcbiAgICAgICAgICAgIG91dGxpbmVDb21wb25lbnRJbmZvKHJlcXVlc3QsIGRlYnVnSW5mb1tpXSksXG4gICAgICAgICAgZW1pdERlYnVnQ2h1bmsocmVxdWVzdCwgaWQsIGRlYnVnSW5mb1tpXSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbWl0Q2h1bmsocmVxdWVzdCwgdGFzaywgdmFsdWUpIHtcbiAgICAgIHZhciBpZCA9IHRhc2suaWQ7XG4gICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdmFsdWUgJiYgbnVsbCAhPT0gYnl0ZUxlbmd0aE9mQ2h1bmtcbiAgICAgICAgPyBlbWl0VGV4dENodW5rKHJlcXVlc3QsIGlkLCB2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyXG4gICAgICAgICAgPyBlbWl0VHlwZWRBcnJheUNodW5rKHJlcXVlc3QsIGlkLCBcIkFcIiwgbmV3IFVpbnQ4QXJyYXkodmFsdWUpKVxuICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBJbnQ4QXJyYXlcbiAgICAgICAgICAgID8gZW1pdFR5cGVkQXJyYXlDaHVuayhyZXF1ZXN0LCBpZCwgXCJPXCIsIHZhbHVlKVxuICAgICAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcbiAgICAgICAgICAgICAgPyBlbWl0VHlwZWRBcnJheUNodW5rKHJlcXVlc3QsIGlkLCBcIm9cIiwgdmFsdWUpXG4gICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheVxuICAgICAgICAgICAgICAgID8gZW1pdFR5cGVkQXJyYXlDaHVuayhyZXF1ZXN0LCBpZCwgXCJVXCIsIHZhbHVlKVxuICAgICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBJbnQxNkFycmF5XG4gICAgICAgICAgICAgICAgICA/IGVtaXRUeXBlZEFycmF5Q2h1bmsocmVxdWVzdCwgaWQsIFwiU1wiLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBVaW50MTZBcnJheVxuICAgICAgICAgICAgICAgICAgICA/IGVtaXRUeXBlZEFycmF5Q2h1bmsocmVxdWVzdCwgaWQsIFwic1wiLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEludDMyQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICA/IGVtaXRUeXBlZEFycmF5Q2h1bmsocmVxdWVzdCwgaWQsIFwiTFwiLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgVWludDMyQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZW1pdFR5cGVkQXJyYXlDaHVuayhyZXF1ZXN0LCBpZCwgXCJsXCIsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVtaXRUeXBlZEFycmF5Q2h1bmsocmVxdWVzdCwgaWQsIFwiR1wiLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZW1pdFR5cGVkQXJyYXlDaHVuayhyZXF1ZXN0LCBpZCwgXCJnXCIsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBCaWdJbnQ2NEFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVtaXRUeXBlZEFycmF5Q2h1bmsocmVxdWVzdCwgaWQsIFwiTVwiLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBCaWdVaW50NjRBcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVtaXRUeXBlZEFycmF5Q2h1bmsocmVxdWVzdCwgaWQsIFwibVwiLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBlbWl0VHlwZWRBcnJheUNodW5rKHJlcXVlc3QsIGlkLCBcIlZcIiwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoKHZhbHVlID0gc3RyaW5naWZ5KHZhbHVlLCB0YXNrLnRvSlNPTikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdE1vZGVsQ2h1bmsocmVxdWVzdCwgdGFzay5pZCwgdmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXJyb3JlZFRhc2socmVxdWVzdCwgdGFzaywgZXJyb3IpIHtcbiAgICAgIHJlcXVlc3QuYWJvcnRhYmxlVGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgdGFzay5zdGF0dXMgPSBFUlJPUkVEJDE7XG4gICAgICB2YXIgZGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgdGFzayk7XG4gICAgICBlbWl0RXJyb3JDaHVuayhyZXF1ZXN0LCB0YXNrLmlkLCBkaWdlc3QsIGVycm9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlUYXNrKHJlcXVlc3QsIHRhc2spIHtcbiAgICAgIGlmICh0YXNrLnN0YXR1cyA9PT0gUEVORElORyQxKSB7XG4gICAgICAgIHZhciBwcmV2RGVidWdJRCA9IGRlYnVnSUQ7XG4gICAgICAgIHRhc2suc3RhdHVzID0gUkVOREVSSU5HO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1vZGVsUm9vdCA9IHRhc2subW9kZWw7XG4gICAgICAgICAgZGVidWdJRCA9IHRhc2suaWQ7XG4gICAgICAgICAgdmFyIHJlc29sdmVkTW9kZWwgPSByZW5kZXJNb2RlbERlc3RydWN0aXZlKFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICBlbXB0eVJvb3QsXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgdGFzay5tb2RlbFxuICAgICAgICAgICk7XG4gICAgICAgICAgZGVidWdJRCA9IG51bGw7XG4gICAgICAgICAgbW9kZWxSb290ID0gcmVzb2x2ZWRNb2RlbDtcbiAgICAgICAgICB0YXNrLmtleVBhdGggPSBudWxsO1xuICAgICAgICAgIHRhc2suaW1wbGljaXRTbG90ID0gITE7XG4gICAgICAgICAgdmFyIGN1cnJlbnRFbnYgPSAoMCwgcmVxdWVzdC5lbnZpcm9ubWVudE5hbWUpKCk7XG4gICAgICAgICAgY3VycmVudEVudiAhPT0gdGFzay5lbnZpcm9ubWVudE5hbWUgJiZcbiAgICAgICAgICAgIChyZXF1ZXN0LnBlbmRpbmdDaHVua3MrKyxcbiAgICAgICAgICAgIGVtaXREZWJ1Z0NodW5rKHJlcXVlc3QsIHRhc2suaWQsIHsgZW52OiBjdXJyZW50RW52IH0pKTtcbiAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJlc29sdmVkTW9kZWwgJiYgbnVsbCAhPT0gcmVzb2x2ZWRNb2RlbClcbiAgICAgICAgICAgIHJlcXVlc3Qud3JpdHRlbk9iamVjdHMuc2V0KFxuICAgICAgICAgICAgICByZXNvbHZlZE1vZGVsLFxuICAgICAgICAgICAgICBzZXJpYWxpemVCeVZhbHVlSUQodGFzay5pZClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGVtaXRDaHVuayhyZXF1ZXN0LCB0YXNrLCByZXNvbHZlZE1vZGVsKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBqc29uID0gc3RyaW5naWZ5KHJlc29sdmVkTW9kZWwpO1xuICAgICAgICAgICAgZW1pdE1vZGVsQ2h1bmsocmVxdWVzdCwgdGFzay5pZCwganNvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcXVlc3QuYWJvcnRhYmxlVGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICAgIHRhc2suc3RhdHVzID0gQ09NUExFVEVEO1xuICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gQUJPUlRJTkcpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuYWJvcnRhYmxlVGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICAgICAgdGFzay5zdGF0dXMgPSBBQk9SVEVEO1xuICAgICAgICAgICAgdmFyIG1vZGVsID0gc3RyaW5naWZ5KHNlcmlhbGl6ZUJ5VmFsdWVJRChyZXF1ZXN0LmZhdGFsRXJyb3IpKTtcbiAgICAgICAgICAgIGVtaXRNb2RlbENodW5rKHJlcXVlc3QsIHRhc2suaWQsIG1vZGVsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHggPVxuICAgICAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICA/IGdldFN1c3BlbmRlZFRoZW5hYmxlKClcbiAgICAgICAgICAgICAgICA6IHRocm93blZhbHVlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgeCAmJlxuICAgICAgICAgICAgICBudWxsICE9PSB4ICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHgudGhlblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRhc2suc3RhdHVzID0gUEVORElORyQxO1xuICAgICAgICAgICAgICB0YXNrLnRoZW5hYmxlU3RhdGUgPSBnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nKCk7XG4gICAgICAgICAgICAgIHZhciBwaW5nID0gdGFzay5waW5nO1xuICAgICAgICAgICAgICB4LnRoZW4ocGluZywgcGluZyk7XG4gICAgICAgICAgICB9IGVsc2UgZXJyb3JlZFRhc2socmVxdWVzdCwgdGFzaywgeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGRlYnVnSUQgPSBwcmV2RGVidWdJRDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cnlTdHJlYW1UYXNrKHJlcXVlc3QsIHRhc2spIHtcbiAgICAgIHZhciBwcmV2RGVidWdJRCA9IGRlYnVnSUQ7XG4gICAgICBkZWJ1Z0lEID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVtaXRDaHVuayhyZXF1ZXN0LCB0YXNrLCB0YXNrLm1vZGVsKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGRlYnVnSUQgPSBwcmV2RGVidWdJRDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVdvcmsocmVxdWVzdCkge1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHNTZXJ2ZXIuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzU2VydmVyLkggPSBIb29rc0Rpc3BhdGNoZXI7XG4gICAgICB2YXIgcHJldlJlcXVlc3QgPSBjdXJyZW50UmVxdWVzdDtcbiAgICAgIGN1cnJlbnRSZXF1ZXN0JDEgPSBjdXJyZW50UmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICB2YXIgaGFkQWJvcnRhYmxlVGFza3MgPSAwIDwgcmVxdWVzdC5hYm9ydGFibGVUYXNrcy5zaXplO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHBpbmdlZFRhc2tzID0gcmVxdWVzdC5waW5nZWRUYXNrcztcbiAgICAgICAgcmVxdWVzdC5waW5nZWRUYXNrcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBpbmdlZFRhc2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHJldHJ5VGFzayhyZXF1ZXN0LCBwaW5nZWRUYXNrc1tpXSk7XG4gICAgICAgIG51bGwgIT09IHJlcXVlc3QuZGVzdGluYXRpb24gJiZcbiAgICAgICAgICBmbHVzaENvbXBsZXRlZENodW5rcyhyZXF1ZXN0LCByZXF1ZXN0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgaWYgKGhhZEFib3J0YWJsZVRhc2tzICYmIDAgPT09IHJlcXVlc3QuYWJvcnRhYmxlVGFza3Muc2l6ZSkge1xuICAgICAgICAgIHZhciBvbkFsbFJlYWR5ID0gcmVxdWVzdC5vbkFsbFJlYWR5O1xuICAgICAgICAgIG9uQWxsUmVhZHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvciwgbnVsbCksIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzU2VydmVyLkggPSBwcmV2RGlzcGF0Y2hlciksXG4gICAgICAgICAgKGN1cnJlbnRSZXF1ZXN0JDEgPSBudWxsKSxcbiAgICAgICAgICAoY3VycmVudFJlcXVlc3QgPSBwcmV2UmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoQ29tcGxldGVkQ2h1bmtzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG4gICAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KDIwNDgpO1xuICAgICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGltcG9ydHNDaHVua3MgPSByZXF1ZXN0LmNvbXBsZXRlZEltcG9ydENodW5rcywgaSA9IDA7XG4gICAgICAgICAgaSA8IGltcG9ydHNDaHVua3MubGVuZ3RoO1xuICAgICAgICAgIGkrK1xuICAgICAgICApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHJlcXVlc3QucGVuZGluZ0NodW5rcy0tLFxuICAgICAgICAgICAgIXdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGltcG9ydHNDaHVua3NbaV0pKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGltcG9ydHNDaHVua3Muc3BsaWNlKDAsIGkpO1xuICAgICAgICB2YXIgaGludENodW5rcyA9IHJlcXVlc3QuY29tcGxldGVkSGludENodW5rcztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGhpbnRDaHVua3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgaWYgKCF3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBoaW50Q2h1bmtzW2ldKSkge1xuICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGhpbnRDaHVua3Muc3BsaWNlKDAsIGkpO1xuICAgICAgICB2YXIgcmVndWxhckNodW5rcyA9IHJlcXVlc3QuY29tcGxldGVkUmVndWxhckNodW5rcztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlZ3VsYXJDaHVua3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHJlcXVlc3QucGVuZGluZ0NodW5rcy0tLFxuICAgICAgICAgICAgIXdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHJlZ3VsYXJDaHVua3NbaV0pKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIHJlZ3VsYXJDaHVua3Muc3BsaWNlKDAsIGkpO1xuICAgICAgICB2YXIgZXJyb3JDaHVua3MgPSByZXF1ZXN0LmNvbXBsZXRlZEVycm9yQ2h1bmtzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXJyb3JDaHVua3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHJlcXVlc3QucGVuZGluZ0NodW5rcy0tLFxuICAgICAgICAgICAgIXdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVycm9yQ2h1bmtzW2ldKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBlcnJvckNodW5rcy5zcGxpY2UoMCwgaSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAocmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9ICExKSxcbiAgICAgICAgICBjdXJyZW50VmlldyAmJlxuICAgICAgICAgICAgMCA8IHdyaXR0ZW5CeXRlcyAmJlxuICAgICAgICAgICAgKGRlc3RpbmF0aW9uLmVucXVldWUoXG4gICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGN1cnJlbnRWaWV3LmJ1ZmZlciwgMCwgd3JpdHRlbkJ5dGVzKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChjdXJyZW50VmlldyA9IG51bGwpLFxuICAgICAgICAgICAgKHdyaXR0ZW5CeXRlcyA9IDApKTtcbiAgICAgIH1cbiAgICAgIDAgPT09IHJlcXVlc3QucGVuZGluZ0NodW5rcyAmJlxuICAgICAgICAoKHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEKSxcbiAgICAgICAgZGVzdGluYXRpb24uY2xvc2UoKSxcbiAgICAgICAgKHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0V29yayhyZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gbnVsbCAhPT0gcmVxdWVzdC5kZXN0aW5hdGlvbjtcbiAgICAgIHN1cHBvcnRzUmVxdWVzdFN0b3JhZ2VcbiAgICAgICAgPyBzY2hlZHVsZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXF1ZXN0U3RvcmFnZS5ydW4ocmVxdWVzdCwgcGVyZm9ybVdvcmssIHJlcXVlc3QpO1xuICAgICAgICAgIH0pXG4gICAgICAgIDogc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBlcmZvcm1Xb3JrKHJlcXVlc3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dE9ySW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVxdWVzdC5zdGF0dXMgPT09IE9QRU5JTkcgJiYgKHJlcXVlc3Quc3RhdHVzID0gMTEpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVGbHVzaChyZXF1ZXN0KSB7XG4gICAgICAhMSA9PT0gcmVxdWVzdC5mbHVzaFNjaGVkdWxlZCAmJlxuICAgICAgICAwID09PSByZXF1ZXN0LnBpbmdlZFRhc2tzLmxlbmd0aCAmJlxuICAgICAgICBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uICYmXG4gICAgICAgICgocmVxdWVzdC5mbHVzaFNjaGVkdWxlZCA9ICEwKSxcbiAgICAgICAgc2V0VGltZW91dE9ySW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXF1ZXN0LmZsdXNoU2NoZWR1bGVkID0gITE7XG4gICAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gcmVxdWVzdC5kZXN0aW5hdGlvbjtcbiAgICAgICAgICBkZXN0aW5hdGlvbiAmJiBmbHVzaENvbXBsZXRlZENodW5rcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gICAgICAgIH0sIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRGbG93aW5nKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IENMT1NJTkcpXG4gICAgICAgIChyZXF1ZXN0LnN0YXR1cyA9IENMT1NFRCksXG4gICAgICAgICAgY2xvc2VXaXRoRXJyb3IoZGVzdGluYXRpb24sIHJlcXVlc3QuZmF0YWxFcnJvcik7XG4gICAgICBlbHNlIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gQ0xPU0VEICYmIG51bGwgPT09IHJlcXVlc3QuZGVzdGluYXRpb24pIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZsdXNoQ29tcGxldGVkQ2h1bmtzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBudWxsKSwgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWJvcnQocmVxdWVzdCwgcmVhc29uKSB7XG4gICAgICB0cnkge1xuICAgICAgICAxMSA+PSByZXF1ZXN0LnN0YXR1cyAmJiAocmVxdWVzdC5zdGF0dXMgPSBBQk9SVElORyk7XG4gICAgICAgIHZhciBhYm9ydGFibGVUYXNrcyA9IHJlcXVlc3QuYWJvcnRhYmxlVGFza3M7XG4gICAgICAgIGlmICgwIDwgYWJvcnRhYmxlVGFza3Muc2l6ZSkge1xuICAgICAgICAgIHZhciBlcnJvciA9XG4gICAgICAgICAgICAgIHZvaWQgMCA9PT0gcmVhc29uXG4gICAgICAgICAgICAgICAgPyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJUaGUgcmVuZGVyIHdhcyBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXIgd2l0aG91dCBhIHJlYXNvbi5cIlxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJlYXNvbiAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSByZWFzb24gJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVhc29uLnRoZW5cbiAgICAgICAgICAgICAgICAgID8gRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJUaGUgcmVuZGVyIHdhcyBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXIgd2l0aCBhIHByb21pc2UuXCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiByZWFzb24sXG4gICAgICAgICAgICBkaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yLCBudWxsKSxcbiAgICAgICAgICAgIF9lcnJvcklkMiA9IHJlcXVlc3QubmV4dENodW5rSWQrKztcbiAgICAgICAgICByZXF1ZXN0LmZhdGFsRXJyb3IgPSBfZXJyb3JJZDI7XG4gICAgICAgICAgcmVxdWVzdC5wZW5kaW5nQ2h1bmtzKys7XG4gICAgICAgICAgZW1pdEVycm9yQ2h1bmsocmVxdWVzdCwgX2Vycm9ySWQyLCBkaWdlc3QsIGVycm9yKTtcbiAgICAgICAgICBhYm9ydGFibGVUYXNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICBpZiAodGFzay5zdGF0dXMgIT09IFJFTkRFUklORykge1xuICAgICAgICAgICAgICB0YXNrLnN0YXR1cyA9IEFCT1JURUQ7XG4gICAgICAgICAgICAgIHZhciByZWYgPSBzZXJpYWxpemVCeVZhbHVlSUQoX2Vycm9ySWQyKTtcbiAgICAgICAgICAgICAgdGFzayA9IGVuY29kZVJlZmVyZW5jZUNodW5rKHJlcXVlc3QsIHRhc2suaWQsIHJlZik7XG4gICAgICAgICAgICAgIHJlcXVlc3QuY29tcGxldGVkRXJyb3JDaHVua3MucHVzaCh0YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhYm9ydGFibGVUYXNrcy5jbGVhcigpO1xuICAgICAgICAgIHZhciBvbkFsbFJlYWR5ID0gcmVxdWVzdC5vbkFsbFJlYWR5O1xuICAgICAgICAgIG9uQWxsUmVhZHkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWJvcnRMaXN0ZW5lcnMgPSByZXF1ZXN0LmFib3J0TGlzdGVuZXJzO1xuICAgICAgICBpZiAoMCA8IGFib3J0TGlzdGVuZXJzLnNpemUpIHtcbiAgICAgICAgICB2YXIgX2Vycm9yID1cbiAgICAgICAgICAgIHZvaWQgMCA9PT0gcmVhc29uXG4gICAgICAgICAgICAgID8gRXJyb3IoXCJUaGUgcmVuZGVyIHdhcyBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXIgd2l0aG91dCBhIHJlYXNvbi5cIilcbiAgICAgICAgICAgICAgOiBcIm9iamVjdFwiID09PSB0eXBlb2YgcmVhc29uICYmXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSByZWFzb24gJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlYXNvbi50aGVuXG4gICAgICAgICAgICAgICAgPyBFcnJvcihcIlRoZSByZW5kZXIgd2FzIGFib3J0ZWQgYnkgdGhlIHNlcnZlciB3aXRoIGEgcHJvbWlzZS5cIilcbiAgICAgICAgICAgICAgICA6IHJlYXNvbjtcbiAgICAgICAgICBhYm9ydExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKF9lcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWJvcnRMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBudWxsICE9PSByZXF1ZXN0LmRlc3RpbmF0aW9uICYmXG4gICAgICAgICAgZmx1c2hDb21wbGV0ZWRDaHVua3MocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgICB9IGNhdGNoIChlcnJvciQyKSB7XG4gICAgICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IkMiwgbnVsbCksXG4gICAgICAgICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvciQyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVNlcnZlclJlZmVyZW5jZShidW5kbGVyQ29uZmlnLCBpZCkge1xuICAgICAgdmFyIG5hbWUgPSBcIlwiLFxuICAgICAgICByZXNvbHZlZE1vZHVsZURhdGEgPSBidW5kbGVyQ29uZmlnW2lkXTtcbiAgICAgIGlmIChyZXNvbHZlZE1vZHVsZURhdGEpIG5hbWUgPSByZXNvbHZlZE1vZHVsZURhdGEubmFtZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgaWR4ID0gaWQubGFzdEluZGV4T2YoXCIjXCIpO1xuICAgICAgICAtMSAhPT0gaWR4ICYmXG4gICAgICAgICAgKChuYW1lID0gaWQuc2xpY2UoaWR4ICsgMSkpLFxuICAgICAgICAgIChyZXNvbHZlZE1vZHVsZURhdGEgPSBidW5kbGVyQ29uZmlnW2lkLnNsaWNlKDAsIGlkeCldKSk7XG4gICAgICAgIGlmICghcmVzb2x2ZWRNb2R1bGVEYXRhKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgJ0NvdWxkIG5vdCBmaW5kIHRoZSBtb2R1bGUgXCInICtcbiAgICAgICAgICAgICAgaWQgK1xuICAgICAgICAgICAgICAnXCIgaW4gdGhlIFJlYWN0IFNlcnZlciBNYW5pZmVzdC4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiB0aGUgUmVhY3QgU2VydmVyIENvbXBvbmVudHMgYnVuZGxlci4nXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNvbHZlZE1vZHVsZURhdGEuYXN5bmNcbiAgICAgICAgPyBbcmVzb2x2ZWRNb2R1bGVEYXRhLmlkLCByZXNvbHZlZE1vZHVsZURhdGEuY2h1bmtzLCBuYW1lLCAxXVxuICAgICAgICA6IFtyZXNvbHZlZE1vZHVsZURhdGEuaWQsIHJlc29sdmVkTW9kdWxlRGF0YS5jaHVua3MsIG5hbWVdO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1aXJlQXN5bmNNb2R1bGUoaWQpIHtcbiAgICAgIHZhciBwcm9taXNlID0gZ2xvYmFsVGhpcy5fX25leHRfcmVxdWlyZV9fKGlkKTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwcm9taXNlLnRoZW4gfHwgXCJmdWxmaWxsZWRcIiA9PT0gcHJvbWlzZS5zdGF0dXMpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgcHJvbWlzZS50aGVuKFxuICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgcHJvbWlzZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgcHJvbWlzZS5yZWFzb24gPSByZWFzb247XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaWdub3JlUmVqZWN0KCkge31cbiAgICBmdW5jdGlvbiBwcmVsb2FkTW9kdWxlKG1ldGFkYXRhKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgY2h1bmtzID0gbWV0YWRhdGFbMV0sIHByb21pc2VzID0gW10sIGkgPSAwO1xuICAgICAgICBpIDwgY2h1bmtzLmxlbmd0aDtcblxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaHVua0lkID0gY2h1bmtzW2krK107XG4gICAgICAgIGNodW5rc1tpKytdO1xuICAgICAgICB2YXIgZW50cnkgPSBjaHVua0NhY2hlLmdldChjaHVua0lkKTtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZW50cnkpIHtcbiAgICAgICAgICBlbnRyeSA9IF9fd2VicGFja19jaHVua19sb2FkX18oY2h1bmtJZCk7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgdmFyIHJlc29sdmUgPSBjaHVua0NhY2hlLnNldC5iaW5kKGNodW5rQ2FjaGUsIGNodW5rSWQsIG51bGwpO1xuICAgICAgICAgIGVudHJ5LnRoZW4ocmVzb2x2ZSwgaWdub3JlUmVqZWN0KTtcbiAgICAgICAgICBjaHVua0NhY2hlLnNldChjaHVua0lkLCBlbnRyeSk7XG4gICAgICAgIH0gZWxzZSBudWxsICE9PSBlbnRyeSAmJiBwcm9taXNlcy5wdXNoKGVudHJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiA0ID09PSBtZXRhZGF0YS5sZW5ndGhcbiAgICAgICAgPyAwID09PSBwcm9taXNlcy5sZW5ndGhcbiAgICAgICAgICA/IHJlcXVpcmVBc3luY01vZHVsZShtZXRhZGF0YVswXSlcbiAgICAgICAgICA6IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmVBc3luY01vZHVsZShtZXRhZGF0YVswXSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICA6IDAgPCBwcm9taXNlcy5sZW5ndGhcbiAgICAgICAgICA/IFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWlyZU1vZHVsZShtZXRhZGF0YSkge1xuICAgICAgdmFyIG1vZHVsZUV4cG9ydHMgPSBnbG9iYWxUaGlzLl9fbmV4dF9yZXF1aXJlX18obWV0YWRhdGFbMF0pO1xuICAgICAgaWYgKDQgPT09IG1ldGFkYXRhLmxlbmd0aCAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtb2R1bGVFeHBvcnRzLnRoZW4pXG4gICAgICAgIGlmIChcImZ1bGZpbGxlZFwiID09PSBtb2R1bGVFeHBvcnRzLnN0YXR1cylcbiAgICAgICAgICBtb2R1bGVFeHBvcnRzID0gbW9kdWxlRXhwb3J0cy52YWx1ZTtcbiAgICAgICAgZWxzZSB0aHJvdyBtb2R1bGVFeHBvcnRzLnJlYXNvbjtcbiAgICAgIHJldHVybiBcIipcIiA9PT0gbWV0YWRhdGFbMl1cbiAgICAgICAgPyBtb2R1bGVFeHBvcnRzXG4gICAgICAgIDogXCJcIiA9PT0gbWV0YWRhdGFbMl1cbiAgICAgICAgICA/IG1vZHVsZUV4cG9ydHMuX19lc01vZHVsZVxuICAgICAgICAgICAgPyBtb2R1bGVFeHBvcnRzLmRlZmF1bHRcbiAgICAgICAgICAgIDogbW9kdWxlRXhwb3J0c1xuICAgICAgICAgIDogbW9kdWxlRXhwb3J0c1ttZXRhZGF0YVsyXV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIENodW5rKHN0YXR1cywgdmFsdWUsIHJlYXNvbiwgcmVzcG9uc2UpIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgICB0aGlzLl9yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVQZW5kaW5nQ2h1bmsocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBuZXcgQ2h1bmsoXCJwZW5kaW5nXCIsIG51bGwsIG51bGwsIHJlc3BvbnNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FrZUNodW5rKGxpc3RlbmVycywgdmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSAoMCwgbGlzdGVuZXJzW2ldKSh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyaWdnZXJFcnJvck9uQ2h1bmsoY2h1bmssIGVycm9yKSB7XG4gICAgICBpZiAoXCJwZW5kaW5nXCIgIT09IGNodW5rLnN0YXR1cyAmJiBcImJsb2NrZWRcIiAhPT0gY2h1bmsuc3RhdHVzKVxuICAgICAgICBjaHVuay5yZWFzb24uZXJyb3IoZXJyb3IpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBjaHVuay5yZWFzb247XG4gICAgICAgIGNodW5rLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgY2h1bmsucmVhc29uID0gZXJyb3I7XG4gICAgICAgIG51bGwgIT09IGxpc3RlbmVycyAmJiB3YWtlQ2h1bmsobGlzdGVuZXJzLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVNb2RlbENodW5rKGNodW5rLCB2YWx1ZSwgaWQpIHtcbiAgICAgIGlmIChcInBlbmRpbmdcIiAhPT0gY2h1bmsuc3RhdHVzKVxuICAgICAgICAoY2h1bmsgPSBjaHVuay5yZWFzb24pLFxuICAgICAgICAgIFwiQ1wiID09PSB2YWx1ZVswXVxuICAgICAgICAgICAgPyBjaHVuay5jbG9zZShcIkNcIiA9PT0gdmFsdWUgPyAnXCIkdW5kZWZpbmVkXCInIDogdmFsdWUuc2xpY2UoMSkpXG4gICAgICAgICAgICA6IGNodW5rLmVucXVldWVNb2RlbCh2YWx1ZSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlc29sdmVMaXN0ZW5lcnMgPSBjaHVuay52YWx1ZSxcbiAgICAgICAgICByZWplY3RMaXN0ZW5lcnMgPSBjaHVuay5yZWFzb247XG4gICAgICAgIGNodW5rLnN0YXR1cyA9IFwicmVzb2x2ZWRfbW9kZWxcIjtcbiAgICAgICAgY2h1bmsudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgY2h1bmsucmVhc29uID0gaWQ7XG4gICAgICAgIGlmIChudWxsICE9PSByZXNvbHZlTGlzdGVuZXJzKVxuICAgICAgICAgIHN3aXRjaCAoKGluaXRpYWxpemVNb2RlbENodW5rKGNodW5rKSwgY2h1bmsuc3RhdHVzKSkge1xuICAgICAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgICAgICB3YWtlQ2h1bmsocmVzb2x2ZUxpc3RlbmVycywgY2h1bmsudmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2tlZFwiOlxuICAgICAgICAgICAgY2FzZSBcImN5Y2xpY1wiOlxuICAgICAgICAgICAgICBpZiAoY2h1bmsudmFsdWUpXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IDA7IHZhbHVlIDwgcmVzb2x2ZUxpc3RlbmVycy5sZW5ndGg7IHZhbHVlKyspXG4gICAgICAgICAgICAgICAgICBjaHVuay52YWx1ZS5wdXNoKHJlc29sdmVMaXN0ZW5lcnNbdmFsdWVdKTtcbiAgICAgICAgICAgICAgZWxzZSBjaHVuay52YWx1ZSA9IHJlc29sdmVMaXN0ZW5lcnM7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5yZWFzb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocmVqZWN0TGlzdGVuZXJzKVxuICAgICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IDA7IHZhbHVlIDwgcmVqZWN0TGlzdGVuZXJzLmxlbmd0aDsgdmFsdWUrKylcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsucmVhc29uLnB1c2gocmVqZWN0TGlzdGVuZXJzW3ZhbHVlXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBjaHVuay5yZWFzb24gPSByZWplY3RMaXN0ZW5lcnM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgICAgIHJlamVjdExpc3RlbmVycyAmJiB3YWtlQ2h1bmsocmVqZWN0TGlzdGVuZXJzLCBjaHVuay5yZWFzb24pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZWRJdGVyYXRvclJlc3VsdENodW5rKHJlc3BvbnNlLCB2YWx1ZSwgZG9uZSkge1xuICAgICAgcmV0dXJuIG5ldyBDaHVuayhcbiAgICAgICAgXCJyZXNvbHZlZF9tb2RlbFwiLFxuICAgICAgICAoZG9uZSA/ICd7XCJkb25lXCI6dHJ1ZSxcInZhbHVlXCI6JyA6ICd7XCJkb25lXCI6ZmFsc2UsXCJ2YWx1ZVwiOicpICtcbiAgICAgICAgICB2YWx1ZSArXG4gICAgICAgICAgXCJ9XCIsXG4gICAgICAgIC0xLFxuICAgICAgICByZXNwb25zZVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUl0ZXJhdG9yUmVzdWx0Q2h1bmsoY2h1bmssIHZhbHVlLCBkb25lKSB7XG4gICAgICByZXNvbHZlTW9kZWxDaHVuayhcbiAgICAgICAgY2h1bmssXG4gICAgICAgIChkb25lID8gJ3tcImRvbmVcIjp0cnVlLFwidmFsdWVcIjonIDogJ3tcImRvbmVcIjpmYWxzZSxcInZhbHVlXCI6JykgK1xuICAgICAgICAgIHZhbHVlICtcbiAgICAgICAgICBcIn1cIixcbiAgICAgICAgLTFcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvYWRTZXJ2ZXJSZWZlcmVuY2UkMShcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgaWQsXG4gICAgICBib3VuZCxcbiAgICAgIHBhcmVudENodW5rLFxuICAgICAgcGFyZW50T2JqZWN0LFxuICAgICAga2V5XG4gICAgKSB7XG4gICAgICB2YXIgc2VydmVyUmVmZXJlbmNlID0gcmVzb2x2ZVNlcnZlclJlZmVyZW5jZShyZXNwb25zZS5fYnVuZGxlckNvbmZpZywgaWQpO1xuICAgICAgaWQgPSBwcmVsb2FkTW9kdWxlKHNlcnZlclJlZmVyZW5jZSk7XG4gICAgICBpZiAoYm91bmQpXG4gICAgICAgIGJvdW5kID0gUHJvbWlzZS5hbGwoW2JvdW5kLCBpZF0pLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICBfcmVmID0gX3JlZlswXTtcbiAgICAgICAgICB2YXIgZm4gPSByZXF1aXJlTW9kdWxlKHNlcnZlclJlZmVyZW5jZSk7XG4gICAgICAgICAgcmV0dXJuIGZuLmJpbmQuYXBwbHkoZm4sIFtudWxsXS5jb25jYXQoX3JlZikpO1xuICAgICAgICB9KTtcbiAgICAgIGVsc2UgaWYgKGlkKVxuICAgICAgICBib3VuZCA9IFByb21pc2UucmVzb2x2ZShpZCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlcXVpcmVNb2R1bGUoc2VydmVyUmVmZXJlbmNlKTtcbiAgICAgICAgfSk7XG4gICAgICBlbHNlIHJldHVybiByZXF1aXJlTW9kdWxlKHNlcnZlclJlZmVyZW5jZSk7XG4gICAgICBib3VuZC50aGVuKFxuICAgICAgICBjcmVhdGVNb2RlbFJlc29sdmVyKFxuICAgICAgICAgIHBhcmVudENodW5rLFxuICAgICAgICAgIHBhcmVudE9iamVjdCxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgITEsXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgY3JlYXRlTW9kZWwsXG4gICAgICAgICAgW11cbiAgICAgICAgKSxcbiAgICAgICAgY3JlYXRlTW9kZWxSZWplY3QocGFyZW50Q2h1bmspXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldml2ZU1vZGVsKHJlc3BvbnNlLCBwYXJlbnRPYmosIHBhcmVudEtleSwgdmFsdWUsIHJlZmVyZW5jZSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHBhcnNlTW9kZWxTdHJpbmcoXG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgcGFyZW50T2JqLFxuICAgICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICByZWZlcmVuY2VcbiAgICAgICAgKTtcbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiYgbnVsbCAhPT0gdmFsdWUpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAodm9pZCAwICE9PSByZWZlcmVuY2UgJiZcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gcmVzcG9uc2UuX3RlbXBvcmFyeVJlZmVyZW5jZXMgJiZcbiAgICAgICAgICAgIHJlc3BvbnNlLl90ZW1wb3JhcnlSZWZlcmVuY2VzLnNldCh2YWx1ZSwgcmVmZXJlbmNlKSxcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB2YWx1ZVtpXSA9IHJldml2ZU1vZGVsKFxuICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIFwiXCIgKyBpLFxuICAgICAgICAgICAgICB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSByZWZlcmVuY2UgPyByZWZlcmVuY2UgKyBcIjpcIiArIGkgOiB2b2lkIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmb3IgKGkgaW4gdmFsdWUpXG4gICAgICAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBpKSAmJlxuICAgICAgICAgICAgICAoKHBhcmVudE9iaiA9XG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSByZWZlcmVuY2UgJiYgLTEgPT09IGkuaW5kZXhPZihcIjpcIilcbiAgICAgICAgICAgICAgICAgID8gcmVmZXJlbmNlICsgXCI6XCIgKyBpXG4gICAgICAgICAgICAgICAgICA6IHZvaWQgMCksXG4gICAgICAgICAgICAgIChwYXJlbnRPYmogPSByZXZpdmVNb2RlbChcbiAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHZhbHVlW2ldLFxuICAgICAgICAgICAgICAgIHBhcmVudE9ialxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBwYXJlbnRPYmogPyAodmFsdWVbaV0gPSBwYXJlbnRPYmopIDogZGVsZXRlIHZhbHVlW2ldKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZU1vZGVsQ2h1bmsoY2h1bmspIHtcbiAgICAgIHZhciBwcmV2Q2h1bmsgPSBpbml0aWFsaXppbmdDaHVuayxcbiAgICAgICAgcHJldkJsb2NrZWQgPSBpbml0aWFsaXppbmdDaHVua0Jsb2NrZWRNb2RlbDtcbiAgICAgIGluaXRpYWxpemluZ0NodW5rID0gY2h1bms7XG4gICAgICBpbml0aWFsaXppbmdDaHVua0Jsb2NrZWRNb2RlbCA9IG51bGw7XG4gICAgICB2YXIgcm9vdFJlZmVyZW5jZSA9XG4gICAgICAgICAgLTEgPT09IGNodW5rLnJlYXNvbiA/IHZvaWQgMCA6IGNodW5rLnJlYXNvbi50b1N0cmluZygxNiksXG4gICAgICAgIHJlc29sdmVkTW9kZWwgPSBjaHVuay52YWx1ZTtcbiAgICAgIGNodW5rLnN0YXR1cyA9IFwiY3ljbGljXCI7XG4gICAgICBjaHVuay52YWx1ZSA9IG51bGw7XG4gICAgICBjaHVuay5yZWFzb24gPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJhd01vZGVsID0gSlNPTi5wYXJzZShyZXNvbHZlZE1vZGVsKSxcbiAgICAgICAgICB2YWx1ZSA9IHJldml2ZU1vZGVsKFxuICAgICAgICAgICAgY2h1bmsuX3Jlc3BvbnNlLFxuICAgICAgICAgICAgeyBcIlwiOiByYXdNb2RlbCB9LFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIHJhd01vZGVsLFxuICAgICAgICAgICAgcm9vdFJlZmVyZW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBudWxsICE9PSBpbml0aWFsaXppbmdDaHVua0Jsb2NrZWRNb2RlbCAmJlxuICAgICAgICAgIDAgPCBpbml0aWFsaXppbmdDaHVua0Jsb2NrZWRNb2RlbC5kZXBzXG4gICAgICAgIClcbiAgICAgICAgICAoaW5pdGlhbGl6aW5nQ2h1bmtCbG9ja2VkTW9kZWwudmFsdWUgPSB2YWx1ZSksXG4gICAgICAgICAgICAoY2h1bmsuc3RhdHVzID0gXCJibG9ja2VkXCIpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZUxpc3RlbmVycyA9IGNodW5rLnZhbHVlO1xuICAgICAgICAgIGNodW5rLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgY2h1bmsudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBudWxsICE9PSByZXNvbHZlTGlzdGVuZXJzICYmIHdha2VDaHVuayhyZXNvbHZlTGlzdGVuZXJzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIChjaHVuay5zdGF0dXMgPSBcInJlamVjdGVkXCIpLCAoY2h1bmsucmVhc29uID0gZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKGluaXRpYWxpemluZ0NodW5rID0gcHJldkNodW5rKSxcbiAgICAgICAgICAoaW5pdGlhbGl6aW5nQ2h1bmtCbG9ja2VkTW9kZWwgPSBwcmV2QmxvY2tlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcG9ydEdsb2JhbEVycm9yKHJlc3BvbnNlLCBlcnJvcikge1xuICAgICAgcmVzcG9uc2UuX2Nsb3NlZCA9ICEwO1xuICAgICAgcmVzcG9uc2UuX2Nsb3NlZFJlYXNvbiA9IGVycm9yO1xuICAgICAgcmVzcG9uc2UuX2NodW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICBcInBlbmRpbmdcIiA9PT0gY2h1bmsuc3RhdHVzICYmIHRyaWdnZXJFcnJvck9uQ2h1bmsoY2h1bmssIGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDaHVuayhyZXNwb25zZSwgaWQpIHtcbiAgICAgIHZhciBjaHVua3MgPSByZXNwb25zZS5fY2h1bmtzLFxuICAgICAgICBjaHVuayA9IGNodW5rcy5nZXQoaWQpO1xuICAgICAgY2h1bmsgfHxcbiAgICAgICAgKChjaHVuayA9IHJlc3BvbnNlLl9mb3JtRGF0YS5nZXQocmVzcG9uc2UuX3ByZWZpeCArIGlkKSksXG4gICAgICAgIChjaHVuayA9XG4gICAgICAgICAgbnVsbCAhPSBjaHVua1xuICAgICAgICAgICAgPyBuZXcgQ2h1bmsoXCJyZXNvbHZlZF9tb2RlbFwiLCBjaHVuaywgaWQsIHJlc3BvbnNlKVxuICAgICAgICAgICAgOiByZXNwb25zZS5fY2xvc2VkXG4gICAgICAgICAgICAgID8gbmV3IENodW5rKFwicmVqZWN0ZWRcIiwgbnVsbCwgcmVzcG9uc2UuX2Nsb3NlZFJlYXNvbiwgcmVzcG9uc2UpXG4gICAgICAgICAgICAgIDogY3JlYXRlUGVuZGluZ0NodW5rKHJlc3BvbnNlKSksXG4gICAgICAgIGNodW5rcy5zZXQoaWQsIGNodW5rKSk7XG4gICAgICByZXR1cm4gY2h1bms7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1vZGVsUmVzb2x2ZXIoXG4gICAgICBjaHVuayxcbiAgICAgIHBhcmVudE9iamVjdCxcbiAgICAgIGtleSxcbiAgICAgIGN5Y2xpYyxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgbWFwLFxuICAgICAgcGF0aFxuICAgICkge1xuICAgICAgaWYgKGluaXRpYWxpemluZ0NodW5rQmxvY2tlZE1vZGVsKSB7XG4gICAgICAgIHZhciBibG9ja2VkID0gaW5pdGlhbGl6aW5nQ2h1bmtCbG9ja2VkTW9kZWw7XG4gICAgICAgIGN5Y2xpYyB8fCBibG9ja2VkLmRlcHMrKztcbiAgICAgIH0gZWxzZVxuICAgICAgICBibG9ja2VkID0gaW5pdGlhbGl6aW5nQ2h1bmtCbG9ja2VkTW9kZWwgPSB7XG4gICAgICAgICAgZGVwczogY3ljbGljID8gMCA6IDEsXG4gICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB2YWx1ZSA9IHZhbHVlW3BhdGhbaV1dO1xuICAgICAgICBwYXJlbnRPYmplY3Rba2V5XSA9IG1hcChyZXNwb25zZSwgdmFsdWUpO1xuICAgICAgICBcIlwiID09PSBrZXkgJiZcbiAgICAgICAgICBudWxsID09PSBibG9ja2VkLnZhbHVlICYmXG4gICAgICAgICAgKGJsb2NrZWQudmFsdWUgPSBwYXJlbnRPYmplY3Rba2V5XSk7XG4gICAgICAgIGJsb2NrZWQuZGVwcy0tO1xuICAgICAgICAwID09PSBibG9ja2VkLmRlcHMgJiZcbiAgICAgICAgICBcImJsb2NrZWRcIiA9PT0gY2h1bmsuc3RhdHVzICYmXG4gICAgICAgICAgKCh2YWx1ZSA9IGNodW5rLnZhbHVlKSxcbiAgICAgICAgICAoY2h1bmsuc3RhdHVzID0gXCJmdWxmaWxsZWRcIiksXG4gICAgICAgICAgKGNodW5rLnZhbHVlID0gYmxvY2tlZC52YWx1ZSksXG4gICAgICAgICAgbnVsbCAhPT0gdmFsdWUgJiYgd2FrZUNodW5rKHZhbHVlLCBibG9ja2VkLnZhbHVlKSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVNb2RlbFJlamVjdChjaHVuaykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4gdHJpZ2dlckVycm9yT25DaHVuayhjaHVuaywgZXJyb3IpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3V0bGluZWRNb2RlbChyZXNwb25zZSwgcmVmZXJlbmNlLCBwYXJlbnRPYmplY3QsIGtleSwgbWFwKSB7XG4gICAgICByZWZlcmVuY2UgPSByZWZlcmVuY2Uuc3BsaXQoXCI6XCIpO1xuICAgICAgdmFyIGlkID0gcGFyc2VJbnQocmVmZXJlbmNlWzBdLCAxNik7XG4gICAgICBpZCA9IGdldENodW5rKHJlc3BvbnNlLCBpZCk7XG4gICAgICBzd2l0Y2ggKGlkLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kZWxcIjpcbiAgICAgICAgICBpbml0aWFsaXplTW9kZWxDaHVuayhpZCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGlkLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgcGFyZW50T2JqZWN0ID0gaWQudmFsdWU7XG4gICAgICAgICAgZm9yIChrZXkgPSAxOyBrZXkgPCByZWZlcmVuY2UubGVuZ3RoOyBrZXkrKylcbiAgICAgICAgICAgIHBhcmVudE9iamVjdCA9IHBhcmVudE9iamVjdFtyZWZlcmVuY2Vba2V5XV07XG4gICAgICAgICAgcmV0dXJuIG1hcChyZXNwb25zZSwgcGFyZW50T2JqZWN0KTtcbiAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgY2FzZSBcImJsb2NrZWRcIjpcbiAgICAgICAgY2FzZSBcImN5Y2xpY1wiOlxuICAgICAgICAgIHZhciBwYXJlbnRDaHVuayA9IGluaXRpYWxpemluZ0NodW5rO1xuICAgICAgICAgIGlkLnRoZW4oXG4gICAgICAgICAgICBjcmVhdGVNb2RlbFJlc29sdmVyKFxuICAgICAgICAgICAgICBwYXJlbnRDaHVuayxcbiAgICAgICAgICAgICAgcGFyZW50T2JqZWN0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIFwiY3ljbGljXCIgPT09IGlkLnN0YXR1cyxcbiAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgIG1hcCxcbiAgICAgICAgICAgICAgcmVmZXJlbmNlXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY3JlYXRlTW9kZWxSZWplY3QocGFyZW50Q2h1bmspXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBpZC5yZWFzb247XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hcChyZXNwb25zZSwgbW9kZWwpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKG1vZGVsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlU2V0KHJlc3BvbnNlLCBtb2RlbCkge1xuICAgICAgcmV0dXJuIG5ldyBTZXQobW9kZWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHRyYWN0SXRlcmF0b3IocmVzcG9uc2UsIG1vZGVsKSB7XG4gICAgICByZXR1cm4gbW9kZWxbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVNb2RlbChyZXNwb25zZSwgbW9kZWwpIHtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VUeXBlZEFycmF5KFxuICAgICAgcmVzcG9uc2UsXG4gICAgICByZWZlcmVuY2UsXG4gICAgICBjb25zdHJ1Y3RvcixcbiAgICAgIGJ5dGVzUGVyRWxlbWVudCxcbiAgICAgIHBhcmVudE9iamVjdCxcbiAgICAgIHBhcmVudEtleVxuICAgICkge1xuICAgICAgcmVmZXJlbmNlID0gcGFyc2VJbnQocmVmZXJlbmNlLnNsaWNlKDIpLCAxNik7XG4gICAgICByZWZlcmVuY2UgPSByZXNwb25zZS5fZm9ybURhdGEuZ2V0KHJlc3BvbnNlLl9wcmVmaXggKyByZWZlcmVuY2UpO1xuICAgICAgcmVmZXJlbmNlID1cbiAgICAgICAgY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyXG4gICAgICAgICAgPyByZWZlcmVuY2UuYXJyYXlCdWZmZXIoKVxuICAgICAgICAgIDogcmVmZXJlbmNlLmFycmF5QnVmZmVyKCkudGhlbihmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3IoYnVmZmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgYnl0ZXNQZXJFbGVtZW50ID0gaW5pdGlhbGl6aW5nQ2h1bms7XG4gICAgICByZWZlcmVuY2UudGhlbihcbiAgICAgICAgY3JlYXRlTW9kZWxSZXNvbHZlcihcbiAgICAgICAgICBieXRlc1BlckVsZW1lbnQsXG4gICAgICAgICAgcGFyZW50T2JqZWN0LFxuICAgICAgICAgIHBhcmVudEtleSxcbiAgICAgICAgICAhMSxcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICBjcmVhdGVNb2RlbCxcbiAgICAgICAgICBbXVxuICAgICAgICApLFxuICAgICAgICBjcmVhdGVNb2RlbFJlamVjdChieXRlc1BlckVsZW1lbnQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVTdHJlYW0ocmVzcG9uc2UsIGlkLCBzdHJlYW0sIGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBjaHVua3MgPSByZXNwb25zZS5fY2h1bmtzO1xuICAgICAgc3RyZWFtID0gbmV3IENodW5rKFwiZnVsZmlsbGVkXCIsIHN0cmVhbSwgY29udHJvbGxlciwgcmVzcG9uc2UpO1xuICAgICAgY2h1bmtzLnNldChpZCwgc3RyZWFtKTtcbiAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2UuX2Zvcm1EYXRhLmdldEFsbChyZXNwb25zZS5fcHJlZml4ICsgaWQpO1xuICAgICAgZm9yIChpZCA9IDA7IGlkIDwgcmVzcG9uc2UubGVuZ3RoOyBpZCsrKVxuICAgICAgICAoY2h1bmtzID0gcmVzcG9uc2VbaWRdKSxcbiAgICAgICAgICBcIkNcIiA9PT0gY2h1bmtzWzBdXG4gICAgICAgICAgICA/IGNvbnRyb2xsZXIuY2xvc2UoXG4gICAgICAgICAgICAgICAgXCJDXCIgPT09IGNodW5rcyA/ICdcIiR1bmRlZmluZWRcIicgOiBjaHVua3Muc2xpY2UoMSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBjb250cm9sbGVyLmVucXVldWVNb2RlbChjaHVua3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlLCByZWZlcmVuY2UsIHR5cGUpIHtcbiAgICAgIHJlZmVyZW5jZSA9IHBhcnNlSW50KHJlZmVyZW5jZS5zbGljZSgyKSwgMTYpO1xuICAgICAgdmFyIGNvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgdHlwZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBjO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBwcmV2aW91c0Jsb2NrZWRDaHVuayA9IG51bGw7XG4gICAgICByZXNvbHZlU3RyZWFtKHJlc3BvbnNlLCByZWZlcmVuY2UsIHR5cGUsIHtcbiAgICAgICAgZW5xdWV1ZU1vZGVsOiBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICAgIGlmIChudWxsID09PSBwcmV2aW91c0Jsb2NrZWRDaHVuaykge1xuICAgICAgICAgICAgdmFyIGNodW5rID0gbmV3IENodW5rKFwicmVzb2x2ZWRfbW9kZWxcIiwganNvbiwgLTEsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGluaXRpYWxpemVNb2RlbENodW5rKGNodW5rKTtcbiAgICAgICAgICAgIFwiZnVsZmlsbGVkXCIgPT09IGNodW5rLnN0YXR1c1xuICAgICAgICAgICAgICA/IGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay52YWx1ZSlcbiAgICAgICAgICAgICAgOiAoY2h1bmsudGhlbihcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmVucXVldWUodik7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAocHJldmlvdXNCbG9ja2VkQ2h1bmsgPSBjaHVuaykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHVuayA9IHByZXZpb3VzQmxvY2tlZENodW5rO1xuICAgICAgICAgICAgdmFyIF9jaHVuayA9IGNyZWF0ZVBlbmRpbmdDaHVuayhyZXNwb25zZSk7XG4gICAgICAgICAgICBfY2h1bmsudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5lbnF1ZXVlKHYpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmVycm9yKGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcHJldmlvdXNCbG9ja2VkQ2h1bmsgPSBfY2h1bms7XG4gICAgICAgICAgICBjaHVuay50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcHJldmlvdXNCbG9ja2VkQ2h1bmsgPT09IF9jaHVuayAmJiAocHJldmlvdXNCbG9ja2VkQ2h1bmsgPSBudWxsKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZU1vZGVsQ2h1bmsoX2NodW5rLCBqc29uLCAtMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHByZXZpb3VzQmxvY2tlZENodW5rKSBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tlZENodW5rID0gcHJldmlvdXNCbG9ja2VkQ2h1bms7XG4gICAgICAgICAgICBwcmV2aW91c0Jsb2NrZWRDaHVuayA9IG51bGw7XG4gICAgICAgICAgICBibG9ja2VkQ2h1bmsudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcHJldmlvdXNCbG9ja2VkQ2h1bmspIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJsb2NrZWRDaHVuayA9IHByZXZpb3VzQmxvY2tlZENodW5rO1xuICAgICAgICAgICAgcHJldmlvdXNCbG9ja2VkQ2h1bmsgPSBudWxsO1xuICAgICAgICAgICAgYmxvY2tlZENodW5rLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzeW5jSXRlcmF0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3IobmV4dCkge1xuICAgICAgbmV4dCA9IHsgbmV4dDogbmV4dCB9O1xuICAgICAgbmV4dFtBU1lOQ19JVEVSQVRPUl0gPSBhc3luY0l0ZXJhdG9yO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQXN5bmNJdGVyYWJsZShyZXNwb25zZSwgcmVmZXJlbmNlLCBpdGVyYXRvcikge1xuICAgICAgcmVmZXJlbmNlID0gcGFyc2VJbnQocmVmZXJlbmNlLnNsaWNlKDIpLCAxNik7XG4gICAgICB2YXIgYnVmZmVyID0gW10sXG4gICAgICAgIGNsb3NlZCA9ICExLFxuICAgICAgICBuZXh0V3JpdGVJbmRleCA9IDAsXG4gICAgICAgIGl0ZXJhYmxlID0gX2RlZmluZVByb3BlcnR5KHt9LCBBU1lOQ19JVEVSQVRPUiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBuZXh0UmVhZEluZGV4ID0gMDtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlSXRlcmF0b3IoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYXJnKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlZhbHVlcyBjYW5ub3QgYmUgcGFzc2VkIHRvIG5leHQoKSBvZiBBc3luY0l0ZXJhYmxlcyBwYXNzZWQgdG8gQ2xpZW50IENvbXBvbmVudHMuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChuZXh0UmVhZEluZGV4ID09PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChjbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaHVuayhcbiAgICAgICAgICAgICAgICAgIFwiZnVsZmlsbGVkXCIsXG4gICAgICAgICAgICAgICAgICB7IGRvbmU6ICEwLCB2YWx1ZTogdm9pZCAwIH0sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBidWZmZXJbbmV4dFJlYWRJbmRleF0gPSBjcmVhdGVQZW5kaW5nQ2h1bmsocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcltuZXh0UmVhZEluZGV4KytdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGl0ZXJhdG9yID0gaXRlcmF0b3IgPyBpdGVyYWJsZVtBU1lOQ19JVEVSQVRPUl0oKSA6IGl0ZXJhYmxlO1xuICAgICAgcmVzb2x2ZVN0cmVhbShyZXNwb25zZSwgcmVmZXJlbmNlLCBpdGVyYXRvciwge1xuICAgICAgICBlbnF1ZXVlTW9kZWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIG5leHRXcml0ZUluZGV4ID09PSBidWZmZXIubGVuZ3RoXG4gICAgICAgICAgICA/IChidWZmZXJbbmV4dFdyaXRlSW5kZXhdID0gY3JlYXRlUmVzb2x2ZWRJdGVyYXRvclJlc3VsdENodW5rKFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgICA6IHJlc29sdmVJdGVyYXRvclJlc3VsdENodW5rKGJ1ZmZlcltuZXh0V3JpdGVJbmRleF0sIHZhbHVlLCAhMSk7XG4gICAgICAgICAgbmV4dFdyaXRlSW5kZXgrKztcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGNsb3NlZCA9ICEwO1xuICAgICAgICAgIG5leHRXcml0ZUluZGV4ID09PSBidWZmZXIubGVuZ3RoXG4gICAgICAgICAgICA/IChidWZmZXJbbmV4dFdyaXRlSW5kZXhdID0gY3JlYXRlUmVzb2x2ZWRJdGVyYXRvclJlc3VsdENodW5rKFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICkpXG4gICAgICAgICAgICA6IHJlc29sdmVJdGVyYXRvclJlc3VsdENodW5rKGJ1ZmZlcltuZXh0V3JpdGVJbmRleF0sIHZhbHVlLCAhMCk7XG4gICAgICAgICAgZm9yIChuZXh0V3JpdGVJbmRleCsrOyBuZXh0V3JpdGVJbmRleCA8IGJ1ZmZlci5sZW5ndGg7IClcbiAgICAgICAgICAgIHJlc29sdmVJdGVyYXRvclJlc3VsdENodW5rKFxuICAgICAgICAgICAgICBidWZmZXJbbmV4dFdyaXRlSW5kZXgrK10sXG4gICAgICAgICAgICAgICdcIiR1bmRlZmluZWRcIicsXG4gICAgICAgICAgICAgICEwXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgY2xvc2VkID0gITA7XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIG5leHRXcml0ZUluZGV4ID09PSBidWZmZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAoYnVmZmVyW25leHRXcml0ZUluZGV4XSA9IGNyZWF0ZVBlbmRpbmdDaHVuayhyZXNwb25zZSkpO1xuICAgICAgICAgICAgbmV4dFdyaXRlSW5kZXggPCBidWZmZXIubGVuZ3RoO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgdHJpZ2dlckVycm9yT25DaHVuayhidWZmZXJbbmV4dFdyaXRlSW5kZXgrK10sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTW9kZWxTdHJpbmcocmVzcG9uc2UsIG9iaiwga2V5LCB2YWx1ZSwgcmVmZXJlbmNlKSB7XG4gICAgICBpZiAoXCIkXCIgPT09IHZhbHVlWzBdKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWVbMV0pIHtcbiAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgIGNhc2UgXCJAXCI6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAob2JqID0gcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDE2KSksIGdldENodW5rKHJlc3BvbnNlLCBvYmopXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJGXCI6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAodmFsdWUgPSB2YWx1ZS5zbGljZSgyKSksXG4gICAgICAgICAgICAgICh2YWx1ZSA9IGdldE91dGxpbmVkTW9kZWwoXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgb2JqLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBjcmVhdGVNb2RlbFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbG9hZFNlcnZlclJlZmVyZW5jZSQxKFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHZhbHVlLmlkLFxuICAgICAgICAgICAgICAgIHZhbHVlLmJvdW5kLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemluZ0NodW5rLFxuICAgICAgICAgICAgICAgIG9iaixcbiAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwiVFwiOlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB2b2lkIDAgPT09IHJlZmVyZW5jZSB8fFxuICAgICAgICAgICAgICB2b2lkIDAgPT09IHJlc3BvbnNlLl90ZW1wb3JhcnlSZWZlcmVuY2VzXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ291bGQgbm90IHJlZmVyZW5jZSBhbiBvcGFxdWUgdGVtcG9yYXJ5IHJlZmVyZW5jZS4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIG1pc2NvbmZpZ3VyaW5nIHRoZSB0ZW1wb3JhcnlSZWZlcmVuY2VzIG9wdGlvbnMgb24gdGhlIHNlcnZlci5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRlbXBvcmFyeVJlZmVyZW5jZShcbiAgICAgICAgICAgICAgcmVzcG9uc2UuX3RlbXBvcmFyeVJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgIHJlZmVyZW5jZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwiUVwiOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHZhbHVlID0gdmFsdWUuc2xpY2UoMikpLFxuICAgICAgICAgICAgICBnZXRPdXRsaW5lZE1vZGVsKHJlc3BvbnNlLCB2YWx1ZSwgb2JqLCBrZXksIGNyZWF0ZU1hcClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh2YWx1ZSA9IHZhbHVlLnNsaWNlKDIpKSxcbiAgICAgICAgICAgICAgZ2V0T3V0bGluZWRNb2RlbChyZXNwb25zZSwgdmFsdWUsIG9iaiwga2V5LCBjcmVhdGVTZXQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJLXCI6XG4gICAgICAgICAgICBvYmogPSB2YWx1ZS5zbGljZSgyKTtcbiAgICAgICAgICAgIHZhciBmb3JtUHJlZml4ID0gcmVzcG9uc2UuX3ByZWZpeCArIG9iaiArIFwiX1wiLFxuICAgICAgICAgICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICByZXNwb25zZS5fZm9ybURhdGEuZm9yRWFjaChmdW5jdGlvbiAoZW50cnksIGVudHJ5S2V5KSB7XG4gICAgICAgICAgICAgIGVudHJ5S2V5LnN0YXJ0c1dpdGgoZm9ybVByZWZpeCkgJiZcbiAgICAgICAgICAgICAgICBkYXRhLmFwcGVuZChlbnRyeUtleS5zbGljZShmb3JtUHJlZml4Lmxlbmd0aCksIGVudHJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgY2FzZSBcImlcIjpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh2YWx1ZSA9IHZhbHVlLnNsaWNlKDIpKSxcbiAgICAgICAgICAgICAgZ2V0T3V0bGluZWRNb2RlbChyZXNwb25zZSwgdmFsdWUsIG9iaiwga2V5LCBleHRyYWN0SXRlcmF0b3IpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJJXCI6XG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIiQtMFwiID09PSB2YWx1ZSA/IC0wIDogLUluZmluaXR5O1xuICAgICAgICAgIGNhc2UgXCJOXCI6XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLnBhcnNlKHZhbHVlLnNsaWNlKDIpKSk7XG4gICAgICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUuc2xpY2UoMikpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWVbMV0pIHtcbiAgICAgICAgICBjYXNlIFwiQVwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHlwZWRBcnJheShyZXNwb25zZSwgdmFsdWUsIEFycmF5QnVmZmVyLCAxLCBvYmosIGtleSk7XG4gICAgICAgICAgY2FzZSBcIk9cIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVR5cGVkQXJyYXkocmVzcG9uc2UsIHZhbHVlLCBJbnQ4QXJyYXksIDEsIG9iaiwga2V5KTtcbiAgICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHlwZWRBcnJheShyZXNwb25zZSwgdmFsdWUsIFVpbnQ4QXJyYXksIDEsIG9iaiwga2V5KTtcbiAgICAgICAgICBjYXNlIFwiVVwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHlwZWRBcnJheShcbiAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBVaW50OENsYW1wZWRBcnJheSxcbiAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgb2JqLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVR5cGVkQXJyYXkocmVzcG9uc2UsIHZhbHVlLCBJbnQxNkFycmF5LCAyLCBvYmosIGtleSk7XG4gICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVR5cGVkQXJyYXkocmVzcG9uc2UsIHZhbHVlLCBVaW50MTZBcnJheSwgMiwgb2JqLCBrZXkpO1xuICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUeXBlZEFycmF5KHJlc3BvbnNlLCB2YWx1ZSwgSW50MzJBcnJheSwgNCwgb2JqLCBrZXkpO1xuICAgICAgICAgIGNhc2UgXCJsXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUeXBlZEFycmF5KHJlc3BvbnNlLCB2YWx1ZSwgVWludDMyQXJyYXksIDQsIG9iaiwga2V5KTtcbiAgICAgICAgICBjYXNlIFwiR1wiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHlwZWRBcnJheShyZXNwb25zZSwgdmFsdWUsIEZsb2F0MzJBcnJheSwgNCwgb2JqLCBrZXkpO1xuICAgICAgICAgIGNhc2UgXCJnXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUeXBlZEFycmF5KHJlc3BvbnNlLCB2YWx1ZSwgRmxvYXQ2NEFycmF5LCA4LCBvYmosIGtleSk7XG4gICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVR5cGVkQXJyYXkocmVzcG9uc2UsIHZhbHVlLCBCaWdJbnQ2NEFycmF5LCA4LCBvYmosIGtleSk7XG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVR5cGVkQXJyYXkoXG4gICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgQmlnVWludDY0QXJyYXksXG4gICAgICAgICAgICAgIDgsXG4gICAgICAgICAgICAgIG9iaixcbiAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUeXBlZEFycmF5KHJlc3BvbnNlLCB2YWx1ZSwgRGF0YVZpZXcsIDEsIG9iaiwga2V5KTtcbiAgICAgICAgICBjYXNlIFwiQlwiOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKG9iaiA9IHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCAxNikpLFxuICAgICAgICAgICAgICByZXNwb25zZS5fZm9ybURhdGEuZ2V0KHJlc3BvbnNlLl9wcmVmaXggKyBvYmopXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWVbMV0pIHtcbiAgICAgICAgICBjYXNlIFwiUlwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmVhZGFibGVTdHJlYW0ocmVzcG9uc2UsIHZhbHVlLCB2b2lkIDApO1xuICAgICAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VSZWFkYWJsZVN0cmVhbShyZXNwb25zZSwgdmFsdWUsIFwiYnl0ZXNcIik7XG4gICAgICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUFzeW5jSXRlcmFibGUocmVzcG9uc2UsIHZhbHVlLCAhMSk7XG4gICAgICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUFzeW5jSXRlcmFibGUocmVzcG9uc2UsIHZhbHVlLCAhMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIGdldE91dGxpbmVkTW9kZWwocmVzcG9uc2UsIHZhbHVlLCBvYmosIGtleSwgY3JlYXRlTW9kZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSZXNwb25zZShcbiAgICAgIGJ1bmRsZXJDb25maWcsXG4gICAgICBmb3JtRmllbGRQcmVmaXgsXG4gICAgICB0ZW1wb3JhcnlSZWZlcmVuY2VzXG4gICAgKSB7XG4gICAgICB2YXIgYmFja2luZ0Zvcm1EYXRhID1cbiAgICAgICAgICAzIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1szXVxuICAgICAgICAgICAgPyBhcmd1bWVudHNbM11cbiAgICAgICAgICAgIDogbmV3IEZvcm1EYXRhKCksXG4gICAgICAgIGNodW5rcyA9IG5ldyBNYXAoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9idW5kbGVyQ29uZmlnOiBidW5kbGVyQ29uZmlnLFxuICAgICAgICBfcHJlZml4OiBmb3JtRmllbGRQcmVmaXgsXG4gICAgICAgIF9mb3JtRGF0YTogYmFja2luZ0Zvcm1EYXRhLFxuICAgICAgICBfY2h1bmtzOiBjaHVua3MsXG4gICAgICAgIF9jbG9zZWQ6ICExLFxuICAgICAgICBfY2xvc2VkUmVhc29uOiBudWxsLFxuICAgICAgICBfdGVtcG9yYXJ5UmVmZXJlbmNlczogdGVtcG9yYXJ5UmVmZXJlbmNlc1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvc2UocmVzcG9uc2UpIHtcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yKHJlc3BvbnNlLCBFcnJvcihcIkNvbm5lY3Rpb24gY2xvc2VkLlwiKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvYWRTZXJ2ZXJSZWZlcmVuY2UoYnVuZGxlckNvbmZpZywgaWQsIGJvdW5kKSB7XG4gICAgICB2YXIgc2VydmVyUmVmZXJlbmNlID0gcmVzb2x2ZVNlcnZlclJlZmVyZW5jZShidW5kbGVyQ29uZmlnLCBpZCk7XG4gICAgICBidW5kbGVyQ29uZmlnID0gcHJlbG9hZE1vZHVsZShzZXJ2ZXJSZWZlcmVuY2UpO1xuICAgICAgcmV0dXJuIGJvdW5kXG4gICAgICAgID8gUHJvbWlzZS5hbGwoW2JvdW5kLCBidW5kbGVyQ29uZmlnXSkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgX3JlZiA9IF9yZWZbMF07XG4gICAgICAgICAgICB2YXIgZm4gPSByZXF1aXJlTW9kdWxlKHNlcnZlclJlZmVyZW5jZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYmluZC5hcHBseShmbiwgW251bGxdLmNvbmNhdChfcmVmKSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgOiBidW5kbGVyQ29uZmlnXG4gICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoYnVuZGxlckNvbmZpZykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXF1aXJlTW9kdWxlKHNlcnZlclJlZmVyZW5jZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKHJlcXVpcmVNb2R1bGUoc2VydmVyUmVmZXJlbmNlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZUJvdW5kQWN0aW9uTWV0YURhdGEoYm9keSwgc2VydmVyTWFuaWZlc3QsIGZvcm1GaWVsZFByZWZpeCkge1xuICAgICAgYm9keSA9IGNyZWF0ZVJlc3BvbnNlKHNlcnZlck1hbmlmZXN0LCBmb3JtRmllbGRQcmVmaXgsIHZvaWQgMCwgYm9keSk7XG4gICAgICBjbG9zZShib2R5KTtcbiAgICAgIGJvZHkgPSBnZXRDaHVuayhib2R5LCAwKTtcbiAgICAgIGJvZHkudGhlbihmdW5jdGlvbiAoKSB7fSk7XG4gICAgICBpZiAoXCJmdWxmaWxsZWRcIiAhPT0gYm9keS5zdGF0dXMpIHRocm93IGJvZHkucmVhc29uO1xuICAgICAgcmV0dXJuIGJvZHkudmFsdWU7XG4gICAgfVxuICAgIHZhciBSZWFjdERPTSA9IHJlcXVpcmUoXCJyZWFjdC1kb21cIiksXG4gICAgICBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKSxcbiAgICAgIFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpO1xuICAgIFN5bWJvbC5mb3IoXCJyZWFjdC5wb3N0cG9uZVwiKTtcbiAgICB2YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgQVNZTkNfSVRFUkFUT1IgPSBTeW1ib2wuYXN5bmNJdGVyYXRvcixcbiAgICAgIExvY2FsUHJvbWlzZSA9IFByb21pc2UsXG4gICAgICBzY2hlZHVsZU1pY3JvdGFzayA9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHF1ZXVlTWljcm90YXNrXG4gICAgICAgICAgPyBxdWV1ZU1pY3JvdGFza1xuICAgICAgICAgIDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIExvY2FsUHJvbWlzZS5yZXNvbHZlKG51bGwpXG4gICAgICAgICAgICAgICAgLnRoZW4oY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgLmNhdGNoKGhhbmRsZUVycm9ySW5OZXh0VGljayk7XG4gICAgICAgICAgICB9LFxuICAgICAgY3VycmVudFZpZXcgPSBudWxsLFxuICAgICAgd3JpdHRlbkJ5dGVzID0gMCxcbiAgICAgIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCksXG4gICAgICBDTElFTlRfUkVGRVJFTkNFX1RBRyQxID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBTRVJWRVJfUkVGRVJFTkNFX1RBRyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zZXJ2ZXIucmVmZXJlbmNlXCIpLFxuICAgICAgRnVuY3Rpb25CaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsXG4gICAgICBBcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuICAgICAgUFJPTUlTRV9QUk9UT1RZUEUgPSBQcm9taXNlLnByb3RvdHlwZSxcbiAgICAgIGRlZXBQcm94eUhhbmRsZXJzID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCIkJHR5cGVvZlwiOlxuICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LiQkdHlwZW9mO1xuICAgICAgICAgICAgY2FzZSBcIiQkaWRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC4kJGlkO1xuICAgICAgICAgICAgY2FzZSBcIiQkYXN5bmNcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC4kJGFzeW5jO1xuICAgICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5uYW1lO1xuICAgICAgICAgICAgY2FzZSBcImRpc3BsYXlOYW1lXCI6XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0UHJvcHNcIjpcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcInRvSlNPTlwiOlxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFN5bWJvbC50b1ByaW1pdGl2ZTpcbiAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGVbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgICAgICAgICAgIGNhc2UgU3ltYm9sLnRvU3RyaW5nVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddO1xuICAgICAgICAgICAgY2FzZSBcIlByb3ZpZGVyXCI6XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiQ2Fubm90IHJlbmRlciBhIENsaWVudCBDb250ZXh0IFByb3ZpZGVyIG9uIHRoZSBTZXJ2ZXIuIEluc3RlYWQsIHlvdSBjYW4gZXhwb3J0IGEgQ2xpZW50IENvbXBvbmVudCB3cmFwcGVyIHRoYXQgaXRzZWxmIHJlbmRlcnMgYSBDbGllbnQgQ29udGV4dCBQcm92aWRlci5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBcInRoZW5cIjpcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJDYW5ub3QgYXdhaXQgb3IgcmV0dXJuIGZyb20gYSB0aGVuYWJsZS4gWW91IGNhbm5vdCBhd2FpdCBhIGNsaWVudCBtb2R1bGUgZnJvbSBhIHNlcnZlciBjb21wb25lbnQuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBhY2Nlc3MgXCIgK1xuICAgICAgICAgICAgICAoU3RyaW5nKHRhcmdldC5uYW1lKSArIFwiLlwiICsgU3RyaW5nKG5hbWUpKSArXG4gICAgICAgICAgICAgIFwiIG9uIHRoZSBzZXJ2ZXIuIFlvdSBjYW5ub3QgZG90IGludG8gYSBjbGllbnQgbW9kdWxlIGZyb20gYSBzZXJ2ZXIgY29tcG9uZW50LiBZb3UgY2FuIG9ubHkgcGFzcyB0aGUgaW1wb3J0ZWQgbmFtZSB0aHJvdWdoLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgYXNzaWduIHRvIGEgY2xpZW50IG1vZHVsZSBmcm9tIGEgc2VydmVyIG1vZHVsZS5cIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwcm94eUhhbmRsZXJzJDEgPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKHRhcmdldCwgbmFtZSkge1xuICAgICAgICAgIHJldHVybiBnZXRSZWZlcmVuY2UodGFyZ2V0LCBuYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lKSB7XG4gICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgbmFtZSk7XG4gICAgICAgICAgZGVzY3JpcHRvciB8fFxuICAgICAgICAgICAgKChkZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0UmVmZXJlbmNlKHRhcmdldCwgbmFtZSksXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiAhMSxcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogITFcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcikpO1xuICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgICB9LFxuICAgICAgICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBQUk9NSVNFX1BST1RPVFlQRTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW5ub3QgYXNzaWduIHRvIGEgY2xpZW50IG1vZHVsZSBmcm9tIGEgc2VydmVyIG1vZHVsZS5cIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBSZWFjdERPTVNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0RE9NLl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLmQ7XG4gICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZCA9IHtcbiAgICAgIGY6IHByZXZpb3VzRGlzcGF0Y2hlci5mLFxuICAgICAgcjogcHJldmlvdXNEaXNwYXRjaGVyLnIsXG4gICAgICBEOiBmdW5jdGlvbiAoaHJlZikge1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikge1xuICAgICAgICAgIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcbiAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgdmFyIGhpbnRzID0gcmVxdWVzdC5oaW50cyxcbiAgICAgICAgICAgICAga2V5ID0gXCJEfFwiICsgaHJlZjtcbiAgICAgICAgICAgIGhpbnRzLmhhcyhrZXkpIHx8IChoaW50cy5hZGQoa2V5KSwgZW1pdEhpbnQocmVxdWVzdCwgXCJEXCIsIGhyZWYpKTtcbiAgICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLkQoaHJlZik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDOiBmdW5jdGlvbiAoaHJlZiwgY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmKSB7XG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuICAgICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgaGludHMgPSByZXF1ZXN0LmhpbnRzLFxuICAgICAgICAgICAgICBrZXkgPVxuICAgICAgICAgICAgICAgIFwiQ3xcIiArXG4gICAgICAgICAgICAgICAgKG51bGwgPT0gY3Jvc3NPcmlnaW4gPyBcIm51bGxcIiA6IGNyb3NzT3JpZ2luKSArXG4gICAgICAgICAgICAgICAgXCJ8XCIgK1xuICAgICAgICAgICAgICAgIGhyZWY7XG4gICAgICAgICAgICBoaW50cy5oYXMoa2V5KSB8fFxuICAgICAgICAgICAgICAoaGludHMuYWRkKGtleSksXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBjcm9zc09yaWdpblxuICAgICAgICAgICAgICAgID8gZW1pdEhpbnQocmVxdWVzdCwgXCJDXCIsIFtocmVmLCBjcm9zc09yaWdpbl0pXG4gICAgICAgICAgICAgICAgOiBlbWl0SGludChyZXF1ZXN0LCBcIkNcIiwgaHJlZikpO1xuICAgICAgICAgIH0gZWxzZSBwcmV2aW91c0Rpc3BhdGNoZXIuQyhocmVmLCBjcm9zc09yaWdpbik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBMOiBmdW5jdGlvbiAoaHJlZiwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmKSB7XG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuICAgICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgaGludHMgPSByZXF1ZXN0LmhpbnRzLFxuICAgICAgICAgICAgICBrZXkgPSBcIkxcIjtcbiAgICAgICAgICAgIGlmIChcImltYWdlXCIgPT09IGFzICYmIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgdmFyIGltYWdlU3JjU2V0ID0gb3B0aW9ucy5pbWFnZVNyY1NldCxcbiAgICAgICAgICAgICAgICBpbWFnZVNpemVzID0gb3B0aW9ucy5pbWFnZVNpemVzLFxuICAgICAgICAgICAgICAgIHVuaXF1ZVBhcnQgPSBcIlwiO1xuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgaW1hZ2VTcmNTZXQgJiYgXCJcIiAhPT0gaW1hZ2VTcmNTZXRcbiAgICAgICAgICAgICAgICA/ICgodW5pcXVlUGFydCArPSBcIltcIiArIGltYWdlU3JjU2V0ICsgXCJdXCIpLFxuICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGltYWdlU2l6ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgKHVuaXF1ZVBhcnQgKz0gXCJbXCIgKyBpbWFnZVNpemVzICsgXCJdXCIpKVxuICAgICAgICAgICAgICAgIDogKHVuaXF1ZVBhcnQgKz0gXCJbXVtdXCIgKyBocmVmKTtcbiAgICAgICAgICAgICAga2V5ICs9IFwiW2ltYWdlXVwiICsgdW5pcXVlUGFydDtcbiAgICAgICAgICAgIH0gZWxzZSBrZXkgKz0gXCJbXCIgKyBhcyArIFwiXVwiICsgaHJlZjtcbiAgICAgICAgICAgIGhpbnRzLmhhcyhrZXkpIHx8XG4gICAgICAgICAgICAgIChoaW50cy5hZGQoa2V5KSxcbiAgICAgICAgICAgICAgKG9wdGlvbnMgPSB0cmltT3B0aW9ucyhvcHRpb25zKSlcbiAgICAgICAgICAgICAgICA/IGVtaXRIaW50KHJlcXVlc3QsIFwiTFwiLCBbaHJlZiwgYXMsIG9wdGlvbnNdKVxuICAgICAgICAgICAgICAgIDogZW1pdEhpbnQocmVxdWVzdCwgXCJMXCIsIFtocmVmLCBhc10pKTtcbiAgICAgICAgICB9IGVsc2UgcHJldmlvdXNEaXNwYXRjaGVyLkwoaHJlZiwgYXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmKSB7XG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSByZXNvbHZlUmVxdWVzdCgpO1xuICAgICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgaGludHMgPSByZXF1ZXN0LmhpbnRzLFxuICAgICAgICAgICAgICBrZXkgPSBcIm18XCIgKyBocmVmO1xuICAgICAgICAgICAgaWYgKGhpbnRzLmhhcyhrZXkpKSByZXR1cm47XG4gICAgICAgICAgICBoaW50cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiAob3B0aW9ucyA9IHRyaW1PcHRpb25zKG9wdGlvbnMpKVxuICAgICAgICAgICAgICA/IGVtaXRIaW50KHJlcXVlc3QsIFwibVwiLCBbaHJlZiwgb3B0aW9uc10pXG4gICAgICAgICAgICAgIDogZW1pdEhpbnQocmVxdWVzdCwgXCJtXCIsIGhyZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2aW91c0Rpc3BhdGNoZXIubShocmVmLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFg6IGZ1bmN0aW9uIChzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBzcmMpIHtcbiAgICAgICAgICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG4gICAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHZhciBoaW50cyA9IHJlcXVlc3QuaGludHMsXG4gICAgICAgICAgICAgIGtleSA9IFwiWHxcIiArIHNyYztcbiAgICAgICAgICAgIGlmIChoaW50cy5oYXMoa2V5KSkgcmV0dXJuO1xuICAgICAgICAgICAgaGludHMuYWRkKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gKG9wdGlvbnMgPSB0cmltT3B0aW9ucyhvcHRpb25zKSlcbiAgICAgICAgICAgICAgPyBlbWl0SGludChyZXF1ZXN0LCBcIlhcIiwgW3NyYywgb3B0aW9uc10pXG4gICAgICAgICAgICAgIDogZW1pdEhpbnQocmVxdWVzdCwgXCJYXCIsIHNyYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXZpb3VzRGlzcGF0Y2hlci5YKHNyYywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBTOiBmdW5jdGlvbiAoaHJlZiwgcHJlY2VkZW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYpIHtcbiAgICAgICAgICB2YXIgcmVxdWVzdCA9IHJlc29sdmVSZXF1ZXN0KCk7XG4gICAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHZhciBoaW50cyA9IHJlcXVlc3QuaGludHMsXG4gICAgICAgICAgICAgIGtleSA9IFwiU3xcIiArIGhyZWY7XG4gICAgICAgICAgICBpZiAoaGludHMuaGFzKGtleSkpIHJldHVybjtcbiAgICAgICAgICAgIGhpbnRzLmFkZChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIChvcHRpb25zID0gdHJpbU9wdGlvbnMob3B0aW9ucykpXG4gICAgICAgICAgICAgID8gZW1pdEhpbnQocmVxdWVzdCwgXCJTXCIsIFtcbiAgICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcHJlY2VkZW5jZSA/IHByZWNlZGVuY2UgOiAwLFxuICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICA/IGVtaXRIaW50KHJlcXVlc3QsIFwiU1wiLCBbaHJlZiwgcHJlY2VkZW5jZV0pXG4gICAgICAgICAgICAgICAgOiBlbWl0SGludChyZXF1ZXN0LCBcIlNcIiwgaHJlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXZpb3VzRGlzcGF0Y2hlci5TKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgTTogZnVuY3Rpb24gKHNyYywgb3B0aW9ucykge1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNyYykge1xuICAgICAgICAgIHZhciByZXF1ZXN0ID0gcmVzb2x2ZVJlcXVlc3QoKTtcbiAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgdmFyIGhpbnRzID0gcmVxdWVzdC5oaW50cyxcbiAgICAgICAgICAgICAga2V5ID0gXCJNfFwiICsgc3JjO1xuICAgICAgICAgICAgaWYgKGhpbnRzLmhhcyhrZXkpKSByZXR1cm47XG4gICAgICAgICAgICBoaW50cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiAob3B0aW9ucyA9IHRyaW1PcHRpb25zKG9wdGlvbnMpKVxuICAgICAgICAgICAgICA/IGVtaXRIaW50KHJlcXVlc3QsIFwiTVwiLCBbc3JjLCBvcHRpb25zXSlcbiAgICAgICAgICAgICAgOiBlbWl0SGludChyZXF1ZXN0LCBcIk1cIiwgc3JjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXNEaXNwYXRjaGVyLk0oc3JjLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGZyYW1lUmVnRXhwID1cbiAgICAgICAgL14gezN9IGF0ICg/OiguKykgXFwoKD86KC4rKTooXFxkKyk6KFxcZCspfDxhbm9ueW1vdXM+KVxcKXwoPzphc3luYyApPyguKyk6KFxcZCspOihcXGQrKXw8YW5vbnltb3VzPikkLyxcbiAgICAgIHN1cHBvcnRzUmVxdWVzdFN0b3JhZ2UgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBBc3luY0xvY2FsU3RvcmFnZSxcbiAgICAgIHJlcXVlc3RTdG9yYWdlID0gc3VwcG9ydHNSZXF1ZXN0U3RvcmFnZSA/IG5ldyBBc3luY0xvY2FsU3RvcmFnZSgpIDogbnVsbCxcbiAgICAgIHN1cHBvcnRzQ29tcG9uZW50U3RvcmFnZSA9IHN1cHBvcnRzUmVxdWVzdFN0b3JhZ2UsXG4gICAgICBjb21wb25lbnRTdG9yYWdlID0gc3VwcG9ydHNDb21wb25lbnRTdG9yYWdlXG4gICAgICAgID8gbmV3IEFzeW5jTG9jYWxTdG9yYWdlKClcbiAgICAgICAgOiBudWxsO1xuICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBhc3luY19ob29rc1xuICAgICAgPyBhc3luY19ob29rcy5jcmVhdGVIb29rXG4gICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geyBlbmFibGU6IGZ1bmN0aW9uICgpIHt9LCBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7fSB9O1xuICAgICAgICB9O1xuICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBhc3luY19ob29rcyA/IGFzeW5jX2hvb2tzLmV4ZWN1dGlvbkFzeW5jSWQgOiBudWxsO1xuICAgIHZhciBURU1QT1JBUllfUkVGRVJFTkNFX1RBRyA9IFN5bWJvbC5mb3IoXCJyZWFjdC50ZW1wb3JhcnkucmVmZXJlbmNlXCIpLFxuICAgICAgcHJveHlIYW5kbGVycyA9IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lKSB7XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiJCR0eXBlb2ZcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC4kJHR5cGVvZjtcbiAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJkaXNwbGF5TmFtZVwiOlxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFByb3BzXCI6XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJ0b0pTT05cIjpcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBTeW1ib2wudG9QcmltaXRpdmU6XG4gICAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlW1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gICAgICAgICAgICBjYXNlIFN5bWJvbC50b1N0cmluZ1RhZzpcbiAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXTtcbiAgICAgICAgICAgIGNhc2UgXCJQcm92aWRlclwiOlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNhbm5vdCByZW5kZXIgYSBDbGllbnQgQ29udGV4dCBQcm92aWRlciBvbiB0aGUgU2VydmVyLiBJbnN0ZWFkLCB5b3UgY2FuIGV4cG9ydCBhIENsaWVudCBDb21wb25lbnQgd3JhcHBlciB0aGF0IGl0c2VsZiByZW5kZXJzIGEgQ2xpZW50IENvbnRleHQgUHJvdmlkZXIuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkNhbm5vdCBhY2Nlc3MgXCIgK1xuICAgICAgICAgICAgICBTdHJpbmcobmFtZSkgK1xuICAgICAgICAgICAgICBcIiBvbiB0aGUgc2VydmVyLiBZb3UgY2Fubm90IGRvdCBpbnRvIGEgdGVtcG9yYXJ5IGNsaWVudCByZWZlcmVuY2UgZnJvbSBhIHNlcnZlciBjb21wb25lbnQuIFlvdSBjYW4gb25seSBwYXNzIHRoZSB2YWx1ZSB0aHJvdWdoIHRvIHRoZSBjbGllbnQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiQ2Fubm90IGFzc2lnbiB0byBhIHRlbXBvcmFyeSBjbGllbnQgcmVmZXJlbmNlIGZyb20gYSBzZXJ2ZXIgbW9kdWxlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFN1c3BlbnNlRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciByZXRocm93IGl0IGltbWVkaWF0ZWx5LCBvciBtb3ZlIHRoZSBgdXNlYCBjYWxsIG91dHNpZGUgb2YgdGhlIGB0cnkvY2F0Y2hgIGJsb2NrLiBDYXB0dXJpbmcgd2l0aG91dCByZXRocm93aW5nIHdpbGwgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcblRvIGhhbmRsZSBhc3luYyBlcnJvcnMsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYW4gZXJyb3IgYm91bmRhcnksIG9yIGNhbGwgdGhlIHByb21pc2UncyBgLmNhdGNoYCBtZXRob2QgYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBgdXNlYC5cIlxuICAgICAgKSxcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbCxcbiAgICAgIGN1cnJlbnRSZXF1ZXN0JDEgPSBudWxsLFxuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIgPSAwLFxuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGwsXG4gICAgICBjdXJyZW50Q29tcG9uZW50RGVidWdJbmZvID0gbnVsbCxcbiAgICAgIEhvb2tzRGlzcGF0Y2hlciA9IHtcbiAgICAgICAgcmVhZENvbnRleHQ6IHVuc3VwcG9ydGVkQ29udGV4dCxcbiAgICAgICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKG51bGwgIT09IHVzYWJsZSAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgdXNhYmxlKSB8fFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdXNhYmxlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdXNhYmxlLnRoZW4pIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gICAgICAgICAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyICs9IDE7XG4gICAgICAgICAgICAgIG51bGwgPT09IHRoZW5hYmxlU3RhdGUgJiYgKHRoZW5hYmxlU3RhdGUgPSBbXSk7XG4gICAgICAgICAgICAgIHJldHVybiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB1c2FibGUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVzYWJsZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIHVuc3VwcG9ydGVkQ29udGV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDbGllbnRSZWZlcmVuY2UodXNhYmxlKSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBudWxsICE9IHVzYWJsZS52YWx1ZSAmJlxuICAgICAgICAgICAgICB1c2FibGUudmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNhbm5vdCByZWFkIGEgQ2xpZW50IENvbnRleHQgZnJvbSBhIFNlcnZlciBDb21wb25lbnQuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQ2Fubm90IHVzZSgpIGFuIGFscmVhZHkgcmVzb2x2ZWQgQ2xpZW50IFJlZmVyZW5jZS5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJBbiB1bnN1cHBvcnRlZCB0eXBlIHdhcyBwYXNzZWQgdG8gdXNlKCk6IFwiICsgU3RyaW5nKHVzYWJsZSlcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICB9LFxuICAgICAgICB1c2VDb250ZXh0OiB1bnN1cHBvcnRlZENvbnRleHQsXG4gICAgICAgIHVzZUVmZmVjdDogdW5zdXBwb3J0ZWRIb29rLFxuICAgICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB1bnN1cHBvcnRlZEhvb2ssXG4gICAgICAgIHVzZUxheW91dEVmZmVjdDogdW5zdXBwb3J0ZWRIb29rLFxuICAgICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IHVuc3VwcG9ydGVkSG9vayxcbiAgICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKG5leHRDcmVhdGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dENyZWF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICB1c2VSZWR1Y2VyOiB1bnN1cHBvcnRlZEhvb2ssXG4gICAgICAgIHVzZVJlZjogdW5zdXBwb3J0ZWRIb29rLFxuICAgICAgICB1c2VTdGF0ZTogdW5zdXBwb3J0ZWRIb29rLFxuICAgICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogdW5zdXBwb3J0ZWRIb29rLFxuICAgICAgICB1c2VUcmFuc2l0aW9uOiB1bnN1cHBvcnRlZEhvb2ssXG4gICAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB1bnN1cHBvcnRlZEhvb2ssXG4gICAgICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRSZXF1ZXN0JDEpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcInVzZUlkIGNhbiBvbmx5IGJlIHVzZWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nXCIpO1xuICAgICAgICAgIHZhciBpZCA9IGN1cnJlbnRSZXF1ZXN0JDEuaWRlbnRpZmllckNvdW50Kys7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFwiOlwiICtcbiAgICAgICAgICAgIGN1cnJlbnRSZXF1ZXN0JDEuaWRlbnRpZmllclByZWZpeCArXG4gICAgICAgICAgICBcIlNcIiArXG4gICAgICAgICAgICBpZC50b1N0cmluZygzMikgK1xuICAgICAgICAgICAgXCI6XCJcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1czogdW5zdXBwb3J0ZWRIb29rLFxuICAgICAgICB1c2VGb3JtU3RhdGU6IHVuc3VwcG9ydGVkSG9vayxcbiAgICAgICAgdXNlQWN0aW9uU3RhdGU6IHVuc3VwcG9ydGVkSG9vayxcbiAgICAgICAgdXNlT3B0aW1pc3RpYzogdW5zdXBwb3J0ZWRIb29rLFxuICAgICAgICB1c2VNZW1vQ2FjaGU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgICAgZm9yICh2YXIgZGF0YSA9IEFycmF5KHNpemUpLCBpID0gMDsgaSA8IHNpemU7IGkrKylcbiAgICAgICAgICAgIGRhdGFbaV0gPSBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdW5zdXBwb3J0ZWRSZWZyZXNoO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3VycmVudE93bmVyID0gbnVsbCxcbiAgICAgIERlZmF1bHRBc3luY0Rpc3BhdGNoZXIgPSB7XG4gICAgICAgIGdldENhY2hlRm9yVHlwZTogZnVuY3Rpb24gKHJlc291cmNlVHlwZSkge1xuICAgICAgICAgIHZhciBjYWNoZSA9IChjYWNoZSA9IHJlc29sdmVSZXF1ZXN0KCkpID8gY2FjaGUuY2FjaGUgOiBuZXcgTWFwKCk7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGUuZ2V0KHJlc291cmNlVHlwZSk7XG4gICAgICAgICAgdm9pZCAwID09PSBlbnRyeSAmJlxuICAgICAgICAgICAgKChlbnRyeSA9IHJlc291cmNlVHlwZSgpKSwgY2FjaGUuc2V0KHJlc291cmNlVHlwZSwgZW50cnkpKTtcbiAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgRGVmYXVsdEFzeW5jRGlzcGF0Y2hlci5nZXRPd25lciA9IHJlc29sdmVPd25lcjtcbiAgICB2YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHNTZXJ2ZXIgPVxuICAgICAgUmVhY3QuX19TRVJWRVJfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFO1xuICAgIGlmICghUmVhY3RTaGFyZWRJbnRlcm5hbHNTZXJ2ZXIpXG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgJ1RoZSBcInJlYWN0XCIgcGFja2FnZSBpbiB0aGlzIGVudmlyb25tZW50IGlzIG5vdCBjb25maWd1cmVkIGNvcnJlY3RseS4gVGhlIFwicmVhY3Qtc2VydmVyXCIgY29uZGl0aW9uIG11c3QgYmUgZW5hYmxlZCBpbiBhbnkgZW52aXJvbm1lbnQgdGhhdCBydW5zIFJlYWN0IFNlcnZlciBDb21wb25lbnRzLidcbiAgICAgICk7XG4gICAgdmFyIHByZWZpeCwgc3VmZml4O1xuICAgIG5ldyAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXApKCk7XG4gICAgdmFyIGxhc3RSZXNldFRpbWUgPSAwO1xuICAgIGlmIChcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwZXJmb3JtYW5jZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGVyZm9ybWFuY2Uubm93XG4gICAgKSB7XG4gICAgICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuICAgICAgdmFyIGdldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxQZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhbERhdGUgPSBEYXRlO1xuICAgICAgZ2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbERhdGUubm93KCk7XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgY2FsbENvbXBvbmVudCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKFxuICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBjb21wb25lbnREZWJ1Z0luZm9cbiAgICAgICAgKSB7XG4gICAgICAgICAgY3VycmVudE93bmVyID0gY29tcG9uZW50RGVidWdJbmZvO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQ29tcG9uZW50KHByb3BzLCB2b2lkIDApO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBjdXJyZW50T3duZXIgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnRJbkRFViA9XG4gICAgICAgIGNhbGxDb21wb25lbnRbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsQ29tcG9uZW50KSxcbiAgICAgIGNhbGxMYXp5SW5pdCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGxhenkpIHtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenkuX2luaXQ7XG4gICAgICAgICAgcmV0dXJuIGluaXQobGF6eS5fcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsTGF6eUluaXRJbkRFViA9XG4gICAgICAgIGNhbGxMYXp5SW5pdFtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxMYXp5SW5pdCksXG4gICAgICBjYWxsSXRlcmF0b3IgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChpdGVyYXRvciwgcHJvZ3Jlc3MsIGVycm9yKSB7XG4gICAgICAgICAgaXRlcmF0b3IubmV4dCgpLnRoZW4ocHJvZ3Jlc3MsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxJdGVyYXRvckluREVWID1cbiAgICAgICAgY2FsbEl0ZXJhdG9yW1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbEl0ZXJhdG9yKSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAganN4UHJvcHNQYXJlbnRzID0gbmV3IFdlYWtNYXAoKSxcbiAgICAgIGpzeENoaWxkcmVuUGFyZW50cyA9IG5ldyBXZWFrTWFwKCksXG4gICAgICBDTElFTlRfUkVGRVJFTkNFX1RBRyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgZG9Ob3RMaW1pdCA9IG5ldyBXZWFrU2V0KCk7XG4gICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGNvbnNvbGUgJiZcbiAgICAgIG51bGwgIT09IGNvbnNvbGUgJiZcbiAgICAgIChwYXRjaENvbnNvbGUoY29uc29sZSwgXCJhc3NlcnRcIiksXG4gICAgICBwYXRjaENvbnNvbGUoY29uc29sZSwgXCJkZWJ1Z1wiKSxcbiAgICAgIHBhdGNoQ29uc29sZShjb25zb2xlLCBcImRpclwiKSxcbiAgICAgIHBhdGNoQ29uc29sZShjb25zb2xlLCBcImRpcnhtbFwiKSxcbiAgICAgIHBhdGNoQ29uc29sZShjb25zb2xlLCBcImVycm9yXCIpLFxuICAgICAgcGF0Y2hDb25zb2xlKGNvbnNvbGUsIFwiZ3JvdXBcIiksXG4gICAgICBwYXRjaENvbnNvbGUoY29uc29sZSwgXCJncm91cENvbGxhcHNlZFwiKSxcbiAgICAgIHBhdGNoQ29uc29sZShjb25zb2xlLCBcImdyb3VwRW5kXCIpLFxuICAgICAgcGF0Y2hDb25zb2xlKGNvbnNvbGUsIFwiaW5mb1wiKSxcbiAgICAgIHBhdGNoQ29uc29sZShjb25zb2xlLCBcImxvZ1wiKSxcbiAgICAgIHBhdGNoQ29uc29sZShjb25zb2xlLCBcInRhYmxlXCIpLFxuICAgICAgcGF0Y2hDb25zb2xlKGNvbnNvbGUsIFwidHJhY2VcIiksXG4gICAgICBwYXRjaENvbnNvbGUoY29uc29sZSwgXCJ3YXJuXCIpKTtcbiAgICB2YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgIHN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5LFxuICAgICAgUEVORElORyQxID0gMCxcbiAgICAgIENPTVBMRVRFRCA9IDEsXG4gICAgICBBQk9SVEVEID0gMyxcbiAgICAgIEVSUk9SRUQkMSA9IDQsXG4gICAgICBSRU5ERVJJTkcgPSA1LFxuICAgICAgT1BFTklORyA9IDEwLFxuICAgICAgQUJPUlRJTkcgPSAxMixcbiAgICAgIENMT1NJTkcgPSAxMyxcbiAgICAgIENMT1NFRCA9IDE0LFxuICAgICAgUFJFUkVOREVSID0gMjEsXG4gICAgICBjdXJyZW50UmVxdWVzdCA9IG51bGwsXG4gICAgICBkZWJ1Z0lEID0gbnVsbCxcbiAgICAgIG1vZGVsUm9vdCA9ICExLFxuICAgICAgZW1wdHlSb290ID0ge30sXG4gICAgICBjaHVua0NhY2hlID0gbmV3IE1hcCgpLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICAgIENodW5rLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuICAgIENodW5rLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgc3dpdGNoICh0aGlzLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwicmVzb2x2ZWRfbW9kZWxcIjpcbiAgICAgICAgICBpbml0aWFsaXplTW9kZWxDaHVuayh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIHJlc29sdmUodGhpcy52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgIGNhc2UgXCJibG9ja2VkXCI6XG4gICAgICAgIGNhc2UgXCJjeWNsaWNcIjpcbiAgICAgICAgICByZXNvbHZlICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gdGhpcy52YWx1ZSAmJiAodGhpcy52YWx1ZSA9IFtdKSxcbiAgICAgICAgICAgIHRoaXMudmFsdWUucHVzaChyZXNvbHZlKSk7XG4gICAgICAgICAgcmVqZWN0ICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gdGhpcy5yZWFzb24gJiYgKHRoaXMucmVhc29uID0gW10pLFxuICAgICAgICAgICAgdGhpcy5yZWFzb24ucHVzaChyZWplY3QpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWplY3QodGhpcy5yZWFzb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGluaXRpYWxpemluZ0NodW5rID0gbnVsbCxcbiAgICAgIGluaXRpYWxpemluZ0NodW5rQmxvY2tlZE1vZGVsID0gbnVsbDtcbiAgICBleHBvcnRzLmNyZWF0ZUNsaWVudE1vZHVsZVByb3h5ID0gZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG4gICAgICBtb2R1bGVJZCA9IHJlZ2lzdGVyQ2xpZW50UmVmZXJlbmNlSW1wbCh7fSwgbW9kdWxlSWQsICExKTtcbiAgICAgIHJldHVybiBuZXcgUHJveHkobW9kdWxlSWQsIHByb3h5SGFuZGxlcnMkMSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZVRlbXBvcmFyeVJlZmVyZW5jZVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgV2Vha01hcCgpO1xuICAgIH07XG4gICAgZXhwb3J0cy5kZWNvZGVBY3Rpb24gPSBmdW5jdGlvbiAoYm9keSwgc2VydmVyTWFuaWZlc3QpIHtcbiAgICAgIHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpLFxuICAgICAgICBhY3Rpb24gPSBudWxsO1xuICAgICAgYm9keS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIGtleS5zdGFydHNXaXRoKFwiJEFDVElPTl9cIilcbiAgICAgICAgICA/IGtleS5zdGFydHNXaXRoKFwiJEFDVElPTl9SRUZfXCIpXG4gICAgICAgICAgICA/ICgodmFsdWUgPSBcIiRBQ1RJT05fXCIgKyBrZXkuc2xpY2UoMTIpICsgXCI6XCIpLFxuICAgICAgICAgICAgICAodmFsdWUgPSBkZWNvZGVCb3VuZEFjdGlvbk1ldGFEYXRhKGJvZHksIHNlcnZlck1hbmlmZXN0LCB2YWx1ZSkpLFxuICAgICAgICAgICAgICAoYWN0aW9uID0gbG9hZFNlcnZlclJlZmVyZW5jZShcbiAgICAgICAgICAgICAgICBzZXJ2ZXJNYW5pZmVzdCxcbiAgICAgICAgICAgICAgICB2YWx1ZS5pZCxcbiAgICAgICAgICAgICAgICB2YWx1ZS5ib3VuZFxuICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgIDoga2V5LnN0YXJ0c1dpdGgoXCIkQUNUSU9OX0lEX1wiKSAmJlxuICAgICAgICAgICAgICAoKHZhbHVlID0ga2V5LnNsaWNlKDExKSksXG4gICAgICAgICAgICAgIChhY3Rpb24gPSBsb2FkU2VydmVyUmVmZXJlbmNlKHNlcnZlck1hbmlmZXN0LCB2YWx1ZSwgbnVsbCkpKVxuICAgICAgICAgIDogZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gYWN0aW9uXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IGFjdGlvbi50aGVuKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmJpbmQobnVsbCwgZm9ybURhdGEpO1xuICAgICAgICAgIH0pO1xuICAgIH07XG4gICAgZXhwb3J0cy5kZWNvZGVGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uUmVzdWx0LCBib2R5LCBzZXJ2ZXJNYW5pZmVzdCkge1xuICAgICAgdmFyIGtleVBhdGggPSBib2R5LmdldChcIiRBQ1RJT05fS0VZXCIpO1xuICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBrZXlQYXRoKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgdmFyIG1ldGFEYXRhID0gbnVsbDtcbiAgICAgIGJvZHkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBrZXkuc3RhcnRzV2l0aChcIiRBQ1RJT05fUkVGX1wiKSAmJlxuICAgICAgICAgICgodmFsdWUgPSBcIiRBQ1RJT05fXCIgKyBrZXkuc2xpY2UoMTIpICsgXCI6XCIpLFxuICAgICAgICAgIChtZXRhRGF0YSA9IGRlY29kZUJvdW5kQWN0aW9uTWV0YURhdGEoYm9keSwgc2VydmVyTWFuaWZlc3QsIHZhbHVlKSkpO1xuICAgICAgfSk7XG4gICAgICBpZiAobnVsbCA9PT0gbWV0YURhdGEpIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICB2YXIgcmVmZXJlbmNlSWQgPSBtZXRhRGF0YS5pZDtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWV0YURhdGEuYm91bmQpLnRoZW4oZnVuY3Rpb24gKGJvdW5kKSB7XG4gICAgICAgIHJldHVybiBudWxsID09PSBib3VuZFxuICAgICAgICAgID8gbnVsbFxuICAgICAgICAgIDogW2FjdGlvblJlc3VsdCwga2V5UGF0aCwgcmVmZXJlbmNlSWQsIGJvdW5kLmxlbmd0aCAtIDFdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmRlY29kZVJlcGx5ID0gZnVuY3Rpb24gKGJvZHksIHdlYnBhY2tNYXAsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgYm9keSkge1xuICAgICAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3JtLmFwcGVuZChcIjBcIiwgYm9keSk7XG4gICAgICAgIGJvZHkgPSBmb3JtO1xuICAgICAgfVxuICAgICAgYm9keSA9IGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICB3ZWJwYWNrTWFwLFxuICAgICAgICBcIlwiLFxuICAgICAgICBvcHRpb25zID8gb3B0aW9ucy50ZW1wb3JhcnlSZWZlcmVuY2VzIDogdm9pZCAwLFxuICAgICAgICBib2R5XG4gICAgICApO1xuICAgICAgd2VicGFja01hcCA9IGdldENodW5rKGJvZHksIDApO1xuICAgICAgY2xvc2UoYm9keSk7XG4gICAgICByZXR1cm4gd2VicGFja01hcDtcbiAgICB9O1xuICAgIGV4cG9ydHMuZGVjb2RlUmVwbHlGcm9tQXN5bmNJdGVyYWJsZSA9IGZ1bmN0aW9uIChcbiAgICAgIGl0ZXJhYmxlLFxuICAgICAgd2VicGFja01hcCxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIGZ1bmN0aW9uIHByb2dyZXNzKGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeS5kb25lKSBjbG9zZShyZXNwb25zZSRqc2NvbXAkMCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVudHJ5ID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbnRyeVswXTtcbiAgICAgICAgICBlbnRyeSA9IGVudHJ5WzFdO1xuICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZW50cnkpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHJlc3BvbnNlJGpzY29tcCQwO1xuICAgICAgICAgICAgcmVzcG9uc2UuX2Zvcm1EYXRhLmFwcGVuZChuYW1lLCBlbnRyeSk7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gcmVzcG9uc2UuX3ByZWZpeDtcbiAgICAgICAgICAgIG5hbWUuc3RhcnRzV2l0aChwcmVmaXgpICYmXG4gICAgICAgICAgICAgICgocmVzcG9uc2UgPSByZXNwb25zZS5fY2h1bmtzKSxcbiAgICAgICAgICAgICAgKG5hbWUgPSArbmFtZS5zbGljZShwcmVmaXgubGVuZ3RoKSksXG4gICAgICAgICAgICAgIChwcmVmaXggPSByZXNwb25zZS5nZXQobmFtZSkpICYmXG4gICAgICAgICAgICAgICAgcmVzb2x2ZU1vZGVsQ2h1bmsocHJlZml4LCBlbnRyeSwgbmFtZSkpO1xuICAgICAgICAgIH0gZWxzZSByZXNwb25zZSRqc2NvbXAkMC5fZm9ybURhdGEuYXBwZW5kKG5hbWUsIGVudHJ5KTtcbiAgICAgICAgICBpdGVyYXRvci5uZXh0KCkudGhlbihwcm9ncmVzcywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlcnJvcihyZWFzb24pIHtcbiAgICAgICAgcmVwb3J0R2xvYmFsRXJyb3IocmVzcG9uc2UkanNjb21wJDAsIHJlYXNvbik7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGl0ZXJhdG9yLnRocm93ICYmXG4gICAgICAgICAgaXRlcmF0b3IudGhyb3cocmVhc29uKS50aGVuKGVycm9yLCBlcnJvcik7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYWJsZVtBU1lOQ19JVEVSQVRPUl0oKSxcbiAgICAgICAgcmVzcG9uc2UkanNjb21wJDAgPSBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICB3ZWJwYWNrTWFwLFxuICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMudGVtcG9yYXJ5UmVmZXJlbmNlcyA6IHZvaWQgMFxuICAgICAgICApO1xuICAgICAgaXRlcmF0b3IubmV4dCgpLnRoZW4ocHJvZ3Jlc3MsIGVycm9yKTtcbiAgICAgIHJldHVybiBnZXRDaHVuayhyZXNwb25zZSRqc2NvbXAkMCwgMCk7XG4gICAgfTtcbiAgICBleHBvcnRzLnJlZ2lzdGVyQ2xpZW50UmVmZXJlbmNlID0gZnVuY3Rpb24gKFxuICAgICAgcHJveHlJbXBsZW1lbnRhdGlvbixcbiAgICAgIGlkLFxuICAgICAgZXhwb3J0TmFtZVxuICAgICkge1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyQ2xpZW50UmVmZXJlbmNlSW1wbChcbiAgICAgICAgcHJveHlJbXBsZW1lbnRhdGlvbixcbiAgICAgICAgaWQgKyBcIiNcIiArIGV4cG9ydE5hbWUsXG4gICAgICAgICExXG4gICAgICApO1xuICAgIH07XG4gICAgZXhwb3J0cy5yZWdpc3RlclNlcnZlclJlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZWZlcmVuY2UsIGlkLCBleHBvcnROYW1lKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocmVmZXJlbmNlLCB7XG4gICAgICAgICQkdHlwZW9mOiB7IHZhbHVlOiBTRVJWRVJfUkVGRVJFTkNFX1RBRyB9LFxuICAgICAgICAkJGlkOiB7XG4gICAgICAgICAgdmFsdWU6IG51bGwgPT09IGV4cG9ydE5hbWUgPyBpZCA6IGlkICsgXCIjXCIgKyBleHBvcnROYW1lLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSxcbiAgICAgICAgJCRib3VuZDogeyB2YWx1ZTogbnVsbCwgY29uZmlndXJhYmxlOiAhMCB9LFxuICAgICAgICAkJGxvY2F0aW9uOiB7IHZhbHVlOiBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKSwgY29uZmlndXJhYmxlOiAhMCB9LFxuICAgICAgICBiaW5kOiB7IHZhbHVlOiBiaW5kLCBjb25maWd1cmFibGU6ICEwIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbi8vIFRoaXMgaXMgYSBwYXRjaCBhZGRlZCBieSBOZXh0LmpzXG5jb25zdCBzZXRUaW1lb3V0T3JJbW1lZGlhdGUgPVxuICB0eXBlb2YgZ2xvYmFsVGhpc1snc2V0JyArICdJbW1lZGlhdGUnXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAvLyBlZGdlIHJ1bnRpbWUgc2FuZGJveCBkZWZpbmVzIGEgc3R1YiBmb3Igc2V0SW1tZWRpYXRlXG4gIC8vIChzZWUgJ2FkZFN0dWInIGluIHBhY2thZ2VzL25leHQvc3JjL3NlcnZlci93ZWIvc2FuZGJveC9jb250ZXh0LnRzKVxuICAvLyBidXQgaXQncyBtYWRlIG5vbi1lbnVtZXJhYmxlLCBzbyB3ZSBjYW4gZGV0ZWN0IGl0XG4gIGdsb2JhbFRoaXMucHJvcGVydHlJc0VudW1lcmFibGUoJ3NldEltbWVkaWF0ZScpXG4gICAgPyBnbG9iYWxUaGlzWydzZXQnICsgJ0ltbWVkaWF0ZSddXG4gICAgOiBzZXRUaW1lb3V0O1xuXG4gICAgZXhwb3J0cy5yZW5kZXJUb1JlYWRhYmxlU3RyZWFtID0gZnVuY3Rpb24gKG1vZGVsLCB3ZWJwYWNrTWFwLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QoXG4gICAgICAgIG1vZGVsLFxuICAgICAgICB3ZWJwYWNrTWFwLFxuICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5vbkVycm9yIDogdm9pZCAwLFxuICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IDogdm9pZCAwLFxuICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5vblBvc3Rwb25lIDogdm9pZCAwLFxuICAgICAgICBvcHRpb25zID8gb3B0aW9ucy50ZW1wb3JhcnlSZWZlcmVuY2VzIDogdm9pZCAwLFxuICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5lbnZpcm9ubWVudE5hbWUgOiB2b2lkIDAsXG4gICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmZpbHRlclN0YWNrRnJhbWUgOiB2b2lkIDBcbiAgICAgICk7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICB2YXIgc2lnbmFsID0gb3B0aW9ucy5zaWduYWw7XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkgYWJvcnQocmVxdWVzdCwgc2lnbmFsLnJlYXNvbik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFib3J0KHJlcXVlc3QsIHNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbShcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RhcnRXb3JrKHJlcXVlc3QpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcHVsbDogZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBjb250cm9sbGVyKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBhYm9ydChyZXF1ZXN0LCByZWFzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeyBoaWdoV2F0ZXJNYXJrOiAwIH1cbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLnVuc3RhYmxlX3ByZXJlbmRlciA9IGZ1bmN0aW9uIChtb2RlbCwgd2VicGFja01hcCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBjcmVhdGVQcmVyZW5kZXJSZXF1ZXN0KFxuICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgIHdlYnBhY2tNYXAsXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbShcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICAgICAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgc3RhcnRXb3JrKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHVsbDogZnVuY3Rpb24gKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBhYm9ydChyZXF1ZXN0LCByZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeyBoaWdoV2F0ZXJNYXJrOiAwIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXNvbHZlKHsgcHJlbHVkZTogc3RyZWFtIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLm9uRXJyb3IgOiB2b2lkIDAsXG4gICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCA6IHZvaWQgMCxcbiAgICAgICAgICBvcHRpb25zID8gb3B0aW9ucy5vblBvc3Rwb25lIDogdm9pZCAwLFxuICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLnRlbXBvcmFyeVJlZmVyZW5jZXMgOiB2b2lkIDAsXG4gICAgICAgICAgb3B0aW9ucyA/IG9wdGlvbnMuZW52aXJvbm1lbnROYW1lIDogdm9pZCAwLFxuICAgICAgICAgIG9wdGlvbnMgPyBvcHRpb25zLmZpbHRlclN0YWNrRnJhbWUgOiB2b2lkIDBcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICB2YXIgc2lnbmFsID0gb3B0aW9ucy5zaWduYWw7XG4gICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSBhYm9ydChyZXF1ZXN0LCBzaWduYWwucmVhc29uKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgYWJvcnQocmVxdWVzdCwgc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFydFdvcmsocmVxdWVzdCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9KSgpO1xuIl0sIm5hbWVzIjpbInZvaWRIYW5kbGVyIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsImEiLCJlIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJoYW5kbGVFcnJvckluTmV4dFRpY2siLCJlcnJvciIsInNldFRpbWVvdXRPckltbWVkaWF0ZSIsIndyaXRlQ2h1bmtBbmRSZXR1cm4iLCJkZXN0aW5hdGlvbiIsImNodW5rIiwiYnl0ZUxlbmd0aCIsIndyaXR0ZW5CeXRlcyIsImVucXVldWUiLCJVaW50OEFycmF5IiwiY3VycmVudFZpZXciLCJidWZmZXIiLCJhbGxvd2FibGVCeXRlcyIsImxlbmd0aCIsInNldCIsInN1YmFycmF5Iiwic3RyaW5nVG9DaHVuayIsImNvbnRlbnQiLCJ0ZXh0RW5jb2RlciIsImVuY29kZSIsImJ5dGVMZW5ndGhPZkNodW5rIiwiY2xvc2VXaXRoRXJyb3IiLCJjbG9zZSIsImlzQ2xpZW50UmVmZXJlbmNlIiwicmVmZXJlbmNlIiwiJCR0eXBlb2YiLCJDTElFTlRfUkVGRVJFTkNFX1RBRyQxIiwicmVnaXN0ZXJDbGllbnRSZWZlcmVuY2VJbXBsIiwicHJveHlJbXBsZW1lbnRhdGlvbiIsImlkIiwiYXN5bmMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiJCRpZCIsIiQkYXN5bmMiLCJiaW5kIiwibmV3Rm4iLCJGdW5jdGlvbkJpbmQiLCJhcHBseSIsImFyZ3VtZW50cyIsIlNFUlZFUl9SRUZFUkVOQ0VfVEFHIiwiY29uc29sZSIsImFyZ3MiLCJBcnJheVNsaWNlIiwiJCRib3VuZCIsImNvbmNhdCIsIiQkbG9jYXRpb24iLCJnZXRSZWZlcmVuY2UiLCJ0YXJnZXQiLCJuYW1lIiwicHJvdG90eXBlIiwidG9TdHJpbmdUYWciLCJtb2R1bGVJZCIsImRlZmF1bHQiLCJFcnJvciIsInRoZW4iLCJjbGllbnRSZWZlcmVuY2UiLCJwcm94eSIsIlByb3h5IiwicHJveHlIYW5kbGVycyQxIiwic3RhdHVzIiwicmVzb2x2ZSIsIlByb21pc2UiLCJkZWVwUHJveHlIYW5kbGVycyIsInRyaW1PcHRpb25zIiwib3B0aW9ucyIsImhhc1Byb3BlcnRpZXMiLCJ0cmltbWVkIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJzdHJ1Y3R1cmVkU3RhY2tUcmFjZSIsIm1lc3NhZ2UiLCJpIiwidG9TdHJpbmciLCJwYXJzZVN0YWNrVHJhY2UiLCJza2lwRnJhbWVzIiwicHJldmlvdXNQcmVwYXJlIiwic3RhY2siLCJzdGFydHNXaXRoIiwic2xpY2UiLCJpbmRleE9mIiwibGFzdEluZGV4T2YiLCJzcGxpdCIsImZyYW1lUmVnRXhwIiwiZXhlYyIsImZpbGVuYW1lIiwicHVzaCIsImNyZWF0ZVRlbXBvcmFyeVJlZmVyZW5jZSIsInRlbXBvcmFyeVJlZmVyZW5jZXMiLCJURU1QT1JBUllfUkVGRVJFTkNFX1RBRyIsInByb3h5SGFuZGxlcnMiLCJub29wJDEiLCJ0cmFja1VzZWRUaGVuYWJsZSIsInRoZW5hYmxlU3RhdGUiLCJ0aGVuYWJsZSIsImluZGV4IiwicmVhc29uIiwiZnVsZmlsbGVkVmFsdWUiLCJmdWxmaWxsZWRUaGVuYWJsZSIsInJlamVjdGVkVGhlbmFibGUiLCJzdXNwZW5kZWRUaGVuYWJsZSIsIlN1c3BlbnNlRXhjZXB0aW9uIiwiZ2V0U3VzcGVuZGVkVGhlbmFibGUiLCJnZXRUaGVuYWJsZVN0YXRlQWZ0ZXJTdXNwZW5kaW5nIiwic3RhdGUiLCJfY29tcG9uZW50RGVidWdJbmZvIiwiY3VycmVudENvbXBvbmVudERlYnVnSW5mbyIsInVuc3VwcG9ydGVkSG9vayIsInVuc3VwcG9ydGVkUmVmcmVzaCIsInVuc3VwcG9ydGVkQ29udGV4dCIsInJlc29sdmVPd25lciIsImN1cnJlbnRPd25lciIsInN1cHBvcnRzQ29tcG9uZW50U3RvcmFnZSIsIm93bmVyIiwiY29tcG9uZW50U3RvcmFnZSIsImdldFN0b3JlIiwicmVzZXRPd25lclN0YWNrTGltaXQiLCJub3ciLCJnZXRDdXJyZW50VGltZSIsImxhc3RSZXNldFRpbWUiLCJSZWFjdFNoYXJlZEludGVybmFsc1NlcnZlciIsInJlY2VudGx5Q3JlYXRlZE93bmVyU3RhY2tzIiwiaXNPYmplY3RQcm90b3R5cGUiLCJvYmplY3QiLCJPYmplY3RQcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsImdldE93blByb3BlcnR5TmFtZXMiLCJpc1NpbXBsZU9iamVjdCIsIm5hbWVzIiwiZGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsIm9iamVjdE5hbWUiLCJyZXBsYWNlIiwibSIsInAwIiwiZGVzY3JpYmVLZXlGb3JFcnJvck1lc3NhZ2UiLCJlbmNvZGVkS2V5IiwiSlNPTiIsInN0cmluZ2lmeSIsImRlc2NyaWJlVmFsdWVGb3JFcnJvck1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsIkNMSUVOVF9SRUZFUkVOQ0VfVEFHIiwiZGlzcGxheU5hbWUiLCJkZXNjcmliZUVsZW1lbnRUeXBlIiwidHlwZSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwicmVuZGVyIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwicGF5bG9hZCIsIl9wYXlsb2FkIiwiX2luaXQiLCJ4IiwiZGVzY3JpYmVPYmplY3RGb3JFcnJvck1lc3NhZ2UiLCJvYmplY3RPckFycmF5IiwiZXhwYW5kZWROYW1lIiwib2JqS2luZCIsInN0YXJ0IiwianN4Q2hpbGRyZW5QYXJlbnRzIiwiaGFzIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwianN4UHJvcHNQYXJlbnRzIiwia2V5cyIsIl92YWx1ZTIiLCJfc3Vic3RyMiIsInJlcGVhdCIsImRlZmF1bHRGaWx0ZXJTdGFja0ZyYW1lIiwiaW5jbHVkZXMiLCJmaWx0ZXJTdGFja1RyYWNlIiwicmVxdWVzdCIsImZpbHRlclN0YWNrRnJhbWUiLCJjYWxsc2l0ZSIsImZ1bmN0aW9uTmFtZSIsInVybCIsImVudklkeCIsInN1ZmZpeElkeCIsInNwbGljZSIsInBhdGNoQ29uc29sZSIsImNvbnNvbGVJbnN0IiwibWV0aG9kTmFtZSIsIm9yaWdpbmFsTWV0aG9kIiwid3JhcHBlck1ldGhvZCIsInJlc29sdmVSZXF1ZXN0IiwicGVuZGluZ0NodW5rcyIsImVtaXRDb25zb2xlQ2h1bmsiLCJnZXRDdXJyZW50U3RhY2tJbkRFViIsImluZm8iLCJvd25lclN0YWNrIiwiZGVidWdTdGFjayIsIkpTQ29tcGlsZXJfdGVtcF9jb25zdCIsInByZXZQcmVwYXJlU3RhY2tUcmFjZSIsImlkeCIsIkpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCIsIkpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCIsInByZWZpeCIsInRyaW0iLCJtYXRjaCIsInN1ZmZpeCIsImRlZmF1bHRFcnJvckhhbmRsZXIiLCJkZWZhdWx0UG9zdHBvbmVIYW5kbGVyIiwiUmVxdWVzdEluc3RhbmNlIiwibW9kZWwiLCJidW5kbGVyQ29uZmlnIiwib25FcnJvciIsImlkZW50aWZpZXJQcmVmaXgiLCJvblBvc3Rwb25lIiwiZW52aXJvbm1lbnROYW1lIiwib25BbGxSZWFkeSIsIm9uRmF0YWxFcnJvciIsIkEiLCJEZWZhdWx0QXN5bmNEaXNwYXRjaGVyIiwiZ2V0Q3VycmVudFN0YWNrIiwiYWJvcnRTZXQiLCJTZXQiLCJwaW5nZWRUYXNrcyIsImhpbnRzIiwiT1BFTklORyIsImZsdXNoU2NoZWR1bGVkIiwiZmF0YWxFcnJvciIsImNhY2hlIiwiTWFwIiwibmV4dENodW5rSWQiLCJhYm9ydExpc3RlbmVycyIsImFib3J0YWJsZVRhc2tzIiwiY29tcGxldGVkSW1wb3J0Q2h1bmtzIiwiY29tcGxldGVkSGludENodW5rcyIsImNvbXBsZXRlZFJlZ3VsYXJDaHVua3MiLCJjb21wbGV0ZWRFcnJvckNodW5rcyIsIndyaXR0ZW5TeW1ib2xzIiwid3JpdHRlbkNsaWVudFJlZmVyZW5jZXMiLCJ3cml0dGVuU2VydmVyUmVmZXJlbmNlcyIsIndyaXR0ZW5PYmplY3RzIiwiV2Vha01hcCIsImlkZW50aWZpZXJDb3VudCIsInRhaW50Q2xlYW51cFF1ZXVlIiwiZGlkV2FybkZvcktleSIsImNyZWF0ZVRhc2siLCJub29wIiwiY3JlYXRlUmVxdWVzdCIsImNyZWF0ZVByZXJlbmRlclJlcXVlc3QiLCJQUkVSRU5ERVIiLCJjdXJyZW50UmVxdWVzdCIsInN1cHBvcnRzUmVxdWVzdFN0b3JhZ2UiLCJzdG9yZSIsInJlcXVlc3RTdG9yYWdlIiwic2VyaWFsaXplVGhlbmFibGUiLCJ0YXNrIiwibmV3VGFzayIsImtleVBhdGgiLCJpbXBsaWNpdFNsb3QiLCJkZWJ1Z093bmVyIiwiZGVidWdUYXNrIiwiX2RlYnVnSW5mbyIsImZvcndhcmREZWJ1Z0luZm8iLCJwaW5nVGFzayIsImVycm9yZWRUYXNrIiwiQUJPUlRJTkciLCJkZWxldGUiLCJBQk9SVEVEIiwic2VyaWFsaXplQnlWYWx1ZUlEIiwiZW1pdE1vZGVsQ2h1bmsiLCJQRU5ESU5HJDEiLCJlbnF1ZXVlRmx1c2giLCJzZXJpYWxpemVSZWFkYWJsZVN0cmVhbSIsInN0cmVhbSIsInByb2dyZXNzIiwiZW50cnkiLCJhYm9ydGVkIiwiZG9uZSIsImFib3J0U3RyZWFtIiwic3RyZWFtVGFzayIsInRyeVN0cmVhbVRhc2siLCJyZWFkZXIiLCJyZWFkIiwieCQwIiwiY2FuY2VsIiwic3VwcG9ydHNCWU9CIiwiZ2V0UmVhZGVyIiwibW9kZSIsInJlbGVhc2VMb2NrIiwiYWRkIiwic2VyaWFsaXplQXN5bmNJdGVyYWJsZSIsIml0ZXJhYmxlIiwiaXRlcmF0b3IiLCJhYm9ydEl0ZXJhYmxlIiwiZW5kU3RyZWFtUm93IiwiY2h1bmtJZCIsIm91dGxpbmVNb2RlbCIsImNhbGxJdGVyYXRvckluREVWIiwieCQxIiwidGhyb3ciLCJpc0l0ZXJhdG9yIiwiZW1pdEhpbnQiLCJjb2RlIiwicmVhZFRoZW5hYmxlIiwiY3JlYXRlTGF6eVdyYXBwZXJBcm91bmRXYWtlYWJsZSIsIndha2VhYmxlIiwibGF6eVR5cGUiLCJjYWxsV2l0aERlYnVnQ29udGV4dEluREVWIiwiY2FsbGJhY2siLCJhcmciLCJjb21wb25lbnREZWJ1Z0luZm8iLCJlbnYiLCJydW4iLCJwcm9jZXNzU2VydmVyQ29tcG9uZW50UmV0dXJuVmFsdWUiLCJDb21wb25lbnQiLCJyZXN1bHQiLCJyZXNvbHZlZFZhbHVlIiwiX3N0b3JlIiwidmFsaWRhdGVkIiwiaXRlcmF0b3JGbiIsIm11bHRpU2hvdCIsIkFTWU5DX0lURVJBVE9SIiwiUmVhZGFibGVTdHJlYW0iLCJyZW5kZXJGdW5jdGlvbkNvbXBvbmVudCIsInByb3BzIiwicHJldlRoZW5hYmxlU3RhdGUiLCJkZWJ1Z0lEIiwib3V0bGluZVRhc2siLCJjb21wb25lbnREZWJ1Z0lEIiwiY29tcG9uZW50RW52Iiwib3V0bGluZUNvbXBvbmVudEluZm8iLCJlbWl0RGVidWdDaHVuayIsIndhcm5Gb3JNaXNzaW5nS2V5IiwidGhlbmFibGVJbmRleENvdW50ZXIiLCJjYWxsQ29tcG9uZW50SW5ERVYiLCJyZW5kZXJNb2RlbERlc3RydWN0aXZlIiwiZW1wdHlSb290IiwibG9nS2V5RXJyb3IiLCJXZWFrU2V0IiwicmVuZGVyRnJhZ21lbnQiLCJjaGlsZHJlbiIsImNoaWxkIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIkFycmF5IiwiZnJvbSIsInJlbmRlckFzeW5jRnJhZ21lbnQiLCJnZXRBc3luY0l0ZXJhdG9yIiwicmV0cnlUYXNrIiwiQ09NUExFVEVEIiwicmVuZGVyRWxlbWVudCIsInJlZiIsImNhbGxMYXp5SW5pdEluREVWIiwic2NoZWR1bGVNaWNyb3Rhc2siLCJwZXJmb3JtV29yayIsInBpbmciLCJ0b0pTT04iLCJwYXJlbnRQcm9wZXJ0eU5hbWUiLCJwYXJlbnQiLCJvcmlnaW5hbFZhbHVlIiwiRGF0ZSIsInJlbmRlck1vZGVsIiwic2VyaWFsaXplTnVtYmVyIiwibnVtYmVyIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJJbmZpbml0eSIsImVuY29kZVJlZmVyZW5jZUNodW5rIiwic2VyaWFsaXplQ2xpZW50UmVmZXJlbmNlIiwiY2xpZW50UmVmZXJlbmNlS2V5IiwiZXhpc3RpbmdJZCIsImNvbmZpZyIsIm1vZHVsZVBhdGgiLCJyZXNvbHZlZE1vZHVsZURhdGEiLCJjbGllbnRSZWZlcmVuY2VNZXRhZGF0YSIsImNodW5rcyIsImltcG9ydElkIiwianNvbiIsInJvdyIsInByb2Nlc3NlZENodW5rIiwibG9nUmVjb3ZlcmFibGVFcnJvciIsImVtaXRFcnJvckNodW5rIiwic2VyaWFsaXplU2VydmVyUmVmZXJlbmNlIiwic2VydmVyUmVmZXJlbmNlIiwibG9jYXRpb24iLCJib3VuZCIsInNlcmlhbGl6ZUxhcmdlVGV4dFN0cmluZyIsInRleHQiLCJ0ZXh0SWQiLCJlbWl0VGV4dENodW5rIiwic2VyaWFsaXplTWFwIiwibWFwIiwic2VyaWFsaXplRm9ybURhdGEiLCJmb3JtRGF0YSIsImVudHJpZXMiLCJzZXJpYWxpemVTZXQiLCJzZXJpYWxpemVUeXBlZEFycmF5IiwidGFnIiwidHlwZWRBcnJheSIsImJ1ZmZlcklkIiwiZW1pdFR5cGVkQXJyYXlDaHVuayIsInNlcmlhbGl6ZUJsb2IiLCJibG9iIiwiYWJvcnRCbG9iIiwiY2F0Y2giLCJwcmV2S2V5UGF0aCIsInByZXZJbXBsaWNpdFNsb3QiLCJ0aHJvd25WYWx1ZSIsImVsZW1lbnRSZWZlcmVuY2UiLCJfd3JpdHRlbk9iamVjdHMiLCJfZXhpc3RpbmdSZWZlcmVuY2UiLCJtb2RlbFJvb3QiLCJyZWZQcm9wIiwiX293bmVyIiwiX2RlYnVnU3RhY2siLCJfZGVidWdUYXNrIiwiUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSIsIkZvcm1EYXRhIiwic2VyaWFsaXplRXJyb3JWYWx1ZSIsIkFycmF5QnVmZmVyIiwiSW50OEFycmF5IiwiVWludDhDbGFtcGVkQXJyYXkiLCJJbnQxNkFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiVWludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJCaWdJbnQ2NEFycmF5IiwiQmlnVWludDY0QXJyYXkiLCJEYXRhVmlldyIsIkJsb2IiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZGVzY3JpcHRpb24iLCJ0ZXN0IiwiZm9yIiwiZW1pdFN5bWJvbENodW5rIiwicHJldlJlcXVlc3QiLCJlcnJvckRpZ2VzdCIsIkNMT1NFRCIsIkNMT1NJTkciLCJlcnJvckVudiIsImRpZ2VzdCIsImRlYnVnSW5mbyIsImNvdW50ZXIiLCJvYmplY3RMaW1pdCIsInJlbmRlckNvbnNvbGVWYWx1ZSIsImNvbXBvbmVudEluZm8iLCJvdXRsaW5lQ29uc29sZVZhbHVlIiwiYnl0ZU9mZnNldCIsImJpbmFyeUxlbmd0aCIsImRvTm90TGltaXQiLCJGdW5jdGlvbiIsInJlcGxhY2VyIiwic3RhY2tUcmFjZSIsInRpbWUiLCJlbWl0Q2h1bmsiLCJFUlJPUkVEJDEiLCJwcmV2RGVidWdJRCIsIlJFTkRFUklORyIsInJlc29sdmVkTW9kZWwiLCJjdXJyZW50RW52IiwicHJldkRpc3BhdGNoZXIiLCJIIiwiSG9va3NEaXNwYXRjaGVyIiwiY3VycmVudFJlcXVlc3QkMSIsImhhZEFib3J0YWJsZVRhc2tzIiwic2l6ZSIsImZsdXNoQ29tcGxldGVkQ2h1bmtzIiwiaW1wb3J0c0NodW5rcyIsImhpbnRDaHVua3MiLCJyZWd1bGFyQ2h1bmtzIiwiZXJyb3JDaHVua3MiLCJzdGFydFdvcmsiLCJzdGFydEZsb3dpbmciLCJhYm9ydCIsIl9lcnJvcklkMiIsImZvckVhY2giLCJjbGVhciIsIl9lcnJvciIsImVycm9yJDIiLCJyZXNvbHZlU2VydmVyUmVmZXJlbmNlIiwicmVxdWlyZUFzeW5jTW9kdWxlIiwicHJvbWlzZSIsImdsb2JhbFRoaXMiLCJfX25leHRfcmVxdWlyZV9fIiwiaWdub3JlUmVqZWN0IiwicHJlbG9hZE1vZHVsZSIsIm1ldGFkYXRhIiwicHJvbWlzZXMiLCJjaHVua0NhY2hlIiwiX193ZWJwYWNrX2NodW5rX2xvYWRfXyIsImFsbCIsInJlcXVpcmVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiX19lc01vZHVsZSIsIkNodW5rIiwicmVzcG9uc2UiLCJfcmVzcG9uc2UiLCJjcmVhdGVQZW5kaW5nQ2h1bmsiLCJ3YWtlQ2h1bmsiLCJsaXN0ZW5lcnMiLCJ0cmlnZ2VyRXJyb3JPbkNodW5rIiwicmVzb2x2ZU1vZGVsQ2h1bmsiLCJlbnF1ZXVlTW9kZWwiLCJyZXNvbHZlTGlzdGVuZXJzIiwicmVqZWN0TGlzdGVuZXJzIiwiaW5pdGlhbGl6ZU1vZGVsQ2h1bmsiLCJjcmVhdGVSZXNvbHZlZEl0ZXJhdG9yUmVzdWx0Q2h1bmsiLCJyZXNvbHZlSXRlcmF0b3JSZXN1bHRDaHVuayIsImxvYWRTZXJ2ZXJSZWZlcmVuY2UkMSIsInBhcmVudENodW5rIiwicGFyZW50T2JqZWN0IiwiX2J1bmRsZXJDb25maWciLCJfcmVmIiwiZm4iLCJjcmVhdGVNb2RlbFJlc29sdmVyIiwiY3JlYXRlTW9kZWwiLCJjcmVhdGVNb2RlbFJlamVjdCIsInJldml2ZU1vZGVsIiwicGFyZW50T2JqIiwicGFyZW50S2V5IiwicGFyc2VNb2RlbFN0cmluZyIsIl90ZW1wb3JhcnlSZWZlcmVuY2VzIiwiaXNBcnJheSIsImhhc093blByb3BlcnR5IiwicHJldkNodW5rIiwiaW5pdGlhbGl6aW5nQ2h1bmsiLCJwcmV2QmxvY2tlZCIsImluaXRpYWxpemluZ0NodW5rQmxvY2tlZE1vZGVsIiwicm9vdFJlZmVyZW5jZSIsInJhd01vZGVsIiwicGFyc2UiLCJkZXBzIiwicmVwb3J0R2xvYmFsRXJyb3IiLCJfY2xvc2VkIiwiX2Nsb3NlZFJlYXNvbiIsIl9jaHVua3MiLCJnZXRDaHVuayIsIl9mb3JtRGF0YSIsIl9wcmVmaXgiLCJjeWNsaWMiLCJwYXRoIiwiYmxvY2tlZCIsImdldE91dGxpbmVkTW9kZWwiLCJwYXJzZUludCIsImNyZWF0ZU1hcCIsImNyZWF0ZVNldCIsImV4dHJhY3RJdGVyYXRvciIsInBhcnNlVHlwZWRBcnJheSIsImNvbnN0cnVjdG9yIiwiYnl0ZXNQZXJFbGVtZW50IiwiYXJyYXlCdWZmZXIiLCJyZXNvbHZlU3RyZWFtIiwiY29udHJvbGxlciIsImdldEFsbCIsInBhcnNlUmVhZGFibGVTdHJlYW0iLCJjIiwicHJldmlvdXNCbG9ja2VkQ2h1bmsiLCJ2IiwiX2NodW5rIiwiYmxvY2tlZENodW5rIiwiYXN5bmNJdGVyYXRvciIsImNyZWF0ZUl0ZXJhdG9yIiwibmV4dCIsInBhcnNlQXN5bmNJdGVyYWJsZSIsImNsb3NlZCIsIm5leHRXcml0ZUluZGV4IiwibmV4dFJlYWRJbmRleCIsImZvcm1QcmVmaXgiLCJkYXRhIiwiZW50cnlLZXkiLCJhcHBlbmQiLCJOYU4iLCJCaWdJbnQiLCJjcmVhdGVSZXNwb25zZSIsImZvcm1GaWVsZFByZWZpeCIsImJhY2tpbmdGb3JtRGF0YSIsImxvYWRTZXJ2ZXJSZWZlcmVuY2UiLCJkZWNvZGVCb3VuZEFjdGlvbk1ldGFEYXRhIiwiYm9keSIsInNlcnZlck1hbmlmZXN0IiwiUmVhY3RET00iLCJyZXF1aXJlIiwiUmVhY3QiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMIiwiTG9jYWxQcm9taXNlIiwicXVldWVNaWNyb3Rhc2siLCJUZXh0RW5jb2RlciIsIlBST01JU0VfUFJPVE9UWVBFIiwiUmVhY3RET01TaGFyZWRJbnRlcm5hbHMiLCJfX0RPTV9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJkIiwiZiIsInIiLCJEIiwiaHJlZiIsIkMiLCJjcm9zc09yaWdpbiIsIkwiLCJhcyIsImltYWdlU3JjU2V0IiwiaW1hZ2VTaXplcyIsInVuaXF1ZVBhcnQiLCJYIiwic3JjIiwiUyIsInByZWNlZGVuY2UiLCJNIiwiQXN5bmNMb2NhbFN0b3JhZ2UiLCJhc3luY19ob29rcyIsImNyZWF0ZUhvb2siLCJlbmFibGUiLCJkaXNhYmxlIiwiZXhlY3V0aW9uQXN5bmNJZCIsInJlYWRDb250ZXh0IiwidXNlIiwidXNhYmxlIiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUxheW91dEVmZmVjdCIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZU1lbW8iLCJuZXh0Q3JlYXRlIiwidXNlUmVkdWNlciIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlRGVidWdWYWx1ZSIsInVzZURlZmVycmVkVmFsdWUiLCJ1c2VUcmFuc2l0aW9uIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJ1c2VJZCIsInVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzIiwidXNlRm9ybVN0YXRlIiwidXNlQWN0aW9uU3RhdGUiLCJ1c2VPcHRpbWlzdGljIiwidXNlTWVtb0NhY2hlIiwidXNlQ2FjaGVSZWZyZXNoIiwiZ2V0Q2FjaGVGb3JUeXBlIiwicmVzb3VyY2VUeXBlIiwiZ2V0T3duZXIiLCJfX1NFUlZFUl9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUiLCJwZXJmb3JtYW5jZSIsImxvY2FsUGVyZm9ybWFuY2UiLCJsb2NhbERhdGUiLCJjYWxsQ29tcG9uZW50IiwiY2FsbExhenlJbml0IiwibGF6eSIsImluaXQiLCJjYWxsSXRlcmF0b3IiLCJjcmVhdGUiLCJyZWplY3QiLCJleHBvcnRzIiwiY3JlYXRlQ2xpZW50TW9kdWxlUHJveHkiLCJjcmVhdGVUZW1wb3JhcnlSZWZlcmVuY2VTZXQiLCJkZWNvZGVBY3Rpb24iLCJhY3Rpb24iLCJkZWNvZGVGb3JtU3RhdGUiLCJhY3Rpb25SZXN1bHQiLCJtZXRhRGF0YSIsInJlZmVyZW5jZUlkIiwiZGVjb2RlUmVwbHkiLCJ3ZWJwYWNrTWFwIiwiZm9ybSIsImRlY29kZVJlcGx5RnJvbUFzeW5jSXRlcmFibGUiLCJyZXNwb25zZSRqc2NvbXAkMCIsInJlZ2lzdGVyQ2xpZW50UmVmZXJlbmNlIiwiZXhwb3J0TmFtZSIsInJlZ2lzdGVyU2VydmVyUmVmZXJlbmNlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzZXRUaW1lb3V0IiwicmVuZGVyVG9SZWFkYWJsZVN0cmVhbSIsInNpZ25hbCIsImxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJwdWxsIiwiaGlnaFdhdGVyTWFyayIsInVuc3RhYmxlX3ByZXJlbmRlciIsInByZWx1ZGUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/next/dist/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js\n");

/***/ })

});