"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/asn1js";
exports.ids = ["vendor-chunks/asn1js"];
exports.modules = {

/***/ "(rsc)/./node_modules/asn1js/build/index.js":
/*!********************************************!*\
  !*** ./node_modules/asn1js/build/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * Copyright (c) 2014, GMO GlobalSign\n * Copyright (c) 2015-2022, Peculiar Ventures\n * All rights reserved.\n * \n * Author 2014-2019, Yury Strozhevsky\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n * \n * * Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n * \n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n */ \nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(rsc)/./node_modules/pvtsutils/build/index.js\");\nvar pvutils = __webpack_require__(/*! pvutils */ \"(rsc)/./node_modules/pvutils/build/utils.js\");\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar pvtsutils__namespace = /*#__PURE__*/ _interopNamespaceDefault(pvtsutils);\nvar pvutils__namespace = /*#__PURE__*/ _interopNamespaceDefault(pvutils);\nfunction assertBigInt() {\n    if (typeof BigInt === \"undefined\") {\n        throw new Error(\"BigInt is not defined. Your environment doesn't implement BigInt.\");\n    }\n}\nfunction concat(buffers) {\n    let outputLength = 0;\n    let prevLength = 0;\n    for(let i = 0; i < buffers.length; i++){\n        const buffer = buffers[i];\n        outputLength += buffer.byteLength;\n    }\n    const retView = new Uint8Array(outputLength);\n    for(let i = 0; i < buffers.length; i++){\n        const buffer = buffers[i];\n        retView.set(new Uint8Array(buffer), prevLength);\n        prevLength += buffer.byteLength;\n    }\n    return retView.buffer;\n}\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\n    if (!(inputBuffer instanceof Uint8Array)) {\n        baseBlock.error = \"Wrong parameter: inputBuffer must be 'Uint8Array'\";\n        return false;\n    }\n    if (!inputBuffer.byteLength) {\n        baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\n        return false;\n    }\n    if (inputOffset < 0) {\n        baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\n        return false;\n    }\n    if (inputLength < 0) {\n        baseBlock.error = \"Wrong parameter: inputLength less than zero\";\n        return false;\n    }\n    if (inputBuffer.byteLength - inputOffset - inputLength < 0) {\n        baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n        return false;\n    }\n    return true;\n}\nclass ViewWriter {\n    constructor(){\n        this.items = [];\n    }\n    write(buf) {\n        this.items.push(buf);\n    }\n    final() {\n        return concat(this.items);\n    }\n}\nconst powers2 = [\n    new Uint8Array([\n        1\n    ])\n];\nconst digitsString = \"0123456789\";\nconst NAME = \"name\";\nconst VALUE_HEX_VIEW = \"valueHexView\";\nconst IS_HEX_ONLY = \"isHexOnly\";\nconst ID_BLOCK = \"idBlock\";\nconst TAG_CLASS = \"tagClass\";\nconst TAG_NUMBER = \"tagNumber\";\nconst IS_CONSTRUCTED = \"isConstructed\";\nconst FROM_BER = \"fromBER\";\nconst TO_BER = \"toBER\";\nconst LOCAL = \"local\";\nconst EMPTY_STRING = \"\";\nconst EMPTY_BUFFER = new ArrayBuffer(0);\nconst EMPTY_VIEW = new Uint8Array(0);\nconst END_OF_CONTENT_NAME = \"EndOfContent\";\nconst OCTET_STRING_NAME = \"OCTET STRING\";\nconst BIT_STRING_NAME = \"BIT STRING\";\nfunction HexBlock(BaseClass) {\n    var _a;\n    return _a = class Some extends BaseClass {\n        get valueHex() {\n            return this.valueHexView.slice().buffer;\n        }\n        set valueHex(value) {\n            this.valueHexView = new Uint8Array(value);\n        }\n        constructor(...args){\n            var _b;\n            super(...args);\n            const params = args[0] || {};\n            this.isHexOnly = (_b = params.isHexOnly) !== null && _b !== void 0 ? _b : false;\n            this.valueHexView = params.valueHex ? pvtsutils__namespace.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;\n        }\n        fromBER(inputBuffer, inputOffset, inputLength) {\n            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\n            if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n                return -1;\n            }\n            const endLength = inputOffset + inputLength;\n            this.valueHexView = view.subarray(inputOffset, endLength);\n            if (!this.valueHexView.length) {\n                this.warnings.push(\"Zero buffer length\");\n                return inputOffset;\n            }\n            this.blockLength = inputLength;\n            return endLength;\n        }\n        toBER(sizeOnly = false) {\n            if (!this.isHexOnly) {\n                this.error = \"Flag 'isHexOnly' is not set, abort\";\n                return EMPTY_BUFFER;\n            }\n            if (sizeOnly) {\n                return new ArrayBuffer(this.valueHexView.byteLength);\n            }\n            return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;\n        }\n        toJSON() {\n            return {\n                ...super.toJSON(),\n                isHexOnly: this.isHexOnly,\n                valueHex: pvtsutils__namespace.Convert.ToHex(this.valueHexView)\n            };\n        }\n    }, _a.NAME = \"hexBlock\", _a;\n}\nclass LocalBaseBlock {\n    static blockName() {\n        return this.NAME;\n    }\n    get valueBeforeDecode() {\n        return this.valueBeforeDecodeView.slice().buffer;\n    }\n    set valueBeforeDecode(value) {\n        this.valueBeforeDecodeView = new Uint8Array(value);\n    }\n    constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}){\n        this.blockLength = blockLength;\n        this.error = error;\n        this.warnings = warnings;\n        this.valueBeforeDecodeView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(valueBeforeDecode);\n    }\n    toJSON() {\n        return {\n            blockName: this.constructor.NAME,\n            blockLength: this.blockLength,\n            error: this.error,\n            warnings: this.warnings,\n            valueBeforeDecode: pvtsutils__namespace.Convert.ToHex(this.valueBeforeDecodeView)\n        };\n    }\n}\nLocalBaseBlock.NAME = \"baseBlock\";\nclass ValueBlock extends LocalBaseBlock {\n    fromBER(_inputBuffer, _inputOffset, _inputLength) {\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\n    }\n    toBER(_sizeOnly, _writer) {\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\n    }\n}\nValueBlock.NAME = \"valueBlock\";\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {\n    constructor({ idBlock = {} } = {}){\n        var _a, _b, _c, _d;\n        super();\n        if (idBlock) {\n            this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;\n            this.valueHexView = idBlock.valueHex ? pvtsutils__namespace.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;\n            this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;\n            this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;\n            this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;\n        } else {\n            this.tagClass = -1;\n            this.tagNumber = -1;\n            this.isConstructed = false;\n        }\n    }\n    toBER(sizeOnly = false) {\n        let firstOctet = 0;\n        switch(this.tagClass){\n            case 1:\n                firstOctet |= 0x00;\n                break;\n            case 2:\n                firstOctet |= 0x40;\n                break;\n            case 3:\n                firstOctet |= 0x80;\n                break;\n            case 4:\n                firstOctet |= 0xC0;\n                break;\n            default:\n                this.error = \"Unknown tag class\";\n                return EMPTY_BUFFER;\n        }\n        if (this.isConstructed) firstOctet |= 0x20;\n        if (this.tagNumber < 31 && !this.isHexOnly) {\n            const retView = new Uint8Array(1);\n            if (!sizeOnly) {\n                let number = this.tagNumber;\n                number &= 0x1F;\n                firstOctet |= number;\n                retView[0] = firstOctet;\n            }\n            return retView.buffer;\n        }\n        if (!this.isHexOnly) {\n            const encodedBuf = pvutils__namespace.utilToBase(this.tagNumber, 7);\n            const encodedView = new Uint8Array(encodedBuf);\n            const size = encodedBuf.byteLength;\n            const retView = new Uint8Array(size + 1);\n            retView[0] = firstOctet | 0x1F;\n            if (!sizeOnly) {\n                for(let i = 0; i < size - 1; i++)retView[i + 1] = encodedView[i] | 0x80;\n                retView[size] = encodedView[size - 1];\n            }\n            return retView.buffer;\n        }\n        const retView = new Uint8Array(this.valueHexView.byteLength + 1);\n        retView[0] = firstOctet | 0x1F;\n        if (!sizeOnly) {\n            const curView = this.valueHexView;\n            for(let i = 0; i < curView.length - 1; i++)retView[i + 1] = curView[i] | 0x80;\n            retView[this.valueHexView.byteLength] = curView[curView.length - 1];\n        }\n        return retView.buffer;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n            return -1;\n        }\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n        if (intBuffer.length === 0) {\n            this.error = \"Zero buffer length\";\n            return -1;\n        }\n        const tagClassMask = intBuffer[0] & 0xC0;\n        switch(tagClassMask){\n            case 0x00:\n                this.tagClass = 1;\n                break;\n            case 0x40:\n                this.tagClass = 2;\n                break;\n            case 0x80:\n                this.tagClass = 3;\n                break;\n            case 0xC0:\n                this.tagClass = 4;\n                break;\n            default:\n                this.error = \"Unknown tag class\";\n                return -1;\n        }\n        this.isConstructed = (intBuffer[0] & 0x20) === 0x20;\n        this.isHexOnly = false;\n        const tagNumberMask = intBuffer[0] & 0x1F;\n        if (tagNumberMask !== 0x1F) {\n            this.tagNumber = tagNumberMask;\n            this.blockLength = 1;\n        } else {\n            let count = 1;\n            let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);\n            let tagNumberBufferMaxLength = 255;\n            while(intBuffer[count] & 0x80){\n                intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n                count++;\n                if (count >= intBuffer.length) {\n                    this.error = \"End of input reached before message was fully decoded\";\n                    return -1;\n                }\n                if (count === tagNumberBufferMaxLength) {\n                    tagNumberBufferMaxLength += 255;\n                    const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);\n                    for(let i = 0; i < intTagNumberBuffer.length; i++)tempBufferView[i] = intTagNumberBuffer[i];\n                    intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);\n                }\n            }\n            this.blockLength = count + 1;\n            intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n            const tempBufferView = new Uint8Array(count);\n            for(let i = 0; i < count; i++)tempBufferView[i] = intTagNumberBuffer[i];\n            intTagNumberBuffer = this.valueHexView = new Uint8Array(count);\n            intTagNumberBuffer.set(tempBufferView);\n            if (this.blockLength <= 9) this.tagNumber = pvutils__namespace.utilFromBase(intTagNumberBuffer, 7);\n            else {\n                this.isHexOnly = true;\n                this.warnings.push(\"Tag too long, represented as hex-coded\");\n            }\n        }\n        if (this.tagClass === 1 && this.isConstructed) {\n            switch(this.tagNumber){\n                case 1:\n                case 2:\n                case 5:\n                case 6:\n                case 9:\n                case 13:\n                case 14:\n                case 23:\n                case 24:\n                case 31:\n                case 32:\n                case 33:\n                case 34:\n                    this.error = \"Constructed encoding used for primitive type\";\n                    return -1;\n            }\n        }\n        return inputOffset + this.blockLength;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            tagClass: this.tagClass,\n            tagNumber: this.tagNumber,\n            isConstructed: this.isConstructed\n        };\n    }\n}\nLocalIdentificationBlock.NAME = \"identificationBlock\";\nclass LocalLengthBlock extends LocalBaseBlock {\n    constructor({ lenBlock = {} } = {}){\n        var _a, _b, _c;\n        super();\n        this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;\n        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;\n        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const view = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n            return -1;\n        }\n        const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);\n        if (intBuffer.length === 0) {\n            this.error = \"Zero buffer length\";\n            return -1;\n        }\n        if (intBuffer[0] === 0xFF) {\n            this.error = \"Length block 0xFF is reserved by standard\";\n            return -1;\n        }\n        this.isIndefiniteForm = intBuffer[0] === 0x80;\n        if (this.isIndefiniteForm) {\n            this.blockLength = 1;\n            return inputOffset + this.blockLength;\n        }\n        this.longFormUsed = !!(intBuffer[0] & 0x80);\n        if (this.longFormUsed === false) {\n            this.length = intBuffer[0];\n            this.blockLength = 1;\n            return inputOffset + this.blockLength;\n        }\n        const count = intBuffer[0] & 0x7F;\n        if (count > 8) {\n            this.error = \"Too big integer\";\n            return -1;\n        }\n        if (count + 1 > intBuffer.length) {\n            this.error = \"End of input reached before message was fully decoded\";\n            return -1;\n        }\n        const lenOffset = inputOffset + 1;\n        const lengthBufferView = view.subarray(lenOffset, lenOffset + count);\n        if (lengthBufferView[count - 1] === 0x00) this.warnings.push(\"Needlessly long encoded length\");\n        this.length = pvutils__namespace.utilFromBase(lengthBufferView, 8);\n        if (this.longFormUsed && this.length <= 127) this.warnings.push(\"Unnecessary usage of long length form\");\n        this.blockLength = count + 1;\n        return inputOffset + this.blockLength;\n    }\n    toBER(sizeOnly = false) {\n        let retBuf;\n        let retView;\n        if (this.length > 127) this.longFormUsed = true;\n        if (this.isIndefiniteForm) {\n            retBuf = new ArrayBuffer(1);\n            if (sizeOnly === false) {\n                retView = new Uint8Array(retBuf);\n                retView[0] = 0x80;\n            }\n            return retBuf;\n        }\n        if (this.longFormUsed) {\n            const encodedBuf = pvutils__namespace.utilToBase(this.length, 8);\n            if (encodedBuf.byteLength > 127) {\n                this.error = \"Too big length\";\n                return EMPTY_BUFFER;\n            }\n            retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n            if (sizeOnly) return retBuf;\n            const encodedView = new Uint8Array(encodedBuf);\n            retView = new Uint8Array(retBuf);\n            retView[0] = encodedBuf.byteLength | 0x80;\n            for(let i = 0; i < encodedBuf.byteLength; i++)retView[i + 1] = encodedView[i];\n            return retBuf;\n        }\n        retBuf = new ArrayBuffer(1);\n        if (sizeOnly === false) {\n            retView = new Uint8Array(retBuf);\n            retView[0] = this.length;\n        }\n        return retBuf;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            isIndefiniteForm: this.isIndefiniteForm,\n            longFormUsed: this.longFormUsed,\n            length: this.length\n        };\n    }\n}\nLocalLengthBlock.NAME = \"lengthBlock\";\nconst typeStore = {};\nclass BaseBlock extends LocalBaseBlock {\n    constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType){\n        super(parameters);\n        this.name = name;\n        this.optional = optional;\n        if (primitiveSchema) {\n            this.primitiveSchema = primitiveSchema;\n        }\n        this.idBlock = new LocalIdentificationBlock(parameters);\n        this.lenBlock = new LocalLengthBlock(parameters);\n        this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n        if (resultOffset === -1) {\n            this.error = this.valueBlock.error;\n            return resultOffset;\n        }\n        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;\n        return resultOffset;\n    }\n    toBER(sizeOnly, writer) {\n        const _writer = writer || new ViewWriter();\n        if (!writer) {\n            prepareIndefiniteForm(this);\n        }\n        const idBlockBuf = this.idBlock.toBER(sizeOnly);\n        _writer.write(idBlockBuf);\n        if (this.lenBlock.isIndefiniteForm) {\n            _writer.write(new Uint8Array([\n                0x80\n            ]).buffer);\n            this.valueBlock.toBER(sizeOnly, _writer);\n            _writer.write(new ArrayBuffer(2));\n        } else {\n            const valueBlockBuf = this.valueBlock.toBER(sizeOnly);\n            this.lenBlock.length = valueBlockBuf.byteLength;\n            const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n            _writer.write(lenBlockBuf);\n            _writer.write(valueBlockBuf);\n        }\n        if (!writer) {\n            return _writer.final();\n        }\n        return EMPTY_BUFFER;\n    }\n    toJSON() {\n        const object = {\n            ...super.toJSON(),\n            idBlock: this.idBlock.toJSON(),\n            lenBlock: this.lenBlock.toJSON(),\n            valueBlock: this.valueBlock.toJSON(),\n            name: this.name,\n            optional: this.optional\n        };\n        if (this.primitiveSchema) object.primitiveSchema = this.primitiveSchema.toJSON();\n        return object;\n    }\n    toString(encoding = \"ascii\") {\n        if (encoding === \"ascii\") {\n            return this.onAsciiEncoding();\n        }\n        return pvtsutils__namespace.Convert.ToHex(this.toBER());\n    }\n    onAsciiEncoding() {\n        const name = this.constructor.NAME;\n        const value = pvtsutils__namespace.Convert.ToHex(this.valueBlock.valueBeforeDecodeView);\n        return `${name} : ${value}`;\n    }\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof this.constructor)) {\n            return false;\n        }\n        const thisRaw = this.toBER();\n        const otherRaw = other.toBER();\n        return pvutils__namespace.isEqualBuffer(thisRaw, otherRaw);\n    }\n}\nBaseBlock.NAME = \"BaseBlock\";\nfunction prepareIndefiniteForm(baseBlock) {\n    var _a;\n    if (baseBlock instanceof typeStore.Constructed) {\n        for (const value of baseBlock.valueBlock.value){\n            if (prepareIndefiniteForm(value)) {\n                baseBlock.lenBlock.isIndefiniteForm = true;\n            }\n        }\n    }\n    return !!((_a = baseBlock.lenBlock) === null || _a === void 0 ? void 0 : _a.isIndefiniteForm);\n}\nclass BaseStringBlock extends BaseBlock {\n    getValue() {\n        return this.valueBlock.value;\n    }\n    setValue(value) {\n        this.valueBlock.value = value;\n    }\n    constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType){\n        super(parameters, stringValueBlockType);\n        if (value) {\n            this.fromString(value);\n        }\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n        if (resultOffset === -1) {\n            this.error = this.valueBlock.error;\n            return resultOffset;\n        }\n        this.fromBuffer(this.valueBlock.valueHexView);\n        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;\n        return resultOffset;\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;\n    }\n}\nBaseStringBlock.NAME = \"BaseStringBlock\";\nclass LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {\n    constructor({ isHexOnly = true, ...parameters } = {}){\n        super(parameters);\n        this.isHexOnly = isHexOnly;\n    }\n}\nLocalPrimitiveValueBlock.NAME = \"PrimitiveValueBlock\";\nvar _a$w;\nclass Primitive extends BaseBlock {\n    constructor(parameters = {}){\n        super(parameters, LocalPrimitiveValueBlock);\n        this.idBlock.isConstructed = false;\n    }\n}\n_a$w = Primitive;\n(()=>{\n    typeStore.Primitive = _a$w;\n})();\nPrimitive.NAME = \"PRIMITIVE\";\nfunction localChangeType(inputObject, newType) {\n    if (inputObject instanceof newType) {\n        return inputObject;\n    }\n    const newObject = new newType();\n    newObject.idBlock = inputObject.idBlock;\n    newObject.lenBlock = inputObject.lenBlock;\n    newObject.warnings = inputObject.warnings;\n    newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;\n    return newObject;\n}\nfunction localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {\n    const incomingOffset = inputOffset;\n    let returnObject = new BaseBlock({}, ValueBlock);\n    const baseBlock = new LocalBaseBlock();\n    if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {\n        returnObject.error = baseBlock.error;\n        return {\n            offset: -1,\n            result: returnObject\n        };\n    }\n    const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);\n    if (!intBuffer.length) {\n        returnObject.error = \"Zero buffer length\";\n        return {\n            offset: -1,\n            result: returnObject\n        };\n    }\n    let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n    if (returnObject.idBlock.warnings.length) {\n        returnObject.warnings.concat(returnObject.idBlock.warnings);\n    }\n    if (resultOffset === -1) {\n        returnObject.error = returnObject.idBlock.error;\n        return {\n            offset: -1,\n            result: returnObject\n        };\n    }\n    inputOffset = resultOffset;\n    inputLength -= returnObject.idBlock.blockLength;\n    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n    if (returnObject.lenBlock.warnings.length) {\n        returnObject.warnings.concat(returnObject.lenBlock.warnings);\n    }\n    if (resultOffset === -1) {\n        returnObject.error = returnObject.lenBlock.error;\n        return {\n            offset: -1,\n            result: returnObject\n        };\n    }\n    inputOffset = resultOffset;\n    inputLength -= returnObject.lenBlock.blockLength;\n    if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {\n        returnObject.error = \"Indefinite length form used for primitive encoding form\";\n        return {\n            offset: -1,\n            result: returnObject\n        };\n    }\n    let newASN1Type = BaseBlock;\n    switch(returnObject.idBlock.tagClass){\n        case 1:\n            if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {\n                returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\n                return {\n                    offset: -1,\n                    result: returnObject\n                };\n            }\n            switch(returnObject.idBlock.tagNumber){\n                case 0:\n                    if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {\n                        returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\n                        return {\n                            offset: -1,\n                            result: returnObject\n                        };\n                    }\n                    newASN1Type = typeStore.EndOfContent;\n                    break;\n                case 1:\n                    newASN1Type = typeStore.Boolean;\n                    break;\n                case 2:\n                    newASN1Type = typeStore.Integer;\n                    break;\n                case 3:\n                    newASN1Type = typeStore.BitString;\n                    break;\n                case 4:\n                    newASN1Type = typeStore.OctetString;\n                    break;\n                case 5:\n                    newASN1Type = typeStore.Null;\n                    break;\n                case 6:\n                    newASN1Type = typeStore.ObjectIdentifier;\n                    break;\n                case 10:\n                    newASN1Type = typeStore.Enumerated;\n                    break;\n                case 12:\n                    newASN1Type = typeStore.Utf8String;\n                    break;\n                case 13:\n                    newASN1Type = typeStore.RelativeObjectIdentifier;\n                    break;\n                case 14:\n                    newASN1Type = typeStore.TIME;\n                    break;\n                case 15:\n                    returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\n                    return {\n                        offset: -1,\n                        result: returnObject\n                    };\n                case 16:\n                    newASN1Type = typeStore.Sequence;\n                    break;\n                case 17:\n                    newASN1Type = typeStore.Set;\n                    break;\n                case 18:\n                    newASN1Type = typeStore.NumericString;\n                    break;\n                case 19:\n                    newASN1Type = typeStore.PrintableString;\n                    break;\n                case 20:\n                    newASN1Type = typeStore.TeletexString;\n                    break;\n                case 21:\n                    newASN1Type = typeStore.VideotexString;\n                    break;\n                case 22:\n                    newASN1Type = typeStore.IA5String;\n                    break;\n                case 23:\n                    newASN1Type = typeStore.UTCTime;\n                    break;\n                case 24:\n                    newASN1Type = typeStore.GeneralizedTime;\n                    break;\n                case 25:\n                    newASN1Type = typeStore.GraphicString;\n                    break;\n                case 26:\n                    newASN1Type = typeStore.VisibleString;\n                    break;\n                case 27:\n                    newASN1Type = typeStore.GeneralString;\n                    break;\n                case 28:\n                    newASN1Type = typeStore.UniversalString;\n                    break;\n                case 29:\n                    newASN1Type = typeStore.CharacterString;\n                    break;\n                case 30:\n                    newASN1Type = typeStore.BmpString;\n                    break;\n                case 31:\n                    newASN1Type = typeStore.DATE;\n                    break;\n                case 32:\n                    newASN1Type = typeStore.TimeOfDay;\n                    break;\n                case 33:\n                    newASN1Type = typeStore.DateTime;\n                    break;\n                case 34:\n                    newASN1Type = typeStore.Duration;\n                    break;\n                default:\n                    {\n                        const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();\n                        newObject.idBlock = returnObject.idBlock;\n                        newObject.lenBlock = returnObject.lenBlock;\n                        newObject.warnings = returnObject.warnings;\n                        returnObject = newObject;\n                    }\n            }\n            break;\n        case 2:\n        case 3:\n        case 4:\n        default:\n            {\n                newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;\n            }\n    }\n    returnObject = localChangeType(returnObject, newASN1Type);\n    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);\n    returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);\n    return {\n        offset: resultOffset,\n        result: returnObject\n    };\n}\nfunction fromBER(inputBuffer) {\n    if (!inputBuffer.byteLength) {\n        const result = new BaseBlock({}, ValueBlock);\n        result.error = \"Input buffer has zero length\";\n        return {\n            offset: -1,\n            result\n        };\n    }\n    return localFromBER(pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);\n}\nfunction checkLen(indefiniteLength, length) {\n    if (indefiniteLength) {\n        return 1;\n    }\n    return length;\n}\nclass LocalConstructedValueBlock extends ValueBlock {\n    constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}){\n        super(parameters);\n        this.value = value;\n        this.isIndefiniteForm = isIndefiniteForm;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const view = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n            return -1;\n        }\n        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);\n        if (this.valueBeforeDecodeView.length === 0) {\n            this.warnings.push(\"Zero buffer length\");\n            return inputOffset;\n        }\n        let currentOffset = inputOffset;\n        while(checkLen(this.isIndefiniteForm, inputLength) > 0){\n            const returnObject = localFromBER(view, currentOffset, inputLength);\n            if (returnObject.offset === -1) {\n                this.error = returnObject.result.error;\n                this.warnings.concat(returnObject.result.warnings);\n                return -1;\n            }\n            currentOffset = returnObject.offset;\n            this.blockLength += returnObject.result.blockLength;\n            inputLength -= returnObject.result.blockLength;\n            this.value.push(returnObject.result);\n            if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {\n                break;\n            }\n        }\n        if (this.isIndefiniteForm) {\n            if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {\n                this.value.pop();\n            } else {\n                this.warnings.push(\"No EndOfContent block encoded\");\n            }\n        }\n        return currentOffset;\n    }\n    toBER(sizeOnly, writer) {\n        const _writer = writer || new ViewWriter();\n        for(let i = 0; i < this.value.length; i++){\n            this.value[i].toBER(sizeOnly, _writer);\n        }\n        if (!writer) {\n            return _writer.final();\n        }\n        return EMPTY_BUFFER;\n    }\n    toJSON() {\n        const object = {\n            ...super.toJSON(),\n            isIndefiniteForm: this.isIndefiniteForm,\n            value: []\n        };\n        for (const value of this.value){\n            object.value.push(value.toJSON());\n        }\n        return object;\n    }\n}\nLocalConstructedValueBlock.NAME = \"ConstructedValueBlock\";\nvar _a$v;\nclass Constructed extends BaseBlock {\n    constructor(parameters = {}){\n        super(parameters, LocalConstructedValueBlock);\n        this.idBlock.isConstructed = true;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n        if (resultOffset === -1) {\n            this.error = this.valueBlock.error;\n            return resultOffset;\n        }\n        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n        if (!this.valueBlock.error.length) this.blockLength += this.valueBlock.blockLength;\n        return resultOffset;\n    }\n    onAsciiEncoding() {\n        const values = [];\n        for (const value of this.valueBlock.value){\n            values.push(value.toString(\"ascii\").split(\"\\n\").map((o)=>`  ${o}`).join(\"\\n\"));\n        }\n        const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;\n        return values.length ? `${blockName} :\\n${values.join(\"\\n\")}` : `${blockName} :`;\n    }\n}\n_a$v = Constructed;\n(()=>{\n    typeStore.Constructed = _a$v;\n})();\nConstructed.NAME = \"CONSTRUCTED\";\nclass LocalEndOfContentValueBlock extends ValueBlock {\n    fromBER(inputBuffer, inputOffset, _inputLength) {\n        return inputOffset;\n    }\n    toBER(_sizeOnly) {\n        return EMPTY_BUFFER;\n    }\n}\nLocalEndOfContentValueBlock.override = \"EndOfContentValueBlock\";\nvar _a$u;\nclass EndOfContent extends BaseBlock {\n    constructor(parameters = {}){\n        super(parameters, LocalEndOfContentValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 0;\n    }\n}\n_a$u = EndOfContent;\n(()=>{\n    typeStore.EndOfContent = _a$u;\n})();\nEndOfContent.NAME = END_OF_CONTENT_NAME;\nvar _a$t;\nclass Null extends BaseBlock {\n    constructor(parameters = {}){\n        super(parameters, ValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 5;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        if (this.lenBlock.length > 0) this.warnings.push(\"Non-zero length of value block for Null type\");\n        if (!this.idBlock.error.length) this.blockLength += this.idBlock.blockLength;\n        if (!this.lenBlock.error.length) this.blockLength += this.lenBlock.blockLength;\n        this.blockLength += inputLength;\n        if (inputOffset + inputLength > inputBuffer.byteLength) {\n            this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n            return -1;\n        }\n        return inputOffset + inputLength;\n    }\n    toBER(sizeOnly, writer) {\n        const retBuf = new ArrayBuffer(2);\n        if (!sizeOnly) {\n            const retView = new Uint8Array(retBuf);\n            retView[0] = 0x05;\n            retView[1] = 0x00;\n        }\n        if (writer) {\n            writer.write(retBuf);\n        }\n        return retBuf;\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME}`;\n    }\n}\n_a$t = Null;\n(()=>{\n    typeStore.Null = _a$t;\n})();\nNull.NAME = \"NULL\";\nclass LocalBooleanValueBlock extends HexBlock(ValueBlock) {\n    get value() {\n        for (const octet of this.valueHexView){\n            if (octet > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    set value(value) {\n        this.valueHexView[0] = value ? 0xFF : 0x00;\n    }\n    constructor({ value, ...parameters } = {}){\n        super(parameters);\n        if (parameters.valueHex) {\n            this.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(parameters.valueHex);\n        } else {\n            this.valueHexView = new Uint8Array(1);\n        }\n        if (value) {\n            this.value = value;\n        }\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n            return -1;\n        }\n        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);\n        if (inputLength > 1) this.warnings.push(\"Boolean value encoded in more then 1 octet\");\n        this.isHexOnly = true;\n        pvutils__namespace.utilDecodeTC.call(this);\n        this.blockLength = inputLength;\n        return inputOffset + inputLength;\n    }\n    toBER() {\n        return this.valueHexView.slice();\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            value: this.value\n        };\n    }\n}\nLocalBooleanValueBlock.NAME = \"BooleanValueBlock\";\nvar _a$s;\nclass Boolean extends BaseBlock {\n    getValue() {\n        return this.valueBlock.value;\n    }\n    setValue(value) {\n        this.valueBlock.value = value;\n    }\n    constructor(parameters = {}){\n        super(parameters, LocalBooleanValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 1;\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME} : ${this.getValue}`;\n    }\n}\n_a$s = Boolean;\n(()=>{\n    typeStore.Boolean = _a$s;\n})();\nBoolean.NAME = \"BOOLEAN\";\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n    constructor({ isConstructed = false, ...parameters } = {}){\n        super(parameters);\n        this.isConstructed = isConstructed;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        let resultOffset = 0;\n        if (this.isConstructed) {\n            this.isHexOnly = false;\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n            if (resultOffset === -1) return resultOffset;\n            for(let i = 0; i < this.value.length; i++){\n                const currentBlockName = this.value[i].constructor.NAME;\n                if (currentBlockName === END_OF_CONTENT_NAME) {\n                    if (this.isIndefiniteForm) break;\n                    else {\n                        this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\n                        return -1;\n                    }\n                }\n                if (currentBlockName !== OCTET_STRING_NAME) {\n                    this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\n                    return -1;\n                }\n            }\n        } else {\n            this.isHexOnly = true;\n            resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n            this.blockLength = inputLength;\n        }\n        return resultOffset;\n    }\n    toBER(sizeOnly, writer) {\n        if (this.isConstructed) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\n        return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            isConstructed: this.isConstructed\n        };\n    }\n}\nLocalOctetStringValueBlock.NAME = \"OctetStringValueBlock\";\nvar _a$r;\nclass OctetString extends BaseBlock {\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}){\n        var _b, _c;\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);\n        super({\n            idBlock: {\n                isConstructed: parameters.isConstructed,\n                ...idBlock\n            },\n            lenBlock: {\n                ...lenBlock,\n                isIndefiniteForm: !!parameters.isIndefiniteForm\n            },\n            ...parameters\n        }, LocalOctetStringValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 4;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n        if (inputLength === 0) {\n            if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n            if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n            return inputOffset;\n        }\n        if (!this.valueBlock.isConstructed) {\n            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\n            const buf = view.subarray(inputOffset, inputOffset + inputLength);\n            try {\n                if (buf.byteLength) {\n                    const asn = localFromBER(buf, 0, buf.byteLength);\n                    if (asn.offset !== -1 && asn.offset === inputLength) {\n                        this.valueBlock.value = [\n                            asn.result\n                        ];\n                    }\n                }\n            } catch  {}\n        }\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\n    }\n    onAsciiEncoding() {\n        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n            return Constructed.prototype.onAsciiEncoding.call(this);\n        }\n        const name = this.constructor.NAME;\n        const value = pvtsutils__namespace.Convert.ToHex(this.valueBlock.valueHexView);\n        return `${name} : ${value}`;\n    }\n    getValue() {\n        if (!this.idBlock.isConstructed) {\n            return this.valueBlock.valueHexView.slice().buffer;\n        }\n        const array = [];\n        for (const content of this.valueBlock.value){\n            if (content instanceof _a$r) {\n                array.push(content.valueBlock.valueHexView);\n            }\n        }\n        return pvtsutils__namespace.BufferSourceConverter.concat(array);\n    }\n}\n_a$r = OctetString;\n(()=>{\n    typeStore.OctetString = _a$r;\n})();\nOctetString.NAME = OCTET_STRING_NAME;\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n    constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}){\n        super(parameters);\n        this.unusedBits = unusedBits;\n        this.isConstructed = isConstructed;\n        this.blockLength = this.valueHexView.byteLength;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        if (!inputLength) {\n            return inputOffset;\n        }\n        let resultOffset = -1;\n        if (this.isConstructed) {\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n            if (resultOffset === -1) return resultOffset;\n            for (const value of this.value){\n                const currentBlockName = value.constructor.NAME;\n                if (currentBlockName === END_OF_CONTENT_NAME) {\n                    if (this.isIndefiniteForm) break;\n                    else {\n                        this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\n                        return -1;\n                    }\n                }\n                if (currentBlockName !== BIT_STRING_NAME) {\n                    this.error = \"BIT STRING may consists of BIT STRINGs only\";\n                    return -1;\n                }\n                const valueBlock = value.valueBlock;\n                if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {\n                    this.error = 'Using of \"unused bits\" inside constructive BIT STRING allowed for least one only';\n                    return -1;\n                }\n                this.unusedBits = valueBlock.unusedBits;\n            }\n            return resultOffset;\n        }\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n            return -1;\n        }\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n        this.unusedBits = intBuffer[0];\n        if (this.unusedBits > 7) {\n            this.error = \"Unused bits for BitString must be in range 0-7\";\n            return -1;\n        }\n        if (!this.unusedBits) {\n            const buf = intBuffer.subarray(1);\n            try {\n                if (buf.byteLength) {\n                    const asn = localFromBER(buf, 0, buf.byteLength);\n                    if (asn.offset !== -1 && asn.offset === inputLength - 1) {\n                        this.value = [\n                            asn.result\n                        ];\n                    }\n                }\n            } catch  {}\n        }\n        this.valueHexView = intBuffer.subarray(1);\n        this.blockLength = intBuffer.length;\n        return inputOffset + inputLength;\n    }\n    toBER(sizeOnly, writer) {\n        if (this.isConstructed) {\n            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\n        }\n        if (sizeOnly) {\n            return new ArrayBuffer(this.valueHexView.byteLength + 1);\n        }\n        if (!this.valueHexView.byteLength) {\n            return EMPTY_BUFFER;\n        }\n        const retView = new Uint8Array(this.valueHexView.length + 1);\n        retView[0] = this.unusedBits;\n        retView.set(this.valueHexView, 1);\n        return retView.buffer;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            unusedBits: this.unusedBits,\n            isConstructed: this.isConstructed\n        };\n    }\n}\nLocalBitStringValueBlock.NAME = \"BitStringValueBlock\";\nvar _a$q;\nclass BitString extends BaseBlock {\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}){\n        var _b, _c;\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);\n        super({\n            idBlock: {\n                isConstructed: parameters.isConstructed,\n                ...idBlock\n            },\n            lenBlock: {\n                ...lenBlock,\n                isIndefiniteForm: !!parameters.isIndefiniteForm\n            },\n            ...parameters\n        }, LocalBitStringValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 3;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\n    }\n    onAsciiEncoding() {\n        if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n            return Constructed.prototype.onAsciiEncoding.call(this);\n        } else {\n            const bits = [];\n            const valueHex = this.valueBlock.valueHexView;\n            for (const byte of valueHex){\n                bits.push(byte.toString(2).padStart(8, \"0\"));\n            }\n            const bitsStr = bits.join(\"\");\n            const name = this.constructor.NAME;\n            const value = bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits);\n            return `${name} : ${value}`;\n        }\n    }\n}\n_a$q = BitString;\n(()=>{\n    typeStore.BitString = _a$q;\n})();\nBitString.NAME = BIT_STRING_NAME;\nvar _a$p;\nfunction viewAdd(first, second) {\n    const c = new Uint8Array([\n        0\n    ]);\n    const firstView = new Uint8Array(first);\n    const secondView = new Uint8Array(second);\n    let firstViewCopy = firstView.slice(0);\n    const firstViewCopyLength = firstViewCopy.length - 1;\n    const secondViewCopy = secondView.slice(0);\n    const secondViewCopyLength = secondViewCopy.length - 1;\n    let value = 0;\n    const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;\n    let counter = 0;\n    for(let i = max; i >= 0; i--, counter++){\n        switch(true){\n            case counter < secondViewCopy.length:\n                value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n                break;\n            default:\n                value = firstViewCopy[firstViewCopyLength - counter] + c[0];\n        }\n        c[0] = value / 10;\n        switch(true){\n            case counter >= firstViewCopy.length:\n                firstViewCopy = pvutils__namespace.utilConcatView(new Uint8Array([\n                    value % 10\n                ]), firstViewCopy);\n                break;\n            default:\n                firstViewCopy[firstViewCopyLength - counter] = value % 10;\n        }\n    }\n    if (c[0] > 0) firstViewCopy = pvutils__namespace.utilConcatView(c, firstViewCopy);\n    return firstViewCopy;\n}\nfunction power2(n) {\n    if (n >= powers2.length) {\n        for(let p = powers2.length; p <= n; p++){\n            const c = new Uint8Array([\n                0\n            ]);\n            let digits = powers2[p - 1].slice(0);\n            for(let i = digits.length - 1; i >= 0; i--){\n                const newValue = new Uint8Array([\n                    (digits[i] << 1) + c[0]\n                ]);\n                c[0] = newValue[0] / 10;\n                digits[i] = newValue[0] % 10;\n            }\n            if (c[0] > 0) digits = pvutils__namespace.utilConcatView(c, digits);\n            powers2.push(digits);\n        }\n    }\n    return powers2[n];\n}\nfunction viewSub(first, second) {\n    let b = 0;\n    const firstView = new Uint8Array(first);\n    const secondView = new Uint8Array(second);\n    const firstViewCopy = firstView.slice(0);\n    const firstViewCopyLength = firstViewCopy.length - 1;\n    const secondViewCopy = secondView.slice(0);\n    const secondViewCopyLength = secondViewCopy.length - 1;\n    let value;\n    let counter = 0;\n    for(let i = secondViewCopyLength; i >= 0; i--, counter++){\n        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n        switch(true){\n            case value < 0:\n                b = 1;\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\n                break;\n            default:\n                b = 0;\n                firstViewCopy[firstViewCopyLength - counter] = value;\n        }\n    }\n    if (b > 0) {\n        for(let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++){\n            value = firstViewCopy[firstViewCopyLength - counter] - b;\n            if (value < 0) {\n                b = 1;\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\n            } else {\n                b = 0;\n                firstViewCopy[firstViewCopyLength - counter] = value;\n                break;\n            }\n        }\n    }\n    return firstViewCopy.slice();\n}\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock) {\n    setValueHex() {\n        if (this.valueHexView.length >= 4) {\n            this.warnings.push(\"Too big Integer for decoding, hex only\");\n            this.isHexOnly = true;\n            this._valueDec = 0;\n        } else {\n            this.isHexOnly = false;\n            if (this.valueHexView.length > 0) {\n                this._valueDec = pvutils__namespace.utilDecodeTC.call(this);\n            }\n        }\n    }\n    constructor({ value, ...parameters } = {}){\n        super(parameters);\n        this._valueDec = 0;\n        if (parameters.valueHex) {\n            this.setValueHex();\n        }\n        if (value !== undefined) {\n            this.valueDec = value;\n        }\n    }\n    set valueDec(v) {\n        this._valueDec = v;\n        this.isHexOnly = false;\n        this.valueHexView = new Uint8Array(pvutils__namespace.utilEncodeTC(v));\n    }\n    get valueDec() {\n        return this._valueDec;\n    }\n    fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\n        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n        if (offset === -1) return offset;\n        const view = this.valueHexView;\n        if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {\n            this.valueHexView = view.subarray(1);\n        } else {\n            if (expectedLength !== 0) {\n                if (view.length < expectedLength) {\n                    if (expectedLength - view.length > 1) expectedLength = view.length + 1;\n                    this.valueHexView = view.subarray(expectedLength - view.length);\n                }\n            }\n        }\n        return offset;\n    }\n    toDER(sizeOnly = false) {\n        const view = this.valueHexView;\n        switch(true){\n            case (view[0] & 0x80) !== 0:\n                {\n                    const updatedView = new Uint8Array(this.valueHexView.length + 1);\n                    updatedView[0] = 0x00;\n                    updatedView.set(view, 1);\n                    this.valueHexView = updatedView;\n                }\n                break;\n            case view[0] === 0x00 && (view[1] & 0x80) === 0:\n                {\n                    this.valueHexView = this.valueHexView.subarray(1);\n                }\n                break;\n        }\n        return this.toBER(sizeOnly);\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n        if (resultOffset === -1) {\n            return resultOffset;\n        }\n        this.setValueHex();\n        return resultOffset;\n    }\n    toBER(sizeOnly) {\n        return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            valueDec: this.valueDec\n        };\n    }\n    toString() {\n        const firstBit = this.valueHexView.length * 8 - 1;\n        let digits = new Uint8Array(this.valueHexView.length * 8 / 3);\n        let bitNumber = 0;\n        let currentByte;\n        const asn1View = this.valueHexView;\n        let result = \"\";\n        let flag = false;\n        for(let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--){\n            currentByte = asn1View[byteNumber];\n            for(let i = 0; i < 8; i++){\n                if ((currentByte & 1) === 1) {\n                    switch(bitNumber){\n                        case firstBit:\n                            digits = viewSub(power2(bitNumber), digits);\n                            result = \"-\";\n                            break;\n                        default:\n                            digits = viewAdd(digits, power2(bitNumber));\n                    }\n                }\n                bitNumber++;\n                currentByte >>= 1;\n            }\n        }\n        for(let i = 0; i < digits.length; i++){\n            if (digits[i]) flag = true;\n            if (flag) result += digitsString.charAt(digits[i]);\n        }\n        if (flag === false) result += digitsString.charAt(0);\n        return result;\n    }\n}\n_a$p = LocalIntegerValueBlock;\nLocalIntegerValueBlock.NAME = \"IntegerValueBlock\";\n(()=>{\n    Object.defineProperty(_a$p.prototype, \"valueHex\", {\n        set: function(v) {\n            this.valueHexView = new Uint8Array(v);\n            this.setValueHex();\n        },\n        get: function() {\n            return this.valueHexView.slice().buffer;\n        }\n    });\n})();\nvar _a$o;\nclass Integer extends BaseBlock {\n    constructor(parameters = {}){\n        super(parameters, LocalIntegerValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 2;\n    }\n    toBigInt() {\n        assertBigInt();\n        return BigInt(this.valueBlock.toString());\n    }\n    static fromBigInt(value) {\n        assertBigInt();\n        const bigIntValue = BigInt(value);\n        const writer = new ViewWriter();\n        const hex = bigIntValue.toString(16).replace(/^-/, \"\");\n        const view = new Uint8Array(pvtsutils__namespace.Convert.FromHex(hex));\n        if (bigIntValue < 0) {\n            const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));\n            first[0] |= 0x80;\n            const firstInt = BigInt(`0x${pvtsutils__namespace.Convert.ToHex(first)}`);\n            const secondInt = firstInt + bigIntValue;\n            const second = pvtsutils__namespace.BufferSourceConverter.toUint8Array(pvtsutils__namespace.Convert.FromHex(secondInt.toString(16)));\n            second[0] |= 0x80;\n            writer.write(second);\n        } else {\n            if (view[0] & 0x80) {\n                writer.write(new Uint8Array([\n                    0\n                ]));\n            }\n            writer.write(view);\n        }\n        const res = new _a$o({\n            valueHex: writer.final()\n        });\n        return res;\n    }\n    convertToDER() {\n        const integer = new _a$o({\n            valueHex: this.valueBlock.valueHexView\n        });\n        integer.valueBlock.toDER();\n        return integer;\n    }\n    convertFromDER() {\n        return new _a$o({\n            valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView\n        });\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;\n    }\n}\n_a$o = Integer;\n(()=>{\n    typeStore.Integer = _a$o;\n})();\nInteger.NAME = \"INTEGER\";\nvar _a$n;\nclass Enumerated extends Integer {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 10;\n    }\n}\n_a$n = Enumerated;\n(()=>{\n    typeStore.Enumerated = _a$n;\n})();\nEnumerated.NAME = \"ENUMERATED\";\nclass LocalSidValueBlock extends HexBlock(ValueBlock) {\n    constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}){\n        super(parameters);\n        this.valueDec = valueDec;\n        this.isFirstSid = isFirstSid;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        if (!inputLength) {\n            return inputOffset;\n        }\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n            return -1;\n        }\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n        this.valueHexView = new Uint8Array(inputLength);\n        for(let i = 0; i < inputLength; i++){\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\n            this.blockLength++;\n            if ((intBuffer[i] & 0x80) === 0x00) break;\n        }\n        const tempView = new Uint8Array(this.blockLength);\n        for(let i = 0; i < this.blockLength; i++){\n            tempView[i] = this.valueHexView[i];\n        }\n        this.valueHexView = tempView;\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n            this.error = \"End of input reached before message was fully decoded\";\n            return -1;\n        }\n        if (this.valueHexView[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n        if (this.blockLength <= 8) this.valueDec = pvutils__namespace.utilFromBase(this.valueHexView, 7);\n        else {\n            this.isHexOnly = true;\n            this.warnings.push(\"Too big SID for decoding, hex only\");\n        }\n        return inputOffset + this.blockLength;\n    }\n    set valueBigInt(value) {\n        assertBigInt();\n        let bits = BigInt(value).toString(2);\n        while(bits.length % 7){\n            bits = \"0\" + bits;\n        }\n        const bytes = new Uint8Array(bits.length / 7);\n        for(let i = 0; i < bytes.length; i++){\n            bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);\n        }\n        this.fromBER(bytes.buffer, 0, bytes.length);\n    }\n    toBER(sizeOnly) {\n        if (this.isHexOnly) {\n            if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);\n            const curView = this.valueHexView;\n            const retView = new Uint8Array(this.blockLength);\n            for(let i = 0; i < this.blockLength - 1; i++)retView[i] = curView[i] | 0x80;\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\n            return retView.buffer;\n        }\n        const encodedBuf = pvutils__namespace.utilToBase(this.valueDec, 7);\n        if (encodedBuf.byteLength === 0) {\n            this.error = \"Error during encoding SID value\";\n            return EMPTY_BUFFER;\n        }\n        const retView = new Uint8Array(encodedBuf.byteLength);\n        if (!sizeOnly) {\n            const encodedView = new Uint8Array(encodedBuf);\n            const len = encodedBuf.byteLength - 1;\n            for(let i = 0; i < len; i++)retView[i] = encodedView[i] | 0x80;\n            retView[len] = encodedView[len];\n        }\n        return retView;\n    }\n    toString() {\n        let result = \"\";\n        if (this.isHexOnly) result = pvtsutils__namespace.Convert.ToHex(this.valueHexView);\n        else {\n            if (this.isFirstSid) {\n                let sidValue = this.valueDec;\n                if (this.valueDec <= 39) result = \"0.\";\n                else {\n                    if (this.valueDec <= 79) {\n                        result = \"1.\";\n                        sidValue -= 40;\n                    } else {\n                        result = \"2.\";\n                        sidValue -= 80;\n                    }\n                }\n                result += sidValue.toString();\n            } else result = this.valueDec.toString();\n        }\n        return result;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            valueDec: this.valueDec,\n            isFirstSid: this.isFirstSid\n        };\n    }\n}\nLocalSidValueBlock.NAME = \"sidBlock\";\nclass LocalObjectIdentifierValueBlock extends ValueBlock {\n    constructor({ value = EMPTY_STRING, ...parameters } = {}){\n        super(parameters);\n        this.value = [];\n        if (value) {\n            this.fromString(value);\n        }\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        let resultOffset = inputOffset;\n        while(inputLength > 0){\n            const sidBlock = new LocalSidValueBlock();\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n            if (resultOffset === -1) {\n                this.blockLength = 0;\n                this.error = sidBlock.error;\n                return resultOffset;\n            }\n            if (this.value.length === 0) sidBlock.isFirstSid = true;\n            this.blockLength += sidBlock.blockLength;\n            inputLength -= sidBlock.blockLength;\n            this.value.push(sidBlock);\n        }\n        return resultOffset;\n    }\n    toBER(sizeOnly) {\n        const retBuffers = [];\n        for(let i = 0; i < this.value.length; i++){\n            const valueBuf = this.value[i].toBER(sizeOnly);\n            if (valueBuf.byteLength === 0) {\n                this.error = this.value[i].error;\n                return EMPTY_BUFFER;\n            }\n            retBuffers.push(valueBuf);\n        }\n        return concat(retBuffers);\n    }\n    fromString(string) {\n        this.value = [];\n        let pos1 = 0;\n        let pos2 = 0;\n        let sid = \"\";\n        let flag = false;\n        do {\n            pos2 = string.indexOf(\".\", pos1);\n            if (pos2 === -1) sid = string.substring(pos1);\n            else sid = string.substring(pos1, pos2);\n            pos1 = pos2 + 1;\n            if (flag) {\n                const sidBlock = this.value[0];\n                let plus = 0;\n                switch(sidBlock.valueDec){\n                    case 0:\n                        break;\n                    case 1:\n                        plus = 40;\n                        break;\n                    case 2:\n                        plus = 80;\n                        break;\n                    default:\n                        this.value = [];\n                        return;\n                }\n                const parsedSID = parseInt(sid, 10);\n                if (isNaN(parsedSID)) return;\n                sidBlock.valueDec = parsedSID + plus;\n                flag = false;\n            } else {\n                const sidBlock = new LocalSidValueBlock();\n                if (sid > Number.MAX_SAFE_INTEGER) {\n                    assertBigInt();\n                    const sidValue = BigInt(sid);\n                    sidBlock.valueBigInt = sidValue;\n                } else {\n                    sidBlock.valueDec = parseInt(sid, 10);\n                    if (isNaN(sidBlock.valueDec)) return;\n                }\n                if (!this.value.length) {\n                    sidBlock.isFirstSid = true;\n                    flag = true;\n                }\n                this.value.push(sidBlock);\n            }\n        }while (pos2 !== -1);\n    }\n    toString() {\n        let result = \"\";\n        let isHexOnly = false;\n        for(let i = 0; i < this.value.length; i++){\n            isHexOnly = this.value[i].isHexOnly;\n            let sidStr = this.value[i].toString();\n            if (i !== 0) result = `${result}.`;\n            if (isHexOnly) {\n                sidStr = `{${sidStr}}`;\n                if (this.value[i].isFirstSid) result = `2.{${sidStr} - 80}`;\n                else result += sidStr;\n            } else result += sidStr;\n        }\n        return result;\n    }\n    toJSON() {\n        const object = {\n            ...super.toJSON(),\n            value: this.toString(),\n            sidArray: []\n        };\n        for(let i = 0; i < this.value.length; i++){\n            object.sidArray.push(this.value[i].toJSON());\n        }\n        return object;\n    }\n}\nLocalObjectIdentifierValueBlock.NAME = \"ObjectIdentifierValueBlock\";\nvar _a$m;\nclass ObjectIdentifier extends BaseBlock {\n    getValue() {\n        return this.valueBlock.toString();\n    }\n    setValue(value) {\n        this.valueBlock.fromString(value);\n    }\n    constructor(parameters = {}){\n        super(parameters, LocalObjectIdentifierValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 6;\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            value: this.getValue()\n        };\n    }\n}\n_a$m = ObjectIdentifier;\n(()=>{\n    typeStore.ObjectIdentifier = _a$m;\n})();\nObjectIdentifier.NAME = \"OBJECT IDENTIFIER\";\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {\n    constructor({ valueDec = 0, ...parameters } = {}){\n        super(parameters);\n        this.valueDec = valueDec;\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        if (inputLength === 0) return inputOffset;\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) return -1;\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n        this.valueHexView = new Uint8Array(inputLength);\n        for(let i = 0; i < inputLength; i++){\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\n            this.blockLength++;\n            if ((intBuffer[i] & 0x80) === 0x00) break;\n        }\n        const tempView = new Uint8Array(this.blockLength);\n        for(let i = 0; i < this.blockLength; i++)tempView[i] = this.valueHexView[i];\n        this.valueHexView = tempView;\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n            this.error = \"End of input reached before message was fully decoded\";\n            return -1;\n        }\n        if (this.valueHexView[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n        if (this.blockLength <= 8) this.valueDec = pvutils__namespace.utilFromBase(this.valueHexView, 7);\n        else {\n            this.isHexOnly = true;\n            this.warnings.push(\"Too big SID for decoding, hex only\");\n        }\n        return inputOffset + this.blockLength;\n    }\n    toBER(sizeOnly) {\n        if (this.isHexOnly) {\n            if (sizeOnly) return new ArrayBuffer(this.valueHexView.byteLength);\n            const curView = this.valueHexView;\n            const retView = new Uint8Array(this.blockLength);\n            for(let i = 0; i < this.blockLength - 1; i++)retView[i] = curView[i] | 0x80;\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\n            return retView.buffer;\n        }\n        const encodedBuf = pvutils__namespace.utilToBase(this.valueDec, 7);\n        if (encodedBuf.byteLength === 0) {\n            this.error = \"Error during encoding SID value\";\n            return EMPTY_BUFFER;\n        }\n        const retView = new Uint8Array(encodedBuf.byteLength);\n        if (!sizeOnly) {\n            const encodedView = new Uint8Array(encodedBuf);\n            const len = encodedBuf.byteLength - 1;\n            for(let i = 0; i < len; i++)retView[i] = encodedView[i] | 0x80;\n            retView[len] = encodedView[len];\n        }\n        return retView.buffer;\n    }\n    toString() {\n        let result = \"\";\n        if (this.isHexOnly) result = pvtsutils__namespace.Convert.ToHex(this.valueHexView);\n        else {\n            result = this.valueDec.toString();\n        }\n        return result;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            valueDec: this.valueDec\n        };\n    }\n}\nLocalRelativeSidValueBlock.NAME = \"relativeSidBlock\";\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\n    constructor({ value = EMPTY_STRING, ...parameters } = {}){\n        super(parameters);\n        this.value = [];\n        if (value) {\n            this.fromString(value);\n        }\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        let resultOffset = inputOffset;\n        while(inputLength > 0){\n            const sidBlock = new LocalRelativeSidValueBlock();\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n            if (resultOffset === -1) {\n                this.blockLength = 0;\n                this.error = sidBlock.error;\n                return resultOffset;\n            }\n            this.blockLength += sidBlock.blockLength;\n            inputLength -= sidBlock.blockLength;\n            this.value.push(sidBlock);\n        }\n        return resultOffset;\n    }\n    toBER(sizeOnly, _writer) {\n        const retBuffers = [];\n        for(let i = 0; i < this.value.length; i++){\n            const valueBuf = this.value[i].toBER(sizeOnly);\n            if (valueBuf.byteLength === 0) {\n                this.error = this.value[i].error;\n                return EMPTY_BUFFER;\n            }\n            retBuffers.push(valueBuf);\n        }\n        return concat(retBuffers);\n    }\n    fromString(string) {\n        this.value = [];\n        let pos1 = 0;\n        let pos2 = 0;\n        let sid = \"\";\n        do {\n            pos2 = string.indexOf(\".\", pos1);\n            if (pos2 === -1) sid = string.substring(pos1);\n            else sid = string.substring(pos1, pos2);\n            pos1 = pos2 + 1;\n            const sidBlock = new LocalRelativeSidValueBlock();\n            sidBlock.valueDec = parseInt(sid, 10);\n            if (isNaN(sidBlock.valueDec)) return true;\n            this.value.push(sidBlock);\n        }while (pos2 !== -1);\n        return true;\n    }\n    toString() {\n        let result = \"\";\n        let isHexOnly = false;\n        for(let i = 0; i < this.value.length; i++){\n            isHexOnly = this.value[i].isHexOnly;\n            let sidStr = this.value[i].toString();\n            if (i !== 0) result = `${result}.`;\n            if (isHexOnly) {\n                sidStr = `{${sidStr}}`;\n                result += sidStr;\n            } else result += sidStr;\n        }\n        return result;\n    }\n    toJSON() {\n        const object = {\n            ...super.toJSON(),\n            value: this.toString(),\n            sidArray: []\n        };\n        for(let i = 0; i < this.value.length; i++)object.sidArray.push(this.value[i].toJSON());\n        return object;\n    }\n}\nLocalRelativeObjectIdentifierValueBlock.NAME = \"RelativeObjectIdentifierValueBlock\";\nvar _a$l;\nclass RelativeObjectIdentifier extends BaseBlock {\n    getValue() {\n        return this.valueBlock.toString();\n    }\n    setValue(value) {\n        this.valueBlock.fromString(value);\n    }\n    constructor(parameters = {}){\n        super(parameters, LocalRelativeObjectIdentifierValueBlock);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 13;\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            value: this.getValue()\n        };\n    }\n}\n_a$l = RelativeObjectIdentifier;\n(()=>{\n    typeStore.RelativeObjectIdentifier = _a$l;\n})();\nRelativeObjectIdentifier.NAME = \"RelativeObjectIdentifier\";\nvar _a$k;\nclass Sequence extends Constructed {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 16;\n    }\n}\n_a$k = Sequence;\n(()=>{\n    typeStore.Sequence = _a$k;\n})();\nSequence.NAME = \"SEQUENCE\";\nvar _a$j;\nclass Set extends Constructed {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 17;\n    }\n}\n_a$j = Set;\n(()=>{\n    typeStore.Set = _a$j;\n})();\nSet.NAME = \"SET\";\nclass LocalStringValueBlock extends HexBlock(ValueBlock) {\n    constructor({ ...parameters } = {}){\n        super(parameters);\n        this.isHexOnly = true;\n        this.value = EMPTY_STRING;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            value: this.value\n        };\n    }\n}\nLocalStringValueBlock.NAME = \"StringValueBlock\";\nclass LocalSimpleStringValueBlock extends LocalStringValueBlock {\n}\nLocalSimpleStringValueBlock.NAME = \"SimpleStringValueBlock\";\nclass LocalSimpleStringBlock extends BaseStringBlock {\n    constructor({ ...parameters } = {}){\n        super(parameters, LocalSimpleStringValueBlock);\n    }\n    fromBuffer(inputBuffer) {\n        this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer));\n    }\n    fromString(inputString) {\n        const strLen = inputString.length;\n        const view = this.valueBlock.valueHexView = new Uint8Array(strLen);\n        for(let i = 0; i < strLen; i++)view[i] = inputString.charCodeAt(i);\n        this.valueBlock.value = inputString;\n    }\n}\nLocalSimpleStringBlock.NAME = \"SIMPLE STRING\";\nclass LocalUtf8StringValueBlock extends LocalSimpleStringBlock {\n    fromBuffer(inputBuffer) {\n        this.valueBlock.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n        try {\n            this.valueBlock.value = pvtsutils__namespace.Convert.ToUtf8String(inputBuffer);\n        } catch (ex) {\n            this.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\n            this.valueBlock.value = pvtsutils__namespace.Convert.ToBinary(inputBuffer);\n        }\n    }\n    fromString(inputString) {\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__namespace.Convert.FromUtf8String(inputString));\n        this.valueBlock.value = inputString;\n    }\n}\nLocalUtf8StringValueBlock.NAME = \"Utf8StringValueBlock\";\nvar _a$i;\nclass Utf8String extends LocalUtf8StringValueBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 12;\n    }\n}\n_a$i = Utf8String;\n(()=>{\n    typeStore.Utf8String = _a$i;\n})();\nUtf8String.NAME = \"UTF8String\";\nclass LocalBmpStringValueBlock extends LocalSimpleStringBlock {\n    fromBuffer(inputBuffer) {\n        this.valueBlock.value = pvtsutils__namespace.Convert.ToUtf16String(inputBuffer);\n        this.valueBlock.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\n    }\n    fromString(inputString) {\n        this.valueBlock.value = inputString;\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__namespace.Convert.FromUtf16String(inputString));\n    }\n}\nLocalBmpStringValueBlock.NAME = \"BmpStringValueBlock\";\nvar _a$h;\nclass BmpString extends LocalBmpStringValueBlock {\n    constructor({ ...parameters } = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 30;\n    }\n}\n_a$h = BmpString;\n(()=>{\n    typeStore.BmpString = _a$h;\n})();\nBmpString.NAME = \"BMPString\";\nclass LocalUniversalStringValueBlock extends LocalSimpleStringBlock {\n    fromBuffer(inputBuffer) {\n        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);\n        const valueView = new Uint8Array(copyBuffer);\n        for(let i = 0; i < valueView.length; i += 4){\n            valueView[i] = valueView[i + 3];\n            valueView[i + 1] = valueView[i + 2];\n            valueView[i + 2] = 0x00;\n            valueView[i + 3] = 0x00;\n        }\n        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n    }\n    fromString(inputString) {\n        const strLength = inputString.length;\n        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);\n        for(let i = 0; i < strLength; i++){\n            const codeBuf = pvutils__namespace.utilToBase(inputString.charCodeAt(i), 8);\n            const codeView = new Uint8Array(codeBuf);\n            if (codeView.length > 4) continue;\n            const dif = 4 - codeView.length;\n            for(let j = codeView.length - 1; j >= 0; j--)valueHexView[i * 4 + j + dif] = codeView[j];\n        }\n        this.valueBlock.value = inputString;\n    }\n}\nLocalUniversalStringValueBlock.NAME = \"UniversalStringValueBlock\";\nvar _a$g;\nclass UniversalString extends LocalUniversalStringValueBlock {\n    constructor({ ...parameters } = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 28;\n    }\n}\n_a$g = UniversalString;\n(()=>{\n    typeStore.UniversalString = _a$g;\n})();\nUniversalString.NAME = \"UniversalString\";\nvar _a$f;\nclass NumericString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 18;\n    }\n}\n_a$f = NumericString;\n(()=>{\n    typeStore.NumericString = _a$f;\n})();\nNumericString.NAME = \"NumericString\";\nvar _a$e;\nclass PrintableString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 19;\n    }\n}\n_a$e = PrintableString;\n(()=>{\n    typeStore.PrintableString = _a$e;\n})();\nPrintableString.NAME = \"PrintableString\";\nvar _a$d;\nclass TeletexString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 20;\n    }\n}\n_a$d = TeletexString;\n(()=>{\n    typeStore.TeletexString = _a$d;\n})();\nTeletexString.NAME = \"TeletexString\";\nvar _a$c;\nclass VideotexString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 21;\n    }\n}\n_a$c = VideotexString;\n(()=>{\n    typeStore.VideotexString = _a$c;\n})();\nVideotexString.NAME = \"VideotexString\";\nvar _a$b;\nclass IA5String extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 22;\n    }\n}\n_a$b = IA5String;\n(()=>{\n    typeStore.IA5String = _a$b;\n})();\nIA5String.NAME = \"IA5String\";\nvar _a$a;\nclass GraphicString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 25;\n    }\n}\n_a$a = GraphicString;\n(()=>{\n    typeStore.GraphicString = _a$a;\n})();\nGraphicString.NAME = \"GraphicString\";\nvar _a$9;\nclass VisibleString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 26;\n    }\n}\n_a$9 = VisibleString;\n(()=>{\n    typeStore.VisibleString = _a$9;\n})();\nVisibleString.NAME = \"VisibleString\";\nvar _a$8;\nclass GeneralString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 27;\n    }\n}\n_a$8 = GeneralString;\n(()=>{\n    typeStore.GeneralString = _a$8;\n})();\nGeneralString.NAME = \"GeneralString\";\nvar _a$7;\nclass CharacterString extends LocalSimpleStringBlock {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 29;\n    }\n}\n_a$7 = CharacterString;\n(()=>{\n    typeStore.CharacterString = _a$7;\n})();\nCharacterString.NAME = \"CharacterString\";\nvar _a$6;\nclass UTCTime extends VisibleString {\n    constructor({ value, valueDate, ...parameters } = {}){\n        super(parameters);\n        this.year = 0;\n        this.month = 0;\n        this.day = 0;\n        this.hour = 0;\n        this.minute = 0;\n        this.second = 0;\n        if (value) {\n            this.fromString(value);\n            this.valueBlock.valueHexView = new Uint8Array(value.length);\n            for(let i = 0; i < value.length; i++)this.valueBlock.valueHexView[i] = value.charCodeAt(i);\n        }\n        if (valueDate) {\n            this.fromDate(valueDate);\n            this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());\n        }\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 23;\n    }\n    fromBuffer(inputBuffer) {\n        this.fromString(String.fromCharCode.apply(null, pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer)));\n    }\n    toBuffer() {\n        const str = this.toString();\n        const buffer = new ArrayBuffer(str.length);\n        const view = new Uint8Array(buffer);\n        for(let i = 0; i < str.length; i++)view[i] = str.charCodeAt(i);\n        return buffer;\n    }\n    fromDate(inputDate) {\n        this.year = inputDate.getUTCFullYear();\n        this.month = inputDate.getUTCMonth() + 1;\n        this.day = inputDate.getUTCDate();\n        this.hour = inputDate.getUTCHours();\n        this.minute = inputDate.getUTCMinutes();\n        this.second = inputDate.getUTCSeconds();\n    }\n    toDate() {\n        return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));\n    }\n    fromString(inputString) {\n        const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n        const parserArray = parser.exec(inputString);\n        if (parserArray === null) {\n            this.error = \"Wrong input string for conversion\";\n            return;\n        }\n        const year = parseInt(parserArray[1], 10);\n        if (year >= 50) this.year = 1900 + year;\n        else this.year = 2000 + year;\n        this.month = parseInt(parserArray[2], 10);\n        this.day = parseInt(parserArray[3], 10);\n        this.hour = parseInt(parserArray[4], 10);\n        this.minute = parseInt(parserArray[5], 10);\n        this.second = parseInt(parserArray[6], 10);\n    }\n    toString(encoding = \"iso\") {\n        if (encoding === \"iso\") {\n            const outputArray = new Array(7);\n            outputArray[0] = pvutils__namespace.padNumber(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);\n            outputArray[1] = pvutils__namespace.padNumber(this.month, 2);\n            outputArray[2] = pvutils__namespace.padNumber(this.day, 2);\n            outputArray[3] = pvutils__namespace.padNumber(this.hour, 2);\n            outputArray[4] = pvutils__namespace.padNumber(this.minute, 2);\n            outputArray[5] = pvutils__namespace.padNumber(this.second, 2);\n            outputArray[6] = \"Z\";\n            return outputArray.join(\"\");\n        }\n        return super.toString(encoding);\n    }\n    onAsciiEncoding() {\n        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            year: this.year,\n            month: this.month,\n            day: this.day,\n            hour: this.hour,\n            minute: this.minute,\n            second: this.second\n        };\n    }\n}\n_a$6 = UTCTime;\n(()=>{\n    typeStore.UTCTime = _a$6;\n})();\nUTCTime.NAME = \"UTCTime\";\nvar _a$5;\nclass GeneralizedTime extends UTCTime {\n    constructor(parameters = {}){\n        var _b;\n        super(parameters);\n        (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 24;\n    }\n    fromDate(inputDate) {\n        super.fromDate(inputDate);\n        this.millisecond = inputDate.getUTCMilliseconds();\n    }\n    toDate() {\n        const utcDate = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond);\n        return new Date(utcDate);\n    }\n    fromString(inputString) {\n        let isUTC = false;\n        let timeString = \"\";\n        let dateTimeString = \"\";\n        let fractionPart = 0;\n        let parser;\n        let hourDifference = 0;\n        let minuteDifference = 0;\n        if (inputString[inputString.length - 1] === \"Z\") {\n            timeString = inputString.substring(0, inputString.length - 1);\n            isUTC = true;\n        } else {\n            const number = new Number(inputString[inputString.length - 1]);\n            if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for conversion\");\n            timeString = inputString;\n        }\n        if (isUTC) {\n            if (timeString.indexOf(\"+\") !== -1) throw new Error(\"Wrong input string for conversion\");\n            if (timeString.indexOf(\"-\") !== -1) throw new Error(\"Wrong input string for conversion\");\n        } else {\n            let multiplier = 1;\n            let differencePosition = timeString.indexOf(\"+\");\n            let differenceString = \"\";\n            if (differencePosition === -1) {\n                differencePosition = timeString.indexOf(\"-\");\n                multiplier = -1;\n            }\n            if (differencePosition !== -1) {\n                differenceString = timeString.substring(differencePosition + 1);\n                timeString = timeString.substring(0, differencePosition);\n                if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error(\"Wrong input string for conversion\");\n                let number = parseInt(differenceString.substring(0, 2), 10);\n                if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for conversion\");\n                hourDifference = multiplier * number;\n                if (differenceString.length === 4) {\n                    number = parseInt(differenceString.substring(2, 4), 10);\n                    if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for conversion\");\n                    minuteDifference = multiplier * number;\n                }\n            }\n        }\n        let fractionPointPosition = timeString.indexOf(\".\");\n        if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(\",\");\n        if (fractionPointPosition !== -1) {\n            const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);\n            if (isNaN(fractionPartCheck.valueOf())) throw new Error(\"Wrong input string for conversion\");\n            fractionPart = fractionPartCheck.valueOf();\n            dateTimeString = timeString.substring(0, fractionPointPosition);\n        } else dateTimeString = timeString;\n        switch(true){\n            case dateTimeString.length === 8:\n                parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n                if (fractionPointPosition !== -1) throw new Error(\"Wrong input string for conversion\");\n                break;\n            case dateTimeString.length === 10:\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n                if (fractionPointPosition !== -1) {\n                    let fractionResult = 60 * fractionPart;\n                    this.minute = Math.floor(fractionResult);\n                    fractionResult = 60 * (fractionResult - this.minute);\n                    this.second = Math.floor(fractionResult);\n                    fractionResult = 1000 * (fractionResult - this.second);\n                    this.millisecond = Math.floor(fractionResult);\n                }\n                break;\n            case dateTimeString.length === 12:\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n                if (fractionPointPosition !== -1) {\n                    let fractionResult = 60 * fractionPart;\n                    this.second = Math.floor(fractionResult);\n                    fractionResult = 1000 * (fractionResult - this.second);\n                    this.millisecond = Math.floor(fractionResult);\n                }\n                break;\n            case dateTimeString.length === 14:\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n                if (fractionPointPosition !== -1) {\n                    const fractionResult = 1000 * fractionPart;\n                    this.millisecond = Math.floor(fractionResult);\n                }\n                break;\n            default:\n                throw new Error(\"Wrong input string for conversion\");\n        }\n        const parserArray = parser.exec(dateTimeString);\n        if (parserArray === null) throw new Error(\"Wrong input string for conversion\");\n        for(let j = 1; j < parserArray.length; j++){\n            switch(j){\n                case 1:\n                    this.year = parseInt(parserArray[j], 10);\n                    break;\n                case 2:\n                    this.month = parseInt(parserArray[j], 10);\n                    break;\n                case 3:\n                    this.day = parseInt(parserArray[j], 10);\n                    break;\n                case 4:\n                    this.hour = parseInt(parserArray[j], 10) + hourDifference;\n                    break;\n                case 5:\n                    this.minute = parseInt(parserArray[j], 10) + minuteDifference;\n                    break;\n                case 6:\n                    this.second = parseInt(parserArray[j], 10);\n                    break;\n                default:\n                    throw new Error(\"Wrong input string for conversion\");\n            }\n        }\n        if (isUTC === false) {\n            const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n            this.year = tempDate.getUTCFullYear();\n            this.month = tempDate.getUTCMonth();\n            this.day = tempDate.getUTCDay();\n            this.hour = tempDate.getUTCHours();\n            this.minute = tempDate.getUTCMinutes();\n            this.second = tempDate.getUTCSeconds();\n            this.millisecond = tempDate.getUTCMilliseconds();\n        }\n    }\n    toString(encoding = \"iso\") {\n        if (encoding === \"iso\") {\n            const outputArray = [];\n            outputArray.push(pvutils__namespace.padNumber(this.year, 4));\n            outputArray.push(pvutils__namespace.padNumber(this.month, 2));\n            outputArray.push(pvutils__namespace.padNumber(this.day, 2));\n            outputArray.push(pvutils__namespace.padNumber(this.hour, 2));\n            outputArray.push(pvutils__namespace.padNumber(this.minute, 2));\n            outputArray.push(pvutils__namespace.padNumber(this.second, 2));\n            if (this.millisecond !== 0) {\n                outputArray.push(\".\");\n                outputArray.push(pvutils__namespace.padNumber(this.millisecond, 3));\n            }\n            outputArray.push(\"Z\");\n            return outputArray.join(\"\");\n        }\n        return super.toString(encoding);\n    }\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            millisecond: this.millisecond\n        };\n    }\n}\n_a$5 = GeneralizedTime;\n(()=>{\n    typeStore.GeneralizedTime = _a$5;\n})();\nGeneralizedTime.NAME = \"GeneralizedTime\";\nvar _a$4;\nclass DATE extends Utf8String {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 31;\n    }\n}\n_a$4 = DATE;\n(()=>{\n    typeStore.DATE = _a$4;\n})();\nDATE.NAME = \"DATE\";\nvar _a$3;\nclass TimeOfDay extends Utf8String {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 32;\n    }\n}\n_a$3 = TimeOfDay;\n(()=>{\n    typeStore.TimeOfDay = _a$3;\n})();\nTimeOfDay.NAME = \"TimeOfDay\";\nvar _a$2;\nclass DateTime extends Utf8String {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 33;\n    }\n}\n_a$2 = DateTime;\n(()=>{\n    typeStore.DateTime = _a$2;\n})();\nDateTime.NAME = \"DateTime\";\nvar _a$1;\nclass Duration extends Utf8String {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 34;\n    }\n}\n_a$1 = Duration;\n(()=>{\n    typeStore.Duration = _a$1;\n})();\nDuration.NAME = \"Duration\";\nvar _a;\nclass TIME extends Utf8String {\n    constructor(parameters = {}){\n        super(parameters);\n        this.idBlock.tagClass = 1;\n        this.idBlock.tagNumber = 14;\n    }\n}\n_a = TIME;\n(()=>{\n    typeStore.TIME = _a;\n})();\nTIME.NAME = \"TIME\";\nclass Any {\n    constructor({ name = EMPTY_STRING, optional = false } = {}){\n        this.name = name;\n        this.optional = optional;\n    }\n}\nclass Choice extends Any {\n    constructor({ value = [], ...parameters } = {}){\n        super(parameters);\n        this.value = value;\n    }\n}\nclass Repeated extends Any {\n    constructor({ value = new Any(), local = false, ...parameters } = {}){\n        super(parameters);\n        this.value = value;\n        this.local = local;\n    }\n}\nclass RawData {\n    get data() {\n        return this.dataView.slice().buffer;\n    }\n    set data(value) {\n        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(value);\n    }\n    constructor({ data = EMPTY_VIEW } = {}){\n        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(data);\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n        const endLength = inputOffset + inputLength;\n        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);\n        return endLength;\n    }\n    toBER(_sizeOnly) {\n        return this.dataView.slice().buffer;\n    }\n}\nfunction compareSchema(root, inputData, inputSchema) {\n    if (inputSchema instanceof Choice) {\n        for (const element of inputSchema.value){\n            const result = compareSchema(root, inputData, element);\n            if (result.verified) {\n                return {\n                    verified: true,\n                    result: root\n                };\n            }\n        }\n        {\n            const _result = {\n                verified: false,\n                result: {\n                    error: \"Wrong values for Choice type\"\n                }\n            };\n            if (inputSchema.hasOwnProperty(NAME)) _result.name = inputSchema.name;\n            return _result;\n        }\n    }\n    if (inputSchema instanceof Any) {\n        if (inputSchema.hasOwnProperty(NAME)) root[inputSchema.name] = inputData;\n        return {\n            verified: true,\n            result: root\n        };\n    }\n    if (root instanceof Object === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong root object\"\n            }\n        };\n    }\n    if (inputData instanceof Object === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 data\"\n            }\n        };\n    }\n    if (inputSchema instanceof Object === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (ID_BLOCK in inputSchema === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (FROM_BER in inputSchema.idBlock === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (TO_BER in inputSchema.idBlock === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    const encodedId = inputSchema.idBlock.toBER(false);\n    if (encodedId.byteLength === 0) {\n        return {\n            verified: false,\n            result: {\n                error: \"Error encoding idBlock for ASN.1 schema\"\n            }\n        };\n    }\n    const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n    if (decodedOffset === -1) {\n        return {\n            verified: false,\n            result: {\n                error: \"Error decoding idBlock for ASN.1 schema\"\n            }\n        };\n    }\n    if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\n        return {\n            verified: false,\n            result: root\n        };\n    }\n    if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\n        return {\n            verified: false,\n            result: root\n        };\n    }\n    if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\n        return {\n            verified: false,\n            result: root\n        };\n    }\n    if (!(IS_HEX_ONLY in inputSchema.idBlock)) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema\"\n            }\n        };\n    }\n    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\n        return {\n            verified: false,\n            result: root\n        };\n    }\n    if (inputSchema.idBlock.isHexOnly) {\n        if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {\n            return {\n                verified: false,\n                result: {\n                    error: \"Wrong ASN.1 schema\"\n                }\n            };\n        }\n        const schemaView = inputSchema.idBlock.valueHexView;\n        const asn1View = inputData.idBlock.valueHexView;\n        if (schemaView.length !== asn1View.length) {\n            return {\n                verified: false,\n                result: root\n            };\n        }\n        for(let i = 0; i < schemaView.length; i++){\n            if (schemaView[i] !== asn1View[1]) {\n                return {\n                    verified: false,\n                    result: root\n                };\n            }\n        }\n    }\n    if (inputSchema.name) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n        if (inputSchema.name) root[inputSchema.name] = inputData;\n    }\n    if (inputSchema instanceof typeStore.Constructed) {\n        let admission = 0;\n        let result = {\n            verified: false,\n            result: {\n                error: \"Unknown error\"\n            }\n        };\n        let maxLength = inputSchema.valueBlock.value.length;\n        if (maxLength > 0) {\n            if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n                maxLength = inputData.valueBlock.value.length;\n            }\n        }\n        if (maxLength === 0) {\n            return {\n                verified: true,\n                result: root\n            };\n        }\n        if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {\n            let _optional = true;\n            for(let i = 0; i < inputSchema.valueBlock.value.length; i++)_optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\n            if (_optional) {\n                return {\n                    verified: true,\n                    result: root\n                };\n            }\n            if (inputSchema.name) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                if (inputSchema.name) delete root[inputSchema.name];\n            }\n            root.error = \"Inconsistent object length\";\n            return {\n                verified: false,\n                result: root\n            };\n        }\n        for(let i = 0; i < maxLength; i++){\n            if (i - admission >= inputData.valueBlock.value.length) {\n                if (inputSchema.valueBlock.value[i].optional === false) {\n                    const _result = {\n                        verified: false,\n                        result: root\n                    };\n                    root.error = \"Inconsistent length between ASN.1 data and schema\";\n                    if (inputSchema.name) {\n                        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                        if (inputSchema.name) {\n                            delete root[inputSchema.name];\n                            _result.name = inputSchema.name;\n                        }\n                    }\n                    return _result;\n                }\n            } else {\n                if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n                    result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\n                    if (result.verified === false) {\n                        if (inputSchema.valueBlock.value[0].optional) admission++;\n                        else {\n                            if (inputSchema.name) {\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                                if (inputSchema.name) delete root[inputSchema.name];\n                            }\n                            return result;\n                        }\n                    }\n                    if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {\n                        let arrayRoot = {};\n                        if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local) arrayRoot = inputData;\n                        else arrayRoot = root;\n                        if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\") arrayRoot[inputSchema.valueBlock.value[0].name] = [];\n                        arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\n                    }\n                } else {\n                    result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\n                    if (result.verified === false) {\n                        if (inputSchema.valueBlock.value[i].optional) admission++;\n                        else {\n                            if (inputSchema.name) {\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                                if (inputSchema.name) delete root[inputSchema.name];\n                            }\n                            return result;\n                        }\n                    }\n                }\n            }\n        }\n        if (result.verified === false) {\n            const _result = {\n                verified: false,\n                result: root\n            };\n            if (inputSchema.name) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                if (inputSchema.name) {\n                    delete root[inputSchema.name];\n                    _result.name = inputSchema.name;\n                }\n            }\n            return _result;\n        }\n        return {\n            verified: true,\n            result: root\n        };\n    }\n    if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {\n        const asn1 = localFromBER(inputData.valueBlock.valueHexView);\n        if (asn1.offset === -1) {\n            const _result = {\n                verified: false,\n                result: asn1.result\n            };\n            if (inputSchema.name) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                if (inputSchema.name) {\n                    delete root[inputSchema.name];\n                    _result.name = inputSchema.name;\n                }\n            }\n            return _result;\n        }\n        return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n    }\n    return {\n        verified: true,\n        result: root\n    };\n}\nfunction verifySchema(inputBuffer, inputSchema) {\n    if (inputSchema instanceof Object === false) {\n        return {\n            verified: false,\n            result: {\n                error: \"Wrong ASN.1 schema type\"\n            }\n        };\n    }\n    const asn1 = localFromBER(pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer));\n    if (asn1.offset === -1) {\n        return {\n            verified: false,\n            result: asn1.result\n        };\n    }\n    return compareSchema(asn1.result, asn1.result, inputSchema);\n}\nexports.Any = Any;\nexports.BaseBlock = BaseBlock;\nexports.BaseStringBlock = BaseStringBlock;\nexports.BitString = BitString;\nexports.BmpString = BmpString;\nexports.Boolean = Boolean;\nexports.CharacterString = CharacterString;\nexports.Choice = Choice;\nexports.Constructed = Constructed;\nexports.DATE = DATE;\nexports.DateTime = DateTime;\nexports.Duration = Duration;\nexports.EndOfContent = EndOfContent;\nexports.Enumerated = Enumerated;\nexports.GeneralString = GeneralString;\nexports.GeneralizedTime = GeneralizedTime;\nexports.GraphicString = GraphicString;\nexports.HexBlock = HexBlock;\nexports.IA5String = IA5String;\nexports.Integer = Integer;\nexports.Null = Null;\nexports.NumericString = NumericString;\nexports.ObjectIdentifier = ObjectIdentifier;\nexports.OctetString = OctetString;\nexports.Primitive = Primitive;\nexports.PrintableString = PrintableString;\nexports.RawData = RawData;\nexports.RelativeObjectIdentifier = RelativeObjectIdentifier;\nexports.Repeated = Repeated;\nexports.Sequence = Sequence;\nexports.Set = Set;\nexports.TIME = TIME;\nexports.TeletexString = TeletexString;\nexports.TimeOfDay = TimeOfDay;\nexports.UTCTime = UTCTime;\nexports.UniversalString = UniversalString;\nexports.Utf8String = Utf8String;\nexports.ValueBlock = ValueBlock;\nexports.VideotexString = VideotexString;\nexports.ViewWriter = ViewWriter;\nexports.VisibleString = VisibleString;\nexports.compareSchema = compareSchema;\nexports.fromBER = fromBER;\nexports.verifySchema = verifySchema;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXNuMWpzL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdDQyxHQUVEO0FBRUEsSUFBSUEsWUFBWUMsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUMsVUFBVUQsbUJBQU9BLENBQUM7QUFFdEIsU0FBU0UseUJBQXlCQyxDQUFDO0lBQ2pDLElBQUlDLElBQUlDLE9BQU9DLE1BQU0sQ0FBQztJQUN0QixJQUFJSCxHQUFHO1FBQ0xFLE9BQU9FLElBQUksQ0FBQ0osR0FBR0ssT0FBTyxDQUFDLFNBQVVDLENBQUM7WUFDaEMsSUFBSUEsTUFBTSxXQUFXO2dCQUNuQixJQUFJQyxJQUFJTCxPQUFPTSx3QkFBd0IsQ0FBQ1IsR0FBR007Z0JBQzNDSixPQUFPTyxjQUFjLENBQUNSLEdBQUdLLEdBQUdDLEVBQUVHLEdBQUcsR0FBR0gsSUFBSTtvQkFDdENJLFlBQVk7b0JBQ1pELEtBQUs7d0JBQWMsT0FBT1YsQ0FBQyxDQUFDTSxFQUFFO29CQUFFO2dCQUNsQztZQUNGO1FBQ0Y7SUFDRjtJQUNBTCxFQUFFVyxPQUFPLEdBQUdaO0lBQ1osT0FBT0UsT0FBT1csTUFBTSxDQUFDWjtBQUN2QjtBQUVBLElBQUlhLHVCQUF1QixXQUFXLEdBQUVmLHlCQUF5Qkg7QUFDakUsSUFBSW1CLHFCQUFxQixXQUFXLEdBQUVoQix5QkFBeUJEO0FBRS9ELFNBQVNrQjtJQUNMLElBQUksT0FBT0MsV0FBVyxhQUFhO1FBQy9CLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtBQUNKO0FBQ0EsU0FBU0MsT0FBT0MsT0FBTztJQUNuQixJQUFJQyxlQUFlO0lBQ25CLElBQUlDLGFBQWE7SUFDakIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILFFBQVFJLE1BQU0sRUFBRUQsSUFBSztRQUNyQyxNQUFNRSxTQUFTTCxPQUFPLENBQUNHLEVBQUU7UUFDekJGLGdCQUFnQkksT0FBT0MsVUFBVTtJQUNyQztJQUNBLE1BQU1DLFVBQVUsSUFBSUMsV0FBV1A7SUFDL0IsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlILFFBQVFJLE1BQU0sRUFBRUQsSUFBSztRQUNyQyxNQUFNRSxTQUFTTCxPQUFPLENBQUNHLEVBQUU7UUFDekJJLFFBQVFFLEdBQUcsQ0FBQyxJQUFJRCxXQUFXSCxTQUFTSDtRQUNwQ0EsY0FBY0csT0FBT0MsVUFBVTtJQUNuQztJQUNBLE9BQU9DLFFBQVFGLE1BQU07QUFDekI7QUFDQSxTQUFTSyxrQkFBa0JDLFNBQVMsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVc7SUFDdkUsSUFBSSxDQUFFRixDQUFBQSx1QkFBdUJKLFVBQVMsR0FBSTtRQUN0Q0csVUFBVUksS0FBSyxHQUFHO1FBQ2xCLE9BQU87SUFDWDtJQUNBLElBQUksQ0FBQ0gsWUFBWU4sVUFBVSxFQUFFO1FBQ3pCSyxVQUFVSSxLQUFLLEdBQUc7UUFDbEIsT0FBTztJQUNYO0lBQ0EsSUFBSUYsY0FBYyxHQUFHO1FBQ2pCRixVQUFVSSxLQUFLLEdBQUc7UUFDbEIsT0FBTztJQUNYO0lBQ0EsSUFBSUQsY0FBYyxHQUFHO1FBQ2pCSCxVQUFVSSxLQUFLLEdBQUc7UUFDbEIsT0FBTztJQUNYO0lBQ0EsSUFBSSxZQUFhVCxVQUFVLEdBQUdPLGNBQWNDLGNBQWUsR0FBRztRQUMxREgsVUFBVUksS0FBSyxHQUFHO1FBQ2xCLE9BQU87SUFDWDtJQUNBLE9BQU87QUFDWDtBQUVBLE1BQU1DO0lBQ0ZDLGFBQWM7UUFDVixJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO0lBQ25CO0lBQ0FDLE1BQU1DLEdBQUcsRUFBRTtRQUNQLElBQUksQ0FBQ0YsS0FBSyxDQUFDRyxJQUFJLENBQUNEO0lBQ3BCO0lBQ0FFLFFBQVE7UUFDSixPQUFPdkIsT0FBTyxJQUFJLENBQUNtQixLQUFLO0lBQzVCO0FBQ0o7QUFFQSxNQUFNSyxVQUFVO0lBQUMsSUFBSWYsV0FBVztRQUFDO0tBQUU7Q0FBRTtBQUNyQyxNQUFNZ0IsZUFBZTtBQUNyQixNQUFNQyxPQUFPO0FBQ2IsTUFBTUMsaUJBQWlCO0FBQ3ZCLE1BQU1DLGNBQWM7QUFDcEIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxZQUFZO0FBQ2xCLE1BQU1DLGFBQWE7QUFDbkIsTUFBTUMsaUJBQWlCO0FBQ3ZCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFFBQVE7QUFDZCxNQUFNQyxlQUFlO0FBQ3JCLE1BQU1DLGVBQWUsSUFBSUMsWUFBWTtBQUNyQyxNQUFNQyxhQUFhLElBQUk5QixXQUFXO0FBQ2xDLE1BQU0rQixzQkFBc0I7QUFDNUIsTUFBTUMsb0JBQW9CO0FBQzFCLE1BQU1DLGtCQUFrQjtBQUV4QixTQUFTQyxTQUFTQyxTQUFTO0lBQ3ZCLElBQUlDO0lBQ0osT0FBT0EsS0FBSyxNQUFNQyxhQUFhRjtRQUN2QixJQUFJRyxXQUFXO1lBQ1gsT0FBTyxJQUFJLENBQUNDLFlBQVksQ0FBQ0MsS0FBSyxHQUFHM0MsTUFBTTtRQUMzQztRQUNBLElBQUl5QyxTQUFTRyxLQUFLLEVBQUU7WUFDaEIsSUFBSSxDQUFDRixZQUFZLEdBQUcsSUFBSXZDLFdBQVd5QztRQUN2QztRQUNBaEMsWUFBWSxHQUFHaUMsSUFBSSxDQUFFO1lBQ2pCLElBQUlDO1lBQ0osS0FBSyxJQUFJRDtZQUNULE1BQU1FLFNBQVNGLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQztZQUMzQixJQUFJLENBQUNHLFNBQVMsR0FBRyxDQUFDRixLQUFLQyxPQUFPQyxTQUFTLE1BQU0sUUFBUUYsT0FBTyxLQUFLLElBQUlBLEtBQUs7WUFDMUUsSUFBSSxDQUFDSixZQUFZLEdBQUdLLE9BQU9OLFFBQVEsR0FBR3BELHFCQUFxQjRELHFCQUFxQixDQUFDQyxZQUFZLENBQUNILE9BQU9OLFFBQVEsSUFBSVI7UUFDckg7UUFDQWtCLFFBQVE1QyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFO1lBQzNDLE1BQU0yQyxPQUFPN0MsdUJBQXVCeUIsY0FBYyxJQUFJN0IsV0FBV0ksZUFBZUE7WUFDaEYsSUFBSSxDQUFDRixrQkFBa0IsSUFBSSxFQUFFK0MsTUFBTTVDLGFBQWFDLGNBQWM7Z0JBQzFELE9BQU8sQ0FBQztZQUNaO1lBQ0EsTUFBTTRDLFlBQVk3QyxjQUFjQztZQUNoQyxJQUFJLENBQUNpQyxZQUFZLEdBQUdVLEtBQUtFLFFBQVEsQ0FBQzlDLGFBQWE2QztZQUMvQyxJQUFJLENBQUMsSUFBSSxDQUFDWCxZQUFZLENBQUMzQyxNQUFNLEVBQUU7Z0JBQzNCLElBQUksQ0FBQ3dELFFBQVEsQ0FBQ3ZDLElBQUksQ0FBQztnQkFDbkIsT0FBT1I7WUFDWDtZQUNBLElBQUksQ0FBQ2dELFdBQVcsR0FBRy9DO1lBQ25CLE9BQU80QztRQUNYO1FBQ0FJLE1BQU1DLFdBQVcsS0FBSyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUNWLFNBQVMsRUFBRTtnQkFDakIsSUFBSSxDQUFDdEMsS0FBSyxHQUFHO2dCQUNiLE9BQU9xQjtZQUNYO1lBQ0EsSUFBSTJCLFVBQVU7Z0JBQ1YsT0FBTyxJQUFJMUIsWUFBWSxJQUFJLENBQUNVLFlBQVksQ0FBQ3pDLFVBQVU7WUFDdkQ7WUFDQSxPQUFPLElBQUssQ0FBQ3lDLFlBQVksQ0FBQ3pDLFVBQVUsS0FBSyxJQUFJLENBQUN5QyxZQUFZLENBQUMxQyxNQUFNLENBQUNDLFVBQVUsR0FDdEUsSUFBSSxDQUFDeUMsWUFBWSxDQUFDMUMsTUFBTSxHQUN4QixJQUFJLENBQUMwQyxZQUFZLENBQUNDLEtBQUssR0FBRzNDLE1BQU07UUFDMUM7UUFDQTJELFNBQVM7WUFDTCxPQUFPO2dCQUNILEdBQUcsS0FBSyxDQUFDQSxRQUFRO2dCQUNqQlgsV0FBVyxJQUFJLENBQUNBLFNBQVM7Z0JBQ3pCUCxVQUFVcEQscUJBQXFCdUUsT0FBTyxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDbkIsWUFBWTtZQUNsRTtRQUNKO0lBQ0osR0FDQUgsR0FBR25CLElBQUksR0FBRyxZQUNWbUI7QUFDUjtBQUVBLE1BQU11QjtJQUNGLE9BQU9DLFlBQVk7UUFDZixPQUFPLElBQUksQ0FBQzNDLElBQUk7SUFDcEI7SUFDQSxJQUFJNEMsb0JBQW9CO1FBQ3BCLE9BQU8sSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ3RCLEtBQUssR0FBRzNDLE1BQU07SUFDcEQ7SUFDQSxJQUFJZ0Usa0JBQWtCcEIsS0FBSyxFQUFFO1FBQ3pCLElBQUksQ0FBQ3FCLHFCQUFxQixHQUFHLElBQUk5RCxXQUFXeUM7SUFDaEQ7SUFDQWhDLFlBQVksRUFBRTRDLGNBQWMsQ0FBQyxFQUFFOUMsUUFBUW9CLFlBQVksRUFBRXlCLFdBQVcsRUFBRSxFQUFFUyxvQkFBb0IvQixVQUFVLEVBQUcsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUN4RyxJQUFJLENBQUN1QixXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQzlDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUM2QyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ1UscUJBQXFCLEdBQUc1RSxxQkFBcUI0RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDYztJQUN6RjtJQUNBTCxTQUFTO1FBQ0wsT0FBTztZQUNISSxXQUFXLElBQUksQ0FBQ25ELFdBQVcsQ0FBQ1EsSUFBSTtZQUNoQ29DLGFBQWEsSUFBSSxDQUFDQSxXQUFXO1lBQzdCOUMsT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDakI2QyxVQUFVLElBQUksQ0FBQ0EsUUFBUTtZQUN2QlMsbUJBQW1CM0UscUJBQXFCdUUsT0FBTyxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDSSxxQkFBcUI7UUFDcEY7SUFDSjtBQUNKO0FBQ0FILGVBQWUxQyxJQUFJLEdBQUc7QUFFdEIsTUFBTThDLG1CQUFtQko7SUFDckJYLFFBQVFnQixZQUFZLEVBQUVDLFlBQVksRUFBRUMsWUFBWSxFQUFFO1FBQzlDLE1BQU1DLFVBQVU7SUFDcEI7SUFDQWIsTUFBTWMsU0FBUyxFQUFFQyxPQUFPLEVBQUU7UUFDdEIsTUFBTUYsVUFBVTtJQUNwQjtBQUNKO0FBQ0FKLFdBQVc5QyxJQUFJLEdBQUc7QUFFbEIsTUFBTXFELGlDQUFpQ3BDLFNBQVN5QjtJQUM1Q2xELFlBQVksRUFBRThELFVBQVUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUMvQixJQUFJbkMsSUFBSU8sSUFBSTZCLElBQUlDO1FBQ2hCLEtBQUs7UUFDTCxJQUFJRixTQUFTO1lBQ1QsSUFBSSxDQUFDMUIsU0FBUyxHQUFHLENBQUNULEtBQUttQyxRQUFRMUIsU0FBUyxNQUFNLFFBQVFULE9BQU8sS0FBSyxJQUFJQSxLQUFLO1lBQzNFLElBQUksQ0FBQ0csWUFBWSxHQUFHZ0MsUUFBUWpDLFFBQVEsR0FDOUJwRCxxQkFBcUI0RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDd0IsUUFBUWpDLFFBQVEsSUFDeEVSO1lBQ04sSUFBSSxDQUFDNEMsUUFBUSxHQUFHLENBQUMvQixLQUFLNEIsUUFBUUcsUUFBUSxNQUFNLFFBQVEvQixPQUFPLEtBQUssSUFBSUEsS0FBSyxDQUFDO1lBQzFFLElBQUksQ0FBQ2dDLFNBQVMsR0FBRyxDQUFDSCxLQUFLRCxRQUFRSSxTQUFTLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUlBLEtBQUssQ0FBQztZQUM1RSxJQUFJLENBQUNJLGFBQWEsR0FBRyxDQUFDSCxLQUFLRixRQUFRSyxhQUFhLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUlBLEtBQUs7UUFDdkYsT0FDSztZQUNELElBQUksQ0FBQ0MsUUFBUSxHQUFHLENBQUM7WUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsQ0FBQztZQUNsQixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUN6QjtJQUNKO0lBQ0F0QixNQUFNQyxXQUFXLEtBQUssRUFBRTtRQUNwQixJQUFJc0IsYUFBYTtRQUNqQixPQUFRLElBQUksQ0FBQ0gsUUFBUTtZQUNqQixLQUFLO2dCQUNERyxjQUFjO2dCQUNkO1lBQ0osS0FBSztnQkFDREEsY0FBYztnQkFDZDtZQUNKLEtBQUs7Z0JBQ0RBLGNBQWM7Z0JBQ2Q7WUFDSixLQUFLO2dCQUNEQSxjQUFjO2dCQUNkO1lBQ0o7Z0JBQ0ksSUFBSSxDQUFDdEUsS0FBSyxHQUFHO2dCQUNiLE9BQU9xQjtRQUNmO1FBQ0EsSUFBSSxJQUFJLENBQUNnRCxhQUFhLEVBQ2xCQyxjQUFjO1FBQ2xCLElBQUksSUFBSSxDQUFDRixTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQzlCLFNBQVMsRUFBRTtZQUN4QyxNQUFNOUMsVUFBVSxJQUFJQyxXQUFXO1lBQy9CLElBQUksQ0FBQ3VELFVBQVU7Z0JBQ1gsSUFBSXVCLFNBQVMsSUFBSSxDQUFDSCxTQUFTO2dCQUMzQkcsVUFBVTtnQkFDVkQsY0FBY0M7Z0JBQ2QvRSxPQUFPLENBQUMsRUFBRSxHQUFHOEU7WUFDakI7WUFDQSxPQUFPOUUsUUFBUUYsTUFBTTtRQUN6QjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUNnRCxTQUFTLEVBQUU7WUFDakIsTUFBTWtDLGFBQWE1RixtQkFBbUI2RixVQUFVLENBQUMsSUFBSSxDQUFDTCxTQUFTLEVBQUU7WUFDakUsTUFBTU0sY0FBYyxJQUFJakYsV0FBVytFO1lBQ25DLE1BQU1HLE9BQU9ILFdBQVdqRixVQUFVO1lBQ2xDLE1BQU1DLFVBQVUsSUFBSUMsV0FBV2tGLE9BQU87WUFDdENuRixPQUFPLENBQUMsRUFBRSxHQUFJOEUsYUFBYTtZQUMzQixJQUFJLENBQUN0QixVQUFVO2dCQUNYLElBQUssSUFBSTVELElBQUksR0FBR0EsSUFBS3VGLE9BQU8sR0FBSXZGLElBQzVCSSxPQUFPLENBQUNKLElBQUksRUFBRSxHQUFHc0YsV0FBVyxDQUFDdEYsRUFBRSxHQUFHO2dCQUN0Q0ksT0FBTyxDQUFDbUYsS0FBSyxHQUFHRCxXQUFXLENBQUNDLE9BQU8sRUFBRTtZQUN6QztZQUNBLE9BQU9uRixRQUFRRixNQUFNO1FBQ3pCO1FBQ0EsTUFBTUUsVUFBVSxJQUFJQyxXQUFXLElBQUksQ0FBQ3VDLFlBQVksQ0FBQ3pDLFVBQVUsR0FBRztRQUM5REMsT0FBTyxDQUFDLEVBQUUsR0FBSThFLGFBQWE7UUFDM0IsSUFBSSxDQUFDdEIsVUFBVTtZQUNYLE1BQU00QixVQUFVLElBQUksQ0FBQzVDLFlBQVk7WUFDakMsSUFBSyxJQUFJNUMsSUFBSSxHQUFHQSxJQUFLd0YsUUFBUXZGLE1BQU0sR0FBRyxHQUFJRCxJQUN0Q0ksT0FBTyxDQUFDSixJQUFJLEVBQUUsR0FBR3dGLE9BQU8sQ0FBQ3hGLEVBQUUsR0FBRztZQUNsQ0ksT0FBTyxDQUFDLElBQUksQ0FBQ3dDLFlBQVksQ0FBQ3pDLFVBQVUsQ0FBQyxHQUFHcUYsT0FBTyxDQUFDQSxRQUFRdkYsTUFBTSxHQUFHLEVBQUU7UUFDdkU7UUFDQSxPQUFPRyxRQUFRRixNQUFNO0lBQ3pCO0lBQ0FtRCxRQUFRNUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxNQUFNOEUsWUFBWWxHLHFCQUFxQjRELHFCQUFxQixDQUFDQyxZQUFZLENBQUMzQztRQUMxRSxJQUFJLENBQUNGLGtCQUFrQixJQUFJLEVBQUVrRixXQUFXL0UsYUFBYUMsY0FBYztZQUMvRCxPQUFPLENBQUM7UUFDWjtRQUNBLE1BQU0rRSxZQUFZRCxVQUFVakMsUUFBUSxDQUFDOUMsYUFBYUEsY0FBY0M7UUFDaEUsSUFBSStFLFVBQVV6RixNQUFNLEtBQUssR0FBRztZQUN4QixJQUFJLENBQUNXLEtBQUssR0FBRztZQUNiLE9BQU8sQ0FBQztRQUNaO1FBQ0EsTUFBTStFLGVBQWVELFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDcEMsT0FBUUM7WUFDSixLQUFLO2dCQUNELElBQUksQ0FBQ1osUUFBUSxHQUFJO2dCQUNqQjtZQUNKLEtBQUs7Z0JBQ0QsSUFBSSxDQUFDQSxRQUFRLEdBQUk7Z0JBQ2pCO1lBQ0osS0FBSztnQkFDRCxJQUFJLENBQUNBLFFBQVEsR0FBSTtnQkFDakI7WUFDSixLQUFLO2dCQUNELElBQUksQ0FBQ0EsUUFBUSxHQUFJO2dCQUNqQjtZQUNKO2dCQUNJLElBQUksQ0FBQ25FLEtBQUssR0FBRztnQkFDYixPQUFPLENBQUM7UUFDaEI7UUFDQSxJQUFJLENBQUNxRSxhQUFhLEdBQUcsQ0FBQ1MsU0FBUyxDQUFDLEVBQUUsR0FBRyxJQUFHLE1BQU87UUFDL0MsSUFBSSxDQUFDeEMsU0FBUyxHQUFHO1FBQ2pCLE1BQU0wQyxnQkFBZ0JGLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDckMsSUFBSUUsa0JBQWtCLE1BQU07WUFDeEIsSUFBSSxDQUFDWixTQUFTLEdBQUlZO1lBQ2xCLElBQUksQ0FBQ2xDLFdBQVcsR0FBRztRQUN2QixPQUNLO1lBQ0QsSUFBSW1DLFFBQVE7WUFDWixJQUFJQyxxQkFBcUIsSUFBSSxDQUFDbEQsWUFBWSxHQUFHLElBQUl2QyxXQUFXO1lBQzVELElBQUkwRiwyQkFBMkI7WUFDL0IsTUFBT0wsU0FBUyxDQUFDRyxNQUFNLEdBQUcsS0FBTTtnQkFDNUJDLGtCQUFrQixDQUFDRCxRQUFRLEVBQUUsR0FBR0gsU0FBUyxDQUFDRyxNQUFNLEdBQUc7Z0JBQ25EQTtnQkFDQSxJQUFJQSxTQUFTSCxVQUFVekYsTUFBTSxFQUFFO29CQUMzQixJQUFJLENBQUNXLEtBQUssR0FBRztvQkFDYixPQUFPLENBQUM7Z0JBQ1o7Z0JBQ0EsSUFBSWlGLFVBQVVFLDBCQUEwQjtvQkFDcENBLDRCQUE0QjtvQkFDNUIsTUFBTUMsaUJBQWlCLElBQUkzRixXQUFXMEY7b0JBQ3RDLElBQUssSUFBSS9GLElBQUksR0FBR0EsSUFBSThGLG1CQUFtQjdGLE1BQU0sRUFBRUQsSUFDM0NnRyxjQUFjLENBQUNoRyxFQUFFLEdBQUc4RixrQkFBa0IsQ0FBQzlGLEVBQUU7b0JBQzdDOEYscUJBQXFCLElBQUksQ0FBQ2xELFlBQVksR0FBRyxJQUFJdkMsV0FBVzBGO2dCQUM1RDtZQUNKO1lBQ0EsSUFBSSxDQUFDckMsV0FBVyxHQUFJbUMsUUFBUTtZQUM1QkMsa0JBQWtCLENBQUNELFFBQVEsRUFBRSxHQUFHSCxTQUFTLENBQUNHLE1BQU0sR0FBRztZQUNuRCxNQUFNRyxpQkFBaUIsSUFBSTNGLFdBQVd3RjtZQUN0QyxJQUFLLElBQUk3RixJQUFJLEdBQUdBLElBQUk2RixPQUFPN0YsSUFDdkJnRyxjQUFjLENBQUNoRyxFQUFFLEdBQUc4RixrQkFBa0IsQ0FBQzlGLEVBQUU7WUFDN0M4RixxQkFBcUIsSUFBSSxDQUFDbEQsWUFBWSxHQUFHLElBQUl2QyxXQUFXd0Y7WUFDeERDLG1CQUFtQnhGLEdBQUcsQ0FBQzBGO1lBQ3ZCLElBQUksSUFBSSxDQUFDdEMsV0FBVyxJQUFJLEdBQ3BCLElBQUksQ0FBQ3NCLFNBQVMsR0FBR3hGLG1CQUFtQnlHLFlBQVksQ0FBQ0gsb0JBQW9CO2lCQUNwRTtnQkFDRCxJQUFJLENBQUM1QyxTQUFTLEdBQUc7Z0JBQ2pCLElBQUksQ0FBQ08sUUFBUSxDQUFDdkMsSUFBSSxDQUFDO1lBQ3ZCO1FBQ0o7UUFDQSxJQUFJLElBQU0sQ0FBQzZELFFBQVEsS0FBSyxLQUNoQixJQUFJLENBQUNFLGFBQWEsRUFBRztZQUN6QixPQUFRLElBQUksQ0FBQ0QsU0FBUztnQkFDbEIsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDRCxJQUFJLENBQUNwRSxLQUFLLEdBQUc7b0JBQ2IsT0FBTyxDQUFDO1lBQ2hCO1FBQ0o7UUFDQSxPQUFRRixjQUFjLElBQUksQ0FBQ2dELFdBQVc7SUFDMUM7SUFDQUcsU0FBUztRQUNMLE9BQU87WUFDSCxHQUFHLEtBQUssQ0FBQ0EsUUFBUTtZQUNqQmtCLFVBQVUsSUFBSSxDQUFDQSxRQUFRO1lBQ3ZCQyxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUN6QkMsZUFBZSxJQUFJLENBQUNBLGFBQWE7UUFDckM7SUFDSjtBQUNKO0FBQ0FOLHlCQUF5QnJELElBQUksR0FBRztBQUVoQyxNQUFNNEUseUJBQXlCbEM7SUFDM0JsRCxZQUFZLEVBQUVxRixXQUFXLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDaEMsSUFBSTFELElBQUlPLElBQUk2QjtRQUNaLEtBQUs7UUFDTCxJQUFJLENBQUN1QixnQkFBZ0IsR0FBRyxDQUFDM0QsS0FBSzBELFNBQVNDLGdCQUFnQixNQUFNLFFBQVEzRCxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUMxRixJQUFJLENBQUM0RCxZQUFZLEdBQUcsQ0FBQ3JELEtBQUttRCxTQUFTRSxZQUFZLE1BQU0sUUFBUXJELE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ2xGLElBQUksQ0FBQy9DLE1BQU0sR0FBRyxDQUFDNEUsS0FBS3NCLFNBQVNsRyxNQUFNLE1BQU0sUUFBUTRFLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0lBQzFFO0lBQ0F4QixRQUFRNUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxNQUFNMkMsT0FBTy9ELHFCQUFxQjRELHFCQUFxQixDQUFDQyxZQUFZLENBQUMzQztRQUNyRSxJQUFJLENBQUNGLGtCQUFrQixJQUFJLEVBQUUrQyxNQUFNNUMsYUFBYUMsY0FBYztZQUMxRCxPQUFPLENBQUM7UUFDWjtRQUNBLE1BQU0rRSxZQUFZcEMsS0FBS0UsUUFBUSxDQUFDOUMsYUFBYUEsY0FBY0M7UUFDM0QsSUFBSStFLFVBQVV6RixNQUFNLEtBQUssR0FBRztZQUN4QixJQUFJLENBQUNXLEtBQUssR0FBRztZQUNiLE9BQU8sQ0FBQztRQUNaO1FBQ0EsSUFBSThFLFNBQVMsQ0FBQyxFQUFFLEtBQUssTUFBTTtZQUN2QixJQUFJLENBQUM5RSxLQUFLLEdBQUc7WUFDYixPQUFPLENBQUM7UUFDWjtRQUNBLElBQUksQ0FBQ3dGLGdCQUFnQixHQUFHVixTQUFTLENBQUMsRUFBRSxLQUFLO1FBQ3pDLElBQUksSUFBSSxDQUFDVSxnQkFBZ0IsRUFBRTtZQUN2QixJQUFJLENBQUMxQyxXQUFXLEdBQUc7WUFDbkIsT0FBUWhELGNBQWMsSUFBSSxDQUFDZ0QsV0FBVztRQUMxQztRQUNBLElBQUksQ0FBQzJDLFlBQVksR0FBRyxDQUFDLENBQUVYLENBQUFBLFNBQVMsQ0FBQyxFQUFFLEdBQUcsSUFBRztRQUN6QyxJQUFJLElBQUksQ0FBQ1csWUFBWSxLQUFLLE9BQU87WUFDN0IsSUFBSSxDQUFDcEcsTUFBTSxHQUFJeUYsU0FBUyxDQUFDLEVBQUU7WUFDM0IsSUFBSSxDQUFDaEMsV0FBVyxHQUFHO1lBQ25CLE9BQVFoRCxjQUFjLElBQUksQ0FBQ2dELFdBQVc7UUFDMUM7UUFDQSxNQUFNbUMsUUFBUUgsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUM3QixJQUFJRyxRQUFRLEdBQUc7WUFDWCxJQUFJLENBQUNqRixLQUFLLEdBQUc7WUFDYixPQUFPLENBQUM7UUFDWjtRQUNBLElBQUksUUFBUyxJQUFLOEUsVUFBVXpGLE1BQU0sRUFBRTtZQUNoQyxJQUFJLENBQUNXLEtBQUssR0FBRztZQUNiLE9BQU8sQ0FBQztRQUNaO1FBQ0EsTUFBTTBGLFlBQVk1RixjQUFjO1FBQ2hDLE1BQU02RixtQkFBbUJqRCxLQUFLRSxRQUFRLENBQUM4QyxXQUFXQSxZQUFZVDtRQUM5RCxJQUFJVSxnQkFBZ0IsQ0FBQ1YsUUFBUSxFQUFFLEtBQUssTUFDaEMsSUFBSSxDQUFDcEMsUUFBUSxDQUFDdkMsSUFBSSxDQUFDO1FBQ3ZCLElBQUksQ0FBQ2pCLE1BQU0sR0FBR1QsbUJBQW1CeUcsWUFBWSxDQUFDTSxrQkFBa0I7UUFDaEUsSUFBSSxJQUFJLENBQUNGLFlBQVksSUFBSyxJQUFJLENBQUNwRyxNQUFNLElBQUksS0FDckMsSUFBSSxDQUFDd0QsUUFBUSxDQUFDdkMsSUFBSSxDQUFDO1FBQ3ZCLElBQUksQ0FBQ3dDLFdBQVcsR0FBR21DLFFBQVE7UUFDM0IsT0FBUW5GLGNBQWMsSUFBSSxDQUFDZ0QsV0FBVztJQUMxQztJQUNBQyxNQUFNQyxXQUFXLEtBQUssRUFBRTtRQUNwQixJQUFJNEM7UUFDSixJQUFJcEc7UUFDSixJQUFJLElBQUksQ0FBQ0gsTUFBTSxHQUFHLEtBQ2QsSUFBSSxDQUFDb0csWUFBWSxHQUFHO1FBQ3hCLElBQUksSUFBSSxDQUFDRCxnQkFBZ0IsRUFBRTtZQUN2QkksU0FBUyxJQUFJdEUsWUFBWTtZQUN6QixJQUFJMEIsYUFBYSxPQUFPO2dCQUNwQnhELFVBQVUsSUFBSUMsV0FBV21HO2dCQUN6QnBHLE9BQU8sQ0FBQyxFQUFFLEdBQUc7WUFDakI7WUFDQSxPQUFPb0c7UUFDWDtRQUNBLElBQUksSUFBSSxDQUFDSCxZQUFZLEVBQUU7WUFDbkIsTUFBTWpCLGFBQWE1RixtQkFBbUI2RixVQUFVLENBQUMsSUFBSSxDQUFDcEYsTUFBTSxFQUFFO1lBQzlELElBQUltRixXQUFXakYsVUFBVSxHQUFHLEtBQUs7Z0JBQzdCLElBQUksQ0FBQ1MsS0FBSyxHQUFHO2dCQUNiLE9BQVFxQjtZQUNaO1lBQ0F1RSxTQUFTLElBQUl0RSxZQUFZa0QsV0FBV2pGLFVBQVUsR0FBRztZQUNqRCxJQUFJeUQsVUFDQSxPQUFPNEM7WUFDWCxNQUFNbEIsY0FBYyxJQUFJakYsV0FBVytFO1lBQ25DaEYsVUFBVSxJQUFJQyxXQUFXbUc7WUFDekJwRyxPQUFPLENBQUMsRUFBRSxHQUFHZ0YsV0FBV2pGLFVBQVUsR0FBRztZQUNyQyxJQUFLLElBQUlILElBQUksR0FBR0EsSUFBSW9GLFdBQVdqRixVQUFVLEVBQUVILElBQ3ZDSSxPQUFPLENBQUNKLElBQUksRUFBRSxHQUFHc0YsV0FBVyxDQUFDdEYsRUFBRTtZQUNuQyxPQUFPd0c7UUFDWDtRQUNBQSxTQUFTLElBQUl0RSxZQUFZO1FBQ3pCLElBQUkwQixhQUFhLE9BQU87WUFDcEJ4RCxVQUFVLElBQUlDLFdBQVdtRztZQUN6QnBHLE9BQU8sQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDSCxNQUFNO1FBQzVCO1FBQ0EsT0FBT3VHO0lBQ1g7SUFDQTNDLFNBQVM7UUFDTCxPQUFPO1lBQ0gsR0FBRyxLQUFLLENBQUNBLFFBQVE7WUFDakJ1QyxrQkFBa0IsSUFBSSxDQUFDQSxnQkFBZ0I7WUFDdkNDLGNBQWMsSUFBSSxDQUFDQSxZQUFZO1lBQy9CcEcsUUFBUSxJQUFJLENBQUNBLE1BQU07UUFDdkI7SUFDSjtBQUNKO0FBQ0FpRyxpQkFBaUI1RSxJQUFJLEdBQUc7QUFFeEIsTUFBTW1GLFlBQVksQ0FBQztBQUVuQixNQUFNQyxrQkFBa0IxQztJQUNwQmxELFlBQVksRUFBRTZGLE9BQU8zRSxZQUFZLEVBQUU0RSxXQUFXLEtBQUssRUFBRUMsZUFBZSxFQUFFLEdBQUdDLFlBQVksR0FBRyxDQUFDLENBQUMsRUFBRUMsY0FBYyxDQUFFO1FBQ3hHLEtBQUssQ0FBQ0Q7UUFDTixJQUFJLENBQUNILElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSUMsaUJBQWlCO1lBQ2pCLElBQUksQ0FBQ0EsZUFBZSxHQUFHQTtRQUMzQjtRQUNBLElBQUksQ0FBQ2pDLE9BQU8sR0FBRyxJQUFJRCx5QkFBeUJtQztRQUM1QyxJQUFJLENBQUNYLFFBQVEsR0FBRyxJQUFJRCxpQkFBaUJZO1FBQ3JDLElBQUksQ0FBQ0UsVUFBVSxHQUFHRCxpQkFBaUIsSUFBSUEsZUFBZUQsY0FBYyxJQUFJMUMsV0FBVzBDO0lBQ3ZGO0lBQ0F6RCxRQUFRNUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxNQUFNc0csZUFBZSxJQUFJLENBQUNELFVBQVUsQ0FBQzNELE9BQU8sQ0FBQzVDLGFBQWFDLGFBQWEsSUFBSyxDQUFDeUYsUUFBUSxDQUFDQyxnQkFBZ0IsR0FDaEd6RixjQUNBLElBQUksQ0FBQ3dGLFFBQVEsQ0FBQ2xHLE1BQU07UUFDMUIsSUFBSWdILGlCQUFpQixDQUFDLEdBQUc7WUFDckIsSUFBSSxDQUFDckcsS0FBSyxHQUFHLElBQUksQ0FBQ29HLFVBQVUsQ0FBQ3BHLEtBQUs7WUFDbEMsT0FBT3FHO1FBQ1g7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDckMsT0FBTyxDQUFDaEUsS0FBSyxDQUFDWCxNQUFNLEVBQzFCLElBQUksQ0FBQ3lELFdBQVcsSUFBSSxJQUFJLENBQUNrQixPQUFPLENBQUNsQixXQUFXO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUN5QyxRQUFRLENBQUN2RixLQUFLLENBQUNYLE1BQU0sRUFDM0IsSUFBSSxDQUFDeUQsV0FBVyxJQUFJLElBQUksQ0FBQ3lDLFFBQVEsQ0FBQ3pDLFdBQVc7UUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQ3NELFVBQVUsQ0FBQ3BHLEtBQUssQ0FBQ1gsTUFBTSxFQUM3QixJQUFJLENBQUN5RCxXQUFXLElBQUksSUFBSSxDQUFDc0QsVUFBVSxDQUFDdEQsV0FBVztRQUNuRCxPQUFPdUQ7SUFDWDtJQUNBdEQsTUFBTUMsUUFBUSxFQUFFc0QsTUFBTSxFQUFFO1FBQ3BCLE1BQU14QyxVQUFVd0MsVUFBVSxJQUFJckc7UUFDOUIsSUFBSSxDQUFDcUcsUUFBUTtZQUNUQyxzQkFBc0IsSUFBSTtRQUM5QjtRQUNBLE1BQU1DLGFBQWEsSUFBSSxDQUFDeEMsT0FBTyxDQUFDakIsS0FBSyxDQUFDQztRQUN0Q2MsUUFBUTFELEtBQUssQ0FBQ29HO1FBQ2QsSUFBSSxJQUFJLENBQUNqQixRQUFRLENBQUNDLGdCQUFnQixFQUFFO1lBQ2hDMUIsUUFBUTFELEtBQUssQ0FBQyxJQUFJWCxXQUFXO2dCQUFDO2FBQUssRUFBRUgsTUFBTTtZQUMzQyxJQUFJLENBQUM4RyxVQUFVLENBQUNyRCxLQUFLLENBQUNDLFVBQVVjO1lBQ2hDQSxRQUFRMUQsS0FBSyxDQUFDLElBQUlrQixZQUFZO1FBQ2xDLE9BQ0s7WUFDRCxNQUFNbUYsZ0JBQWdCLElBQUksQ0FBQ0wsVUFBVSxDQUFDckQsS0FBSyxDQUFDQztZQUM1QyxJQUFJLENBQUN1QyxRQUFRLENBQUNsRyxNQUFNLEdBQUdvSCxjQUFjbEgsVUFBVTtZQUMvQyxNQUFNbUgsY0FBYyxJQUFJLENBQUNuQixRQUFRLENBQUN4QyxLQUFLLENBQUNDO1lBQ3hDYyxRQUFRMUQsS0FBSyxDQUFDc0c7WUFDZDVDLFFBQVExRCxLQUFLLENBQUNxRztRQUNsQjtRQUNBLElBQUksQ0FBQ0gsUUFBUTtZQUNULE9BQU94QyxRQUFRdkQsS0FBSztRQUN4QjtRQUNBLE9BQU9jO0lBQ1g7SUFDQTRCLFNBQVM7UUFDTCxNQUFNMEQsU0FBUztZQUNYLEdBQUcsS0FBSyxDQUFDMUQsUUFBUTtZQUNqQmUsU0FBUyxJQUFJLENBQUNBLE9BQU8sQ0FBQ2YsTUFBTTtZQUM1QnNDLFVBQVUsSUFBSSxDQUFDQSxRQUFRLENBQUN0QyxNQUFNO1lBQzlCbUQsWUFBWSxJQUFJLENBQUNBLFVBQVUsQ0FBQ25ELE1BQU07WUFDbEM4QyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmQyxVQUFVLElBQUksQ0FBQ0EsUUFBUTtRQUMzQjtRQUNBLElBQUksSUFBSSxDQUFDQyxlQUFlLEVBQ3BCVSxPQUFPVixlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlLENBQUNoRCxNQUFNO1FBQ3hELE9BQU8wRDtJQUNYO0lBQ0FDLFNBQVNDLFdBQVcsT0FBTyxFQUFFO1FBQ3pCLElBQUlBLGFBQWEsU0FBUztZQUN0QixPQUFPLElBQUksQ0FBQ0MsZUFBZTtRQUMvQjtRQUNBLE9BQU9uSSxxQkFBcUJ1RSxPQUFPLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUNKLEtBQUs7SUFDeEQ7SUFDQStELGtCQUFrQjtRQUNkLE1BQU1mLE9BQU8sSUFBSSxDQUFDN0YsV0FBVyxDQUFDUSxJQUFJO1FBQ2xDLE1BQU13QixRQUFRdkQscUJBQXFCdUUsT0FBTyxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDaUQsVUFBVSxDQUFDN0MscUJBQXFCO1FBQ3RGLE9BQU8sQ0FBQyxFQUFFd0MsS0FBSyxHQUFHLEVBQUU3RCxNQUFNLENBQUM7SUFDL0I7SUFDQTZFLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxLQUFLQSxPQUFPO1lBQ2hCLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBRUEsQ0FBQUEsaUJBQWlCLElBQUksQ0FBQzlHLFdBQVcsR0FBRztZQUN0QyxPQUFPO1FBQ1g7UUFDQSxNQUFNK0csVUFBVSxJQUFJLENBQUNsRSxLQUFLO1FBQzFCLE1BQU1tRSxXQUFXRixNQUFNakUsS0FBSztRQUM1QixPQUFPbkUsbUJBQW1CdUksYUFBYSxDQUFDRixTQUFTQztJQUNyRDtBQUNKO0FBQ0FwQixVQUFVcEYsSUFBSSxHQUFHO0FBQ2pCLFNBQVM2RixzQkFBc0IzRyxTQUFTO0lBQ3BDLElBQUlpQztJQUNKLElBQUlqQyxxQkFBcUJpRyxVQUFVdUIsV0FBVyxFQUFFO1FBQzVDLEtBQUssTUFBTWxGLFNBQVN0QyxVQUFVd0csVUFBVSxDQUFDbEUsS0FBSyxDQUFFO1lBQzVDLElBQUlxRSxzQkFBc0JyRSxRQUFRO2dCQUM5QnRDLFVBQVUyRixRQUFRLENBQUNDLGdCQUFnQixHQUFHO1lBQzFDO1FBQ0o7SUFDSjtJQUNBLE9BQU8sQ0FBQyxDQUFFLEVBQUMzRCxLQUFLakMsVUFBVTJGLFFBQVEsTUFBTSxRQUFRMUQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMkQsZ0JBQWdCO0FBQ2hHO0FBRUEsTUFBTTZCLHdCQUF3QnZCO0lBQzFCd0IsV0FBVztRQUNQLE9BQU8sSUFBSSxDQUFDbEIsVUFBVSxDQUFDbEUsS0FBSztJQUNoQztJQUNBcUYsU0FBU3JGLEtBQUssRUFBRTtRQUNaLElBQUksQ0FBQ2tFLFVBQVUsQ0FBQ2xFLEtBQUssR0FBR0E7SUFDNUI7SUFDQWhDLFlBQVksRUFBRWdDLFFBQVFkLFlBQVksRUFBRSxHQUFHOEUsWUFBWSxHQUFHLENBQUMsQ0FBQyxFQUFFc0Isb0JBQW9CLENBQUU7UUFDNUUsS0FBSyxDQUFDdEIsWUFBWXNCO1FBQ2xCLElBQUl0RixPQUFPO1lBQ1AsSUFBSSxDQUFDdUYsVUFBVSxDQUFDdkY7UUFDcEI7SUFDSjtJQUNBTyxRQUFRNUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxNQUFNc0csZUFBZSxJQUFJLENBQUNELFVBQVUsQ0FBQzNELE9BQU8sQ0FBQzVDLGFBQWFDLGFBQWEsSUFBSyxDQUFDeUYsUUFBUSxDQUFDQyxnQkFBZ0IsR0FDaEd6RixjQUNBLElBQUksQ0FBQ3dGLFFBQVEsQ0FBQ2xHLE1BQU07UUFDMUIsSUFBSWdILGlCQUFpQixDQUFDLEdBQUc7WUFDckIsSUFBSSxDQUFDckcsS0FBSyxHQUFHLElBQUksQ0FBQ29HLFVBQVUsQ0FBQ3BHLEtBQUs7WUFDbEMsT0FBT3FHO1FBQ1g7UUFDQSxJQUFJLENBQUNxQixVQUFVLENBQUMsSUFBSSxDQUFDdEIsVUFBVSxDQUFDcEUsWUFBWTtRQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDZ0MsT0FBTyxDQUFDaEUsS0FBSyxDQUFDWCxNQUFNLEVBQzFCLElBQUksQ0FBQ3lELFdBQVcsSUFBSSxJQUFJLENBQUNrQixPQUFPLENBQUNsQixXQUFXO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUN5QyxRQUFRLENBQUN2RixLQUFLLENBQUNYLE1BQU0sRUFDM0IsSUFBSSxDQUFDeUQsV0FBVyxJQUFJLElBQUksQ0FBQ3lDLFFBQVEsQ0FBQ3pDLFdBQVc7UUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQ3NELFVBQVUsQ0FBQ3BHLEtBQUssQ0FBQ1gsTUFBTSxFQUM3QixJQUFJLENBQUN5RCxXQUFXLElBQUksSUFBSSxDQUFDc0QsVUFBVSxDQUFDdEQsV0FBVztRQUNuRCxPQUFPdUQ7SUFDWDtJQUNBUyxrQkFBa0I7UUFDZCxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUM1RyxXQUFXLENBQUNRLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDMEYsVUFBVSxDQUFDbEUsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNsRTtBQUNKO0FBQ0FtRixnQkFBZ0IzRyxJQUFJLEdBQUc7QUFFdkIsTUFBTWlILGlDQUFpQ2hHLFNBQVM2QjtJQUM1Q3RELFlBQVksRUFBRW9DLFlBQVksSUFBSSxFQUFFLEdBQUc0RCxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDbEQsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQzVELFNBQVMsR0FBR0E7SUFDckI7QUFDSjtBQUNBcUYseUJBQXlCakgsSUFBSSxHQUFHO0FBRWhDLElBQUlrSDtBQUNKLE1BQU1DLGtCQUFrQi9CO0lBQ3BCNUYsWUFBWWdHLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQSxZQUFZeUI7UUFDbEIsSUFBSSxDQUFDM0QsT0FBTyxDQUFDSyxhQUFhLEdBQUc7SUFDakM7QUFDSjtBQUNBdUQsT0FBT0M7QUFDTjtJQUNHaEMsVUFBVWdDLFNBQVMsR0FBR0Q7QUFDMUI7QUFDQUMsVUFBVW5ILElBQUksR0FBRztBQUVqQixTQUFTb0gsZ0JBQWdCQyxXQUFXLEVBQUVDLE9BQU87SUFDekMsSUFBSUQsdUJBQXVCQyxTQUFTO1FBQ2hDLE9BQU9EO0lBQ1g7SUFDQSxNQUFNRSxZQUFZLElBQUlEO0lBQ3RCQyxVQUFVakUsT0FBTyxHQUFHK0QsWUFBWS9ELE9BQU87SUFDdkNpRSxVQUFVMUMsUUFBUSxHQUFHd0MsWUFBWXhDLFFBQVE7SUFDekMwQyxVQUFVcEYsUUFBUSxHQUFHa0YsWUFBWWxGLFFBQVE7SUFDekNvRixVQUFVMUUscUJBQXFCLEdBQUd3RSxZQUFZeEUscUJBQXFCO0lBQ25FLE9BQU8wRTtBQUNYO0FBQ0EsU0FBU0MsYUFBYXJJLFdBQVcsRUFBRUMsY0FBYyxDQUFDLEVBQUVDLGNBQWNGLFlBQVlSLE1BQU07SUFDaEYsTUFBTThJLGlCQUFpQnJJO0lBQ3ZCLElBQUlzSSxlQUFlLElBQUl0QyxVQUFVLENBQUMsR0FBR3RDO0lBQ3JDLE1BQU01RCxZQUFZLElBQUl3RDtJQUN0QixJQUFJLENBQUN6RCxrQkFBa0JDLFdBQVdDLGFBQWFDLGFBQWFDLGNBQWM7UUFDdEVxSSxhQUFhcEksS0FBSyxHQUFHSixVQUFVSSxLQUFLO1FBQ3BDLE9BQU87WUFDSHFJLFFBQVEsQ0FBQztZQUNUQyxRQUFRRjtRQUNaO0lBQ0o7SUFDQSxNQUFNdEQsWUFBWWpGLFlBQVkrQyxRQUFRLENBQUM5QyxhQUFhQSxjQUFjQztJQUNsRSxJQUFJLENBQUMrRSxVQUFVekYsTUFBTSxFQUFFO1FBQ25CK0ksYUFBYXBJLEtBQUssR0FBRztRQUNyQixPQUFPO1lBQ0hxSSxRQUFRLENBQUM7WUFDVEMsUUFBUUY7UUFDWjtJQUNKO0lBQ0EsSUFBSS9CLGVBQWUrQixhQUFhcEUsT0FBTyxDQUFDdkIsT0FBTyxDQUFDNUMsYUFBYUMsYUFBYUM7SUFDMUUsSUFBSXFJLGFBQWFwRSxPQUFPLENBQUNuQixRQUFRLENBQUN4RCxNQUFNLEVBQUU7UUFDdEMrSSxhQUFhdkYsUUFBUSxDQUFDN0QsTUFBTSxDQUFDb0osYUFBYXBFLE9BQU8sQ0FBQ25CLFFBQVE7SUFDOUQ7SUFDQSxJQUFJd0QsaUJBQWlCLENBQUMsR0FBRztRQUNyQitCLGFBQWFwSSxLQUFLLEdBQUdvSSxhQUFhcEUsT0FBTyxDQUFDaEUsS0FBSztRQUMvQyxPQUFPO1lBQ0hxSSxRQUFRLENBQUM7WUFDVEMsUUFBUUY7UUFDWjtJQUNKO0lBQ0F0SSxjQUFjdUc7SUFDZHRHLGVBQWVxSSxhQUFhcEUsT0FBTyxDQUFDbEIsV0FBVztJQUMvQ3VELGVBQWUrQixhQUFhN0MsUUFBUSxDQUFDOUMsT0FBTyxDQUFDNUMsYUFBYUMsYUFBYUM7SUFDdkUsSUFBSXFJLGFBQWE3QyxRQUFRLENBQUMxQyxRQUFRLENBQUN4RCxNQUFNLEVBQUU7UUFDdkMrSSxhQUFhdkYsUUFBUSxDQUFDN0QsTUFBTSxDQUFDb0osYUFBYTdDLFFBQVEsQ0FBQzFDLFFBQVE7SUFDL0Q7SUFDQSxJQUFJd0QsaUJBQWlCLENBQUMsR0FBRztRQUNyQitCLGFBQWFwSSxLQUFLLEdBQUdvSSxhQUFhN0MsUUFBUSxDQUFDdkYsS0FBSztRQUNoRCxPQUFPO1lBQ0hxSSxRQUFRLENBQUM7WUFDVEMsUUFBUUY7UUFDWjtJQUNKO0lBQ0F0SSxjQUFjdUc7SUFDZHRHLGVBQWVxSSxhQUFhN0MsUUFBUSxDQUFDekMsV0FBVztJQUNoRCxJQUFJLENBQUNzRixhQUFhcEUsT0FBTyxDQUFDSyxhQUFhLElBQ2hDK0QsYUFBYTdDLFFBQVEsQ0FBQ0MsZ0JBQWdCLEVBQUU7UUFDM0M0QyxhQUFhcEksS0FBSyxHQUFHO1FBQ3JCLE9BQU87WUFDSHFJLFFBQVEsQ0FBQztZQUNUQyxRQUFRRjtRQUNaO0lBQ0o7SUFDQSxJQUFJRyxjQUFjekM7SUFDbEIsT0FBUXNDLGFBQWFwRSxPQUFPLENBQUNHLFFBQVE7UUFDakMsS0FBSztZQUNELElBQUksYUFBY0gsT0FBTyxDQUFDSSxTQUFTLElBQUksTUFDL0JnRSxhQUFhcEUsT0FBTyxDQUFDMUIsU0FBUyxLQUFLLE9BQVE7Z0JBQy9DOEYsYUFBYXBJLEtBQUssR0FBRztnQkFDckIsT0FBTztvQkFDSHFJLFFBQVEsQ0FBQztvQkFDVEMsUUFBUUY7Z0JBQ1o7WUFDSjtZQUNBLE9BQVFBLGFBQWFwRSxPQUFPLENBQUNJLFNBQVM7Z0JBQ2xDLEtBQUs7b0JBQ0QsSUFBSSxhQUFjSixPQUFPLENBQUNLLGFBQWEsSUFDL0IrRCxhQUFhN0MsUUFBUSxDQUFDbEcsTUFBTSxHQUFHLEdBQUk7d0JBQ3ZDK0ksYUFBYXBJLEtBQUssR0FBRzt3QkFDckIsT0FBTzs0QkFDSHFJLFFBQVEsQ0FBQzs0QkFDVEMsUUFBUUY7d0JBQ1o7b0JBQ0o7b0JBQ0FHLGNBQWMxQyxVQUFVMkMsWUFBWTtvQkFDcEM7Z0JBQ0osS0FBSztvQkFDREQsY0FBYzFDLFVBQVU0QyxPQUFPO29CQUMvQjtnQkFDSixLQUFLO29CQUNERixjQUFjMUMsVUFBVTZDLE9BQU87b0JBQy9CO2dCQUNKLEtBQUs7b0JBQ0RILGNBQWMxQyxVQUFVOEMsU0FBUztvQkFDakM7Z0JBQ0osS0FBSztvQkFDREosY0FBYzFDLFVBQVUrQyxXQUFXO29CQUNuQztnQkFDSixLQUFLO29CQUNETCxjQUFjMUMsVUFBVWdELElBQUk7b0JBQzVCO2dCQUNKLEtBQUs7b0JBQ0ROLGNBQWMxQyxVQUFVaUQsZ0JBQWdCO29CQUN4QztnQkFDSixLQUFLO29CQUNEUCxjQUFjMUMsVUFBVWtELFVBQVU7b0JBQ2xDO2dCQUNKLEtBQUs7b0JBQ0RSLGNBQWMxQyxVQUFVbUQsVUFBVTtvQkFDbEM7Z0JBQ0osS0FBSztvQkFDRFQsY0FBYzFDLFVBQVVvRCx3QkFBd0I7b0JBQ2hEO2dCQUNKLEtBQUs7b0JBQ0RWLGNBQWMxQyxVQUFVcUQsSUFBSTtvQkFDNUI7Z0JBQ0osS0FBSztvQkFDRGQsYUFBYXBJLEtBQUssR0FBRztvQkFDckIsT0FBTzt3QkFDSHFJLFFBQVEsQ0FBQzt3QkFDVEMsUUFBUUY7b0JBQ1o7Z0JBQ0osS0FBSztvQkFDREcsY0FBYzFDLFVBQVVzRCxRQUFRO29CQUNoQztnQkFDSixLQUFLO29CQUNEWixjQUFjMUMsVUFBVXVELEdBQUc7b0JBQzNCO2dCQUNKLEtBQUs7b0JBQ0RiLGNBQWMxQyxVQUFVd0QsYUFBYTtvQkFDckM7Z0JBQ0osS0FBSztvQkFDRGQsY0FBYzFDLFVBQVV5RCxlQUFlO29CQUN2QztnQkFDSixLQUFLO29CQUNEZixjQUFjMUMsVUFBVTBELGFBQWE7b0JBQ3JDO2dCQUNKLEtBQUs7b0JBQ0RoQixjQUFjMUMsVUFBVTJELGNBQWM7b0JBQ3RDO2dCQUNKLEtBQUs7b0JBQ0RqQixjQUFjMUMsVUFBVTRELFNBQVM7b0JBQ2pDO2dCQUNKLEtBQUs7b0JBQ0RsQixjQUFjMUMsVUFBVTZELE9BQU87b0JBQy9CO2dCQUNKLEtBQUs7b0JBQ0RuQixjQUFjMUMsVUFBVThELGVBQWU7b0JBQ3ZDO2dCQUNKLEtBQUs7b0JBQ0RwQixjQUFjMUMsVUFBVStELGFBQWE7b0JBQ3JDO2dCQUNKLEtBQUs7b0JBQ0RyQixjQUFjMUMsVUFBVWdFLGFBQWE7b0JBQ3JDO2dCQUNKLEtBQUs7b0JBQ0R0QixjQUFjMUMsVUFBVWlFLGFBQWE7b0JBQ3JDO2dCQUNKLEtBQUs7b0JBQ0R2QixjQUFjMUMsVUFBVWtFLGVBQWU7b0JBQ3ZDO2dCQUNKLEtBQUs7b0JBQ0R4QixjQUFjMUMsVUFBVW1FLGVBQWU7b0JBQ3ZDO2dCQUNKLEtBQUs7b0JBQ0R6QixjQUFjMUMsVUFBVW9FLFNBQVM7b0JBQ2pDO2dCQUNKLEtBQUs7b0JBQ0QxQixjQUFjMUMsVUFBVXFFLElBQUk7b0JBQzVCO2dCQUNKLEtBQUs7b0JBQ0QzQixjQUFjMUMsVUFBVXNFLFNBQVM7b0JBQ2pDO2dCQUNKLEtBQUs7b0JBQ0Q1QixjQUFjMUMsVUFBVXVFLFFBQVE7b0JBQ2hDO2dCQUNKLEtBQUs7b0JBQ0Q3QixjQUFjMUMsVUFBVXdFLFFBQVE7b0JBQ2hDO2dCQUNKO29CQUFTO3dCQUNMLE1BQU1wQyxZQUFZRyxhQUFhcEUsT0FBTyxDQUFDSyxhQUFhLEdBQzlDLElBQUl3QixVQUFVdUIsV0FBVyxLQUN6QixJQUFJdkIsVUFBVWdDLFNBQVM7d0JBQzdCSSxVQUFVakUsT0FBTyxHQUFHb0UsYUFBYXBFLE9BQU87d0JBQ3hDaUUsVUFBVTFDLFFBQVEsR0FBRzZDLGFBQWE3QyxRQUFRO3dCQUMxQzBDLFVBQVVwRixRQUFRLEdBQUd1RixhQUFhdkYsUUFBUTt3QkFDMUN1RixlQUFlSDtvQkFDbkI7WUFDSjtZQUNBO1FBQ0osS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0w7WUFBUztnQkFDTE0sY0FBY0gsYUFBYXBFLE9BQU8sQ0FBQ0ssYUFBYSxHQUMxQ3dCLFVBQVV1QixXQUFXLEdBQ3JCdkIsVUFBVWdDLFNBQVM7WUFDN0I7SUFDSjtJQUNBTyxlQUFlTixnQkFBZ0JNLGNBQWNHO0lBQzdDbEMsZUFBZStCLGFBQWEzRixPQUFPLENBQUM1QyxhQUFhQyxhQUFhc0ksYUFBYTdDLFFBQVEsQ0FBQ0MsZ0JBQWdCLEdBQUd6RixjQUFjcUksYUFBYTdDLFFBQVEsQ0FBQ2xHLE1BQU07SUFDakorSSxhQUFhN0UscUJBQXFCLEdBQUcxRCxZQUFZK0MsUUFBUSxDQUFDdUYsZ0JBQWdCQSxpQkFBaUJDLGFBQWF0RixXQUFXO0lBQ25ILE9BQU87UUFDSHVGLFFBQVFoQztRQUNSaUMsUUFBUUY7SUFDWjtBQUNKO0FBQ0EsU0FBUzNGLFFBQVE1QyxXQUFXO0lBQ3hCLElBQUksQ0FBQ0EsWUFBWU4sVUFBVSxFQUFFO1FBQ3pCLE1BQU0rSSxTQUFTLElBQUl4QyxVQUFVLENBQUMsR0FBR3RDO1FBQ2pDOEUsT0FBT3RJLEtBQUssR0FBRztRQUNmLE9BQU87WUFDSHFJLFFBQVEsQ0FBQztZQUNUQztRQUNKO0lBQ0o7SUFDQSxPQUFPSixhQUFhdkoscUJBQXFCNEQscUJBQXFCLENBQUNDLFlBQVksQ0FBQzNDLGFBQWFvQyxLQUFLLElBQUksR0FBR3BDLFlBQVlOLFVBQVU7QUFDL0g7QUFFQSxTQUFTK0ssU0FBU0MsZ0JBQWdCLEVBQUVsTCxNQUFNO0lBQ3RDLElBQUlrTCxrQkFBa0I7UUFDbEIsT0FBTztJQUNYO0lBQ0EsT0FBT2xMO0FBQ1g7QUFDQSxNQUFNbUwsbUNBQW1DaEg7SUFDckN0RCxZQUFZLEVBQUVnQyxRQUFRLEVBQUUsRUFBRXNELG1CQUFtQixLQUFLLEVBQUUsR0FBR1UsWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3RFLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNoRSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDc0QsZ0JBQWdCLEdBQUdBO0lBQzVCO0lBQ0EvQyxRQUFRNUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxNQUFNMkMsT0FBTy9ELHFCQUFxQjRELHFCQUFxQixDQUFDQyxZQUFZLENBQUMzQztRQUNyRSxJQUFJLENBQUNGLGtCQUFrQixJQUFJLEVBQUUrQyxNQUFNNUMsYUFBYUMsY0FBYztZQUMxRCxPQUFPLENBQUM7UUFDWjtRQUNBLElBQUksQ0FBQ3dELHFCQUFxQixHQUFHYixLQUFLRSxRQUFRLENBQUM5QyxhQUFhQSxjQUFjQztRQUN0RSxJQUFJLElBQUksQ0FBQ3dELHFCQUFxQixDQUFDbEUsTUFBTSxLQUFLLEdBQUc7WUFDekMsSUFBSSxDQUFDd0QsUUFBUSxDQUFDdkMsSUFBSSxDQUFDO1lBQ25CLE9BQU9SO1FBQ1g7UUFDQSxJQUFJMkssZ0JBQWdCM0s7UUFDcEIsTUFBT3dLLFNBQVMsSUFBSSxDQUFDOUUsZ0JBQWdCLEVBQUV6RixlQUFlLEVBQUc7WUFDckQsTUFBTXFJLGVBQWVGLGFBQWF4RixNQUFNK0gsZUFBZTFLO1lBQ3ZELElBQUlxSSxhQUFhQyxNQUFNLEtBQUssQ0FBQyxHQUFHO2dCQUM1QixJQUFJLENBQUNySSxLQUFLLEdBQUdvSSxhQUFhRSxNQUFNLENBQUN0SSxLQUFLO2dCQUN0QyxJQUFJLENBQUM2QyxRQUFRLENBQUM3RCxNQUFNLENBQUNvSixhQUFhRSxNQUFNLENBQUN6RixRQUFRO2dCQUNqRCxPQUFPLENBQUM7WUFDWjtZQUNBNEgsZ0JBQWdCckMsYUFBYUMsTUFBTTtZQUNuQyxJQUFJLENBQUN2RixXQUFXLElBQUlzRixhQUFhRSxNQUFNLENBQUN4RixXQUFXO1lBQ25EL0MsZUFBZXFJLGFBQWFFLE1BQU0sQ0FBQ3hGLFdBQVc7WUFDOUMsSUFBSSxDQUFDWixLQUFLLENBQUM1QixJQUFJLENBQUM4SCxhQUFhRSxNQUFNO1lBQ25DLElBQUksSUFBSSxDQUFDOUMsZ0JBQWdCLElBQUk0QyxhQUFhRSxNQUFNLENBQUNwSSxXQUFXLENBQUNRLElBQUksS0FBS2MscUJBQXFCO2dCQUN2RjtZQUNKO1FBQ0o7UUFDQSxJQUFJLElBQUksQ0FBQ2dFLGdCQUFnQixFQUFFO1lBQ3ZCLElBQUksSUFBSSxDQUFDdEQsS0FBSyxDQUFDLElBQUksQ0FBQ0EsS0FBSyxDQUFDN0MsTUFBTSxHQUFHLEVBQUUsQ0FBQ2EsV0FBVyxDQUFDUSxJQUFJLEtBQUtjLHFCQUFxQjtnQkFDNUUsSUFBSSxDQUFDVSxLQUFLLENBQUN3SSxHQUFHO1lBQ2xCLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDN0gsUUFBUSxDQUFDdkMsSUFBSSxDQUFDO1lBQ3ZCO1FBQ0o7UUFDQSxPQUFPbUs7SUFDWDtJQUNBMUgsTUFBTUMsUUFBUSxFQUFFc0QsTUFBTSxFQUFFO1FBQ3BCLE1BQU14QyxVQUFVd0MsVUFBVSxJQUFJckc7UUFDOUIsSUFBSyxJQUFJYixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDOEMsS0FBSyxDQUFDN0MsTUFBTSxFQUFFRCxJQUFLO1lBQ3hDLElBQUksQ0FBQzhDLEtBQUssQ0FBQzlDLEVBQUUsQ0FBQzJELEtBQUssQ0FBQ0MsVUFBVWM7UUFDbEM7UUFDQSxJQUFJLENBQUN3QyxRQUFRO1lBQ1QsT0FBT3hDLFFBQVF2RCxLQUFLO1FBQ3hCO1FBQ0EsT0FBT2M7SUFDWDtJQUNBNEIsU0FBUztRQUNMLE1BQU0wRCxTQUFTO1lBQ1gsR0FBRyxLQUFLLENBQUMxRCxRQUFRO1lBQ2pCdUMsa0JBQWtCLElBQUksQ0FBQ0EsZ0JBQWdCO1lBQ3ZDdEQsT0FBTyxFQUFFO1FBQ2I7UUFDQSxLQUFLLE1BQU1BLFNBQVMsSUFBSSxDQUFDQSxLQUFLLENBQUU7WUFDNUJ5RSxPQUFPekUsS0FBSyxDQUFDNUIsSUFBSSxDQUFDNEIsTUFBTWUsTUFBTTtRQUNsQztRQUNBLE9BQU8wRDtJQUNYO0FBQ0o7QUFDQTZELDJCQUEyQjlKLElBQUksR0FBRztBQUVsQyxJQUFJaUs7QUFDSixNQUFNdkQsb0JBQW9CdEI7SUFDdEI1RixZQUFZZ0csYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBLFlBQVlzRTtRQUNsQixJQUFJLENBQUN4RyxPQUFPLENBQUNLLGFBQWEsR0FBRztJQUNqQztJQUNBNUIsUUFBUTVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUU7UUFDM0MsSUFBSSxDQUFDcUcsVUFBVSxDQUFDWixnQkFBZ0IsR0FBRyxJQUFJLENBQUNELFFBQVEsQ0FBQ0MsZ0JBQWdCO1FBQ2pFLE1BQU1hLGVBQWUsSUFBSSxDQUFDRCxVQUFVLENBQUMzRCxPQUFPLENBQUM1QyxhQUFhQyxhQUFhLElBQUssQ0FBQ3lGLFFBQVEsQ0FBQ0MsZ0JBQWdCLEdBQUl6RixjQUFjLElBQUksQ0FBQ3dGLFFBQVEsQ0FBQ2xHLE1BQU07UUFDNUksSUFBSWdILGlCQUFpQixDQUFDLEdBQUc7WUFDckIsSUFBSSxDQUFDckcsS0FBSyxHQUFHLElBQUksQ0FBQ29HLFVBQVUsQ0FBQ3BHLEtBQUs7WUFDbEMsT0FBT3FHO1FBQ1g7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDckMsT0FBTyxDQUFDaEUsS0FBSyxDQUFDWCxNQUFNLEVBQzFCLElBQUksQ0FBQ3lELFdBQVcsSUFBSSxJQUFJLENBQUNrQixPQUFPLENBQUNsQixXQUFXO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUN5QyxRQUFRLENBQUN2RixLQUFLLENBQUNYLE1BQU0sRUFDM0IsSUFBSSxDQUFDeUQsV0FBVyxJQUFJLElBQUksQ0FBQ3lDLFFBQVEsQ0FBQ3pDLFdBQVc7UUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQ3NELFVBQVUsQ0FBQ3BHLEtBQUssQ0FBQ1gsTUFBTSxFQUM3QixJQUFJLENBQUN5RCxXQUFXLElBQUksSUFBSSxDQUFDc0QsVUFBVSxDQUFDdEQsV0FBVztRQUNuRCxPQUFPdUQ7SUFDWDtJQUNBUyxrQkFBa0I7UUFDZCxNQUFNOEQsU0FBUyxFQUFFO1FBQ2pCLEtBQUssTUFBTTFJLFNBQVMsSUFBSSxDQUFDa0UsVUFBVSxDQUFDbEUsS0FBSyxDQUFFO1lBQ3ZDMEksT0FBT3RLLElBQUksQ0FBQzRCLE1BQU0wRSxRQUFRLENBQUMsU0FBU2lFLEtBQUssQ0FBQyxNQUFNQyxHQUFHLENBQUMsQ0FBQ0MsSUFBTSxDQUFDLEVBQUUsRUFBRUEsRUFBRSxDQUFDLEVBQUVDLElBQUksQ0FBQztRQUM5RTtRQUNBLE1BQU0zSCxZQUFZLElBQUksQ0FBQ1csT0FBTyxDQUFDRyxRQUFRLEtBQUssSUFDdEMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDSCxPQUFPLENBQUNJLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FDN0IsSUFBSSxDQUFDbEUsV0FBVyxDQUFDUSxJQUFJO1FBQzNCLE9BQU9rSyxPQUFPdkwsTUFBTSxHQUNkLENBQUMsRUFBRWdFLFVBQVUsSUFBSSxFQUFFdUgsT0FBT0ksSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUN0QyxDQUFDLEVBQUUzSCxVQUFVLEVBQUUsQ0FBQztJQUMxQjtBQUNKO0FBQ0FzSCxPQUFPdkQ7QUFDTjtJQUNHdkIsVUFBVXVCLFdBQVcsR0FBR3VEO0FBQzVCO0FBQ0F2RCxZQUFZMUcsSUFBSSxHQUFHO0FBRW5CLE1BQU11SyxvQ0FBb0N6SDtJQUN0Q2YsUUFBUTVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFNkQsWUFBWSxFQUFFO1FBQzVDLE9BQU83RDtJQUNYO0lBQ0FpRCxNQUFNYyxTQUFTLEVBQUU7UUFDYixPQUFPeEM7SUFDWDtBQUNKO0FBQ0E0Siw0QkFBNEJDLFFBQVEsR0FBRztBQUV2QyxJQUFJQztBQUNKLE1BQU0zQyxxQkFBcUIxQztJQUN2QjVGLFlBQVlnRyxhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0EsWUFBWStFO1FBQ2xCLElBQUksQ0FBQ2pILE9BQU8sQ0FBQ0csUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBK0csT0FBTzNDO0FBQ047SUFDRzNDLFVBQVUyQyxZQUFZLEdBQUcyQztBQUM3QjtBQUNBM0MsYUFBYTlILElBQUksR0FBR2M7QUFFcEIsSUFBSTRKO0FBQ0osTUFBTXZDLGFBQWEvQztJQUNmNUYsWUFBWWdHLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQSxZQUFZMUM7UUFDbEIsSUFBSSxDQUFDUSxPQUFPLENBQUNHLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNILE9BQU8sQ0FBQ0ksU0FBUyxHQUFHO0lBQzdCO0lBQ0EzQixRQUFRNUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxJQUFJLElBQUksQ0FBQ3dGLFFBQVEsQ0FBQ2xHLE1BQU0sR0FBRyxHQUN2QixJQUFJLENBQUN3RCxRQUFRLENBQUN2QyxJQUFJLENBQUM7UUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQzBELE9BQU8sQ0FBQ2hFLEtBQUssQ0FBQ1gsTUFBTSxFQUMxQixJQUFJLENBQUN5RCxXQUFXLElBQUksSUFBSSxDQUFDa0IsT0FBTyxDQUFDbEIsV0FBVztRQUNoRCxJQUFJLENBQUMsSUFBSSxDQUFDeUMsUUFBUSxDQUFDdkYsS0FBSyxDQUFDWCxNQUFNLEVBQzNCLElBQUksQ0FBQ3lELFdBQVcsSUFBSSxJQUFJLENBQUN5QyxRQUFRLENBQUN6QyxXQUFXO1FBQ2pELElBQUksQ0FBQ0EsV0FBVyxJQUFJL0M7UUFDcEIsSUFBSSxjQUFlQSxjQUFlRixZQUFZTixVQUFVLEVBQUU7WUFDdEQsSUFBSSxDQUFDUyxLQUFLLEdBQUc7WUFDYixPQUFPLENBQUM7UUFDWjtRQUNBLE9BQVFGLGNBQWNDO0lBQzFCO0lBQ0FnRCxNQUFNQyxRQUFRLEVBQUVzRCxNQUFNLEVBQUU7UUFDcEIsTUFBTVYsU0FBUyxJQUFJdEUsWUFBWTtRQUMvQixJQUFJLENBQUMwQixVQUFVO1lBQ1gsTUFBTXhELFVBQVUsSUFBSUMsV0FBV21HO1lBQy9CcEcsT0FBTyxDQUFDLEVBQUUsR0FBRztZQUNiQSxPQUFPLENBQUMsRUFBRSxHQUFHO1FBQ2pCO1FBQ0EsSUFBSThHLFFBQVE7WUFDUkEsT0FBT2xHLEtBQUssQ0FBQ3dGO1FBQ2pCO1FBQ0EsT0FBT0E7SUFDWDtJQUNBa0Isa0JBQWtCO1FBQ2QsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDNUcsV0FBVyxDQUFDUSxJQUFJLENBQUMsQ0FBQztJQUNyQztBQUNKO0FBQ0EwSyxPQUFPdkM7QUFDTjtJQUNHaEQsVUFBVWdELElBQUksR0FBR3VDO0FBQ3JCO0FBQ0F2QyxLQUFLbkksSUFBSSxHQUFHO0FBRVosTUFBTTJLLCtCQUErQjFKLFNBQVM2QjtJQUMxQyxJQUFJdEIsUUFBUTtRQUNSLEtBQUssTUFBTW9KLFNBQVMsSUFBSSxDQUFDdEosWUFBWSxDQUFFO1lBQ25DLElBQUlzSixRQUFRLEdBQUc7Z0JBQ1gsT0FBTztZQUNYO1FBQ0o7UUFDQSxPQUFPO0lBQ1g7SUFDQSxJQUFJcEosTUFBTUEsS0FBSyxFQUFFO1FBQ2IsSUFBSSxDQUFDRixZQUFZLENBQUMsRUFBRSxHQUFHRSxRQUFRLE9BQU87SUFDMUM7SUFDQWhDLFlBQVksRUFBRWdDLEtBQUssRUFBRSxHQUFHZ0UsWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3ZDLEtBQUssQ0FBQ0E7UUFDTixJQUFJQSxXQUFXbkUsUUFBUSxFQUFFO1lBQ3JCLElBQUksQ0FBQ0MsWUFBWSxHQUFHckQscUJBQXFCNEQscUJBQXFCLENBQUNDLFlBQVksQ0FBQzBELFdBQVduRSxRQUFRO1FBQ25HLE9BQ0s7WUFDRCxJQUFJLENBQUNDLFlBQVksR0FBRyxJQUFJdkMsV0FBVztRQUN2QztRQUNBLElBQUl5QyxPQUFPO1lBQ1AsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO1FBQ2pCO0lBQ0o7SUFDQU8sUUFBUTVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUU7UUFDM0MsTUFBTThFLFlBQVlsRyxxQkFBcUI0RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDM0M7UUFDMUUsSUFBSSxDQUFDRixrQkFBa0IsSUFBSSxFQUFFa0YsV0FBVy9FLGFBQWFDLGNBQWM7WUFDL0QsT0FBTyxDQUFDO1FBQ1o7UUFDQSxJQUFJLENBQUNpQyxZQUFZLEdBQUc2QyxVQUFVakMsUUFBUSxDQUFDOUMsYUFBYUEsY0FBY0M7UUFDbEUsSUFBSUEsY0FBYyxHQUNkLElBQUksQ0FBQzhDLFFBQVEsQ0FBQ3ZDLElBQUksQ0FBQztRQUN2QixJQUFJLENBQUNnQyxTQUFTLEdBQUc7UUFDakIxRCxtQkFBbUIyTSxZQUFZLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQ3pDLElBQUksQ0FBQzFJLFdBQVcsR0FBRy9DO1FBQ25CLE9BQVFELGNBQWNDO0lBQzFCO0lBQ0FnRCxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUNmLFlBQVksQ0FBQ0MsS0FBSztJQUNsQztJQUNBZ0IsU0FBUztRQUNMLE9BQU87WUFDSCxHQUFHLEtBQUssQ0FBQ0EsUUFBUTtZQUNqQmYsT0FBTyxJQUFJLENBQUNBLEtBQUs7UUFDckI7SUFDSjtBQUNKO0FBQ0FtSix1QkFBdUIzSyxJQUFJLEdBQUc7QUFFOUIsSUFBSStLO0FBQ0osTUFBTWhELGdCQUFnQjNDO0lBQ2xCd0IsV0FBVztRQUNQLE9BQU8sSUFBSSxDQUFDbEIsVUFBVSxDQUFDbEUsS0FBSztJQUNoQztJQUNBcUYsU0FBU3JGLEtBQUssRUFBRTtRQUNaLElBQUksQ0FBQ2tFLFVBQVUsQ0FBQ2xFLEtBQUssR0FBR0E7SUFDNUI7SUFDQWhDLFlBQVlnRyxhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0EsWUFBWW1GO1FBQ2xCLElBQUksQ0FBQ3JILE9BQU8sQ0FBQ0csUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLEdBQUc7SUFDN0I7SUFDQTBDLGtCQUFrQjtRQUNkLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQzVHLFdBQVcsQ0FBQ1EsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUM0RyxRQUFRLENBQUMsQ0FBQztJQUN4RDtBQUNKO0FBQ0FtRSxPQUFPaEQ7QUFDTjtJQUNHNUMsVUFBVTRDLE9BQU8sR0FBR2dEO0FBQ3hCO0FBQ0FoRCxRQUFRL0gsSUFBSSxHQUFHO0FBRWYsTUFBTWdMLG1DQUFtQy9KLFNBQVM2STtJQUM5Q3RLLFlBQVksRUFBRW1FLGdCQUFnQixLQUFLLEVBQUUsR0FBRzZCLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUN2RCxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDN0IsYUFBYSxHQUFHQTtJQUN6QjtJQUNBNUIsUUFBUTVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUU7UUFDM0MsSUFBSXNHLGVBQWU7UUFDbkIsSUFBSSxJQUFJLENBQUNoQyxhQUFhLEVBQUU7WUFDcEIsSUFBSSxDQUFDL0IsU0FBUyxHQUFHO1lBQ2pCK0QsZUFBZW1FLDJCQUEyQm1CLFNBQVMsQ0FBQ2xKLE9BQU8sQ0FBQytJLElBQUksQ0FBQyxJQUFJLEVBQUUzTCxhQUFhQyxhQUFhQztZQUNqRyxJQUFJc0csaUJBQWlCLENBQUMsR0FDbEIsT0FBT0E7WUFDWCxJQUFLLElBQUlqSCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDOEMsS0FBSyxDQUFDN0MsTUFBTSxFQUFFRCxJQUFLO2dCQUN4QyxNQUFNd00sbUJBQW1CLElBQUksQ0FBQzFKLEtBQUssQ0FBQzlDLEVBQUUsQ0FBQ2MsV0FBVyxDQUFDUSxJQUFJO2dCQUN2RCxJQUFJa0wscUJBQXFCcEsscUJBQXFCO29CQUMxQyxJQUFJLElBQUksQ0FBQ2dFLGdCQUFnQixFQUNyQjt5QkFDQzt3QkFDRCxJQUFJLENBQUN4RixLQUFLLEdBQUc7d0JBQ2IsT0FBTyxDQUFDO29CQUNaO2dCQUNKO2dCQUNBLElBQUk0TCxxQkFBcUJuSyxtQkFBbUI7b0JBQ3hDLElBQUksQ0FBQ3pCLEtBQUssR0FBRztvQkFDYixPQUFPLENBQUM7Z0JBQ1o7WUFDSjtRQUNKLE9BQ0s7WUFDRCxJQUFJLENBQUNzQyxTQUFTLEdBQUc7WUFDakIrRCxlQUFlLEtBQUssQ0FBQzVELFFBQVE1QyxhQUFhQyxhQUFhQztZQUN2RCxJQUFJLENBQUMrQyxXQUFXLEdBQUcvQztRQUN2QjtRQUNBLE9BQU9zRztJQUNYO0lBQ0F0RCxNQUFNQyxRQUFRLEVBQUVzRCxNQUFNLEVBQUU7UUFDcEIsSUFBSSxJQUFJLENBQUNqQyxhQUFhLEVBQ2xCLE9BQU9tRywyQkFBMkJtQixTQUFTLENBQUM1SSxLQUFLLENBQUN5SSxJQUFJLENBQUMsSUFBSSxFQUFFeEksVUFBVXNEO1FBQzNFLE9BQU90RCxXQUNELElBQUkxQixZQUFZLElBQUksQ0FBQ1UsWUFBWSxDQUFDekMsVUFBVSxJQUM1QyxJQUFJLENBQUN5QyxZQUFZLENBQUNDLEtBQUssR0FBRzNDLE1BQU07SUFDMUM7SUFDQTJELFNBQVM7UUFDTCxPQUFPO1lBQ0gsR0FBRyxLQUFLLENBQUNBLFFBQVE7WUFDakJvQixlQUFlLElBQUksQ0FBQ0EsYUFBYTtRQUNyQztJQUNKO0FBQ0o7QUFDQXFILDJCQUEyQmhMLElBQUksR0FBRztBQUVsQyxJQUFJbUw7QUFDSixNQUFNakQsb0JBQW9COUM7SUFDdEI1RixZQUFZLEVBQUU4RCxVQUFVLENBQUMsQ0FBQyxFQUFFdUIsV0FBVyxDQUFDLENBQUMsRUFBRSxHQUFHVyxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDN0QsSUFBSTlELElBQUk2QjtRQUNQN0IsQ0FBQUEsS0FBSzhELFdBQVc3QixhQUFhLE1BQU0sUUFBUWpDLE9BQU8sS0FBSyxJQUFJQSxLQUFNOEQsV0FBVzdCLGFBQWEsR0FBRyxDQUFDLENBQUUsRUFBQ0osS0FBS2lDLFdBQVdoRSxLQUFLLE1BQU0sUUFBUStCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzVFLE1BQU07UUFDdEssS0FBSyxDQUFDO1lBQ0YyRSxTQUFTO2dCQUNMSyxlQUFlNkIsV0FBVzdCLGFBQWE7Z0JBQ3ZDLEdBQUdMLE9BQU87WUFDZDtZQUNBdUIsVUFBVTtnQkFDTixHQUFHQSxRQUFRO2dCQUNYQyxrQkFBa0IsQ0FBQyxDQUFDVSxXQUFXVixnQkFBZ0I7WUFDbkQ7WUFDQSxHQUFHVSxVQUFVO1FBQ2pCLEdBQUd3RjtRQUNILElBQUksQ0FBQzFILE9BQU8sQ0FBQ0csUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLEdBQUc7SUFDN0I7SUFDQTNCLFFBQVE1QyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFO1FBQzNDLElBQUksQ0FBQ3FHLFVBQVUsQ0FBQy9CLGFBQWEsR0FBRyxJQUFJLENBQUNMLE9BQU8sQ0FBQ0ssYUFBYTtRQUMxRCxJQUFJLENBQUMrQixVQUFVLENBQUNaLGdCQUFnQixHQUFHLElBQUksQ0FBQ0QsUUFBUSxDQUFDQyxnQkFBZ0I7UUFDakUsSUFBSXpGLGdCQUFnQixHQUFHO1lBQ25CLElBQUksSUFBSSxDQUFDaUUsT0FBTyxDQUFDaEUsS0FBSyxDQUFDWCxNQUFNLEtBQUssR0FDOUIsSUFBSSxDQUFDeUQsV0FBVyxJQUFJLElBQUksQ0FBQ2tCLE9BQU8sQ0FBQ2xCLFdBQVc7WUFDaEQsSUFBSSxJQUFJLENBQUN5QyxRQUFRLENBQUN2RixLQUFLLENBQUNYLE1BQU0sS0FBSyxHQUMvQixJQUFJLENBQUN5RCxXQUFXLElBQUksSUFBSSxDQUFDeUMsUUFBUSxDQUFDekMsV0FBVztZQUNqRCxPQUFPaEQ7UUFDWDtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUNzRyxVQUFVLENBQUMvQixhQUFhLEVBQUU7WUFDaEMsTUFBTTNCLE9BQU83Qyx1QkFBdUJ5QixjQUFjLElBQUk3QixXQUFXSSxlQUFlQTtZQUNoRixNQUFNUSxNQUFNcUMsS0FBS0UsUUFBUSxDQUFDOUMsYUFBYUEsY0FBY0M7WUFDckQsSUFBSTtnQkFDQSxJQUFJTSxJQUFJZCxVQUFVLEVBQUU7b0JBQ2hCLE1BQU11TSxNQUFNNUQsYUFBYTdILEtBQUssR0FBR0EsSUFBSWQsVUFBVTtvQkFDL0MsSUFBSXVNLElBQUl6RCxNQUFNLEtBQUssQ0FBQyxLQUFLeUQsSUFBSXpELE1BQU0sS0FBS3RJLGFBQWE7d0JBQ2pELElBQUksQ0FBQ3FHLFVBQVUsQ0FBQ2xFLEtBQUssR0FBRzs0QkFBQzRKLElBQUl4RCxNQUFNO3lCQUFDO29CQUN4QztnQkFDSjtZQUNKLEVBQ0EsT0FBTSxDQUNOO1FBQ0o7UUFDQSxPQUFPLEtBQUssQ0FBQzdGLFFBQVE1QyxhQUFhQyxhQUFhQztJQUNuRDtJQUNBK0csa0JBQWtCO1FBQ2QsSUFBSSxJQUFJLENBQUNWLFVBQVUsQ0FBQy9CLGFBQWEsSUFBSyxJQUFJLENBQUMrQixVQUFVLENBQUNsRSxLQUFLLElBQUksSUFBSSxDQUFDa0UsVUFBVSxDQUFDbEUsS0FBSyxDQUFDN0MsTUFBTSxFQUFHO1lBQzFGLE9BQU8rSCxZQUFZdUUsU0FBUyxDQUFDN0UsZUFBZSxDQUFDMEUsSUFBSSxDQUFDLElBQUk7UUFDMUQ7UUFDQSxNQUFNekYsT0FBTyxJQUFJLENBQUM3RixXQUFXLENBQUNRLElBQUk7UUFDbEMsTUFBTXdCLFFBQVF2RCxxQkFBcUJ1RSxPQUFPLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUNpRCxVQUFVLENBQUNwRSxZQUFZO1FBQzdFLE9BQU8sQ0FBQyxFQUFFK0QsS0FBSyxHQUFHLEVBQUU3RCxNQUFNLENBQUM7SUFDL0I7SUFDQW9GLFdBQVc7UUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDdEQsT0FBTyxDQUFDSyxhQUFhLEVBQUU7WUFDN0IsT0FBTyxJQUFJLENBQUMrQixVQUFVLENBQUNwRSxZQUFZLENBQUNDLEtBQUssR0FBRzNDLE1BQU07UUFDdEQ7UUFDQSxNQUFNeU0sUUFBUSxFQUFFO1FBQ2hCLEtBQUssTUFBTUMsV0FBVyxJQUFJLENBQUM1RixVQUFVLENBQUNsRSxLQUFLLENBQUU7WUFDekMsSUFBSThKLG1CQUFtQkgsTUFBTTtnQkFDekJFLE1BQU16TCxJQUFJLENBQUMwTCxRQUFRNUYsVUFBVSxDQUFDcEUsWUFBWTtZQUM5QztRQUNKO1FBQ0EsT0FBT3JELHFCQUFxQjRELHFCQUFxQixDQUFDdkQsTUFBTSxDQUFDK007SUFDN0Q7QUFDSjtBQUNBRixPQUFPakQ7QUFDTjtJQUNHL0MsVUFBVStDLFdBQVcsR0FBR2lEO0FBQzVCO0FBQ0FqRCxZQUFZbEksSUFBSSxHQUFHZTtBQUVuQixNQUFNd0ssaUNBQWlDdEssU0FBUzZJO0lBQzVDdEssWUFBWSxFQUFFZ00sYUFBYSxDQUFDLEVBQUU3SCxnQkFBZ0IsS0FBSyxFQUFFLEdBQUc2QixZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDdkUsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ2dHLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDN0gsYUFBYSxHQUFHQTtRQUNyQixJQUFJLENBQUN2QixXQUFXLEdBQUcsSUFBSSxDQUFDZCxZQUFZLENBQUN6QyxVQUFVO0lBQ25EO0lBQ0FrRCxRQUFRNUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxJQUFJLENBQUNBLGFBQWE7WUFDZCxPQUFPRDtRQUNYO1FBQ0EsSUFBSXVHLGVBQWUsQ0FBQztRQUNwQixJQUFJLElBQUksQ0FBQ2hDLGFBQWEsRUFBRTtZQUNwQmdDLGVBQWVtRSwyQkFBMkJtQixTQUFTLENBQUNsSixPQUFPLENBQUMrSSxJQUFJLENBQUMsSUFBSSxFQUFFM0wsYUFBYUMsYUFBYUM7WUFDakcsSUFBSXNHLGlCQUFpQixDQUFDLEdBQ2xCLE9BQU9BO1lBQ1gsS0FBSyxNQUFNbkUsU0FBUyxJQUFJLENBQUNBLEtBQUssQ0FBRTtnQkFDNUIsTUFBTTBKLG1CQUFtQjFKLE1BQU1oQyxXQUFXLENBQUNRLElBQUk7Z0JBQy9DLElBQUlrTCxxQkFBcUJwSyxxQkFBcUI7b0JBQzFDLElBQUksSUFBSSxDQUFDZ0UsZ0JBQWdCLEVBQ3JCO3lCQUNDO3dCQUNELElBQUksQ0FBQ3hGLEtBQUssR0FBRzt3QkFDYixPQUFPLENBQUM7b0JBQ1o7Z0JBQ0o7Z0JBQ0EsSUFBSTRMLHFCQUFxQmxLLGlCQUFpQjtvQkFDdEMsSUFBSSxDQUFDMUIsS0FBSyxHQUFHO29CQUNiLE9BQU8sQ0FBQztnQkFDWjtnQkFDQSxNQUFNb0csYUFBYWxFLE1BQU1rRSxVQUFVO2dCQUNuQyxJQUFJLElBQUssQ0FBQzhGLFVBQVUsR0FBRyxLQUFPOUYsV0FBVzhGLFVBQVUsR0FBRyxHQUFJO29CQUN0RCxJQUFJLENBQUNsTSxLQUFLLEdBQUc7b0JBQ2IsT0FBTyxDQUFDO2dCQUNaO2dCQUNBLElBQUksQ0FBQ2tNLFVBQVUsR0FBRzlGLFdBQVc4RixVQUFVO1lBQzNDO1lBQ0EsT0FBTzdGO1FBQ1g7UUFDQSxNQUFNeEIsWUFBWWxHLHFCQUFxQjRELHFCQUFxQixDQUFDQyxZQUFZLENBQUMzQztRQUMxRSxJQUFJLENBQUNGLGtCQUFrQixJQUFJLEVBQUVrRixXQUFXL0UsYUFBYUMsY0FBYztZQUMvRCxPQUFPLENBQUM7UUFDWjtRQUNBLE1BQU0rRSxZQUFZRCxVQUFVakMsUUFBUSxDQUFDOUMsYUFBYUEsY0FBY0M7UUFDaEUsSUFBSSxDQUFDbU0sVUFBVSxHQUFHcEgsU0FBUyxDQUFDLEVBQUU7UUFDOUIsSUFBSSxJQUFJLENBQUNvSCxVQUFVLEdBQUcsR0FBRztZQUNyQixJQUFJLENBQUNsTSxLQUFLLEdBQUc7WUFDYixPQUFPLENBQUM7UUFDWjtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUNrTSxVQUFVLEVBQUU7WUFDbEIsTUFBTTdMLE1BQU15RSxVQUFVbEMsUUFBUSxDQUFDO1lBQy9CLElBQUk7Z0JBQ0EsSUFBSXZDLElBQUlkLFVBQVUsRUFBRTtvQkFDaEIsTUFBTXVNLE1BQU01RCxhQUFhN0gsS0FBSyxHQUFHQSxJQUFJZCxVQUFVO29CQUMvQyxJQUFJdU0sSUFBSXpELE1BQU0sS0FBSyxDQUFDLEtBQUt5RCxJQUFJekQsTUFBTSxLQUFNdEksY0FBYyxHQUFJO3dCQUN2RCxJQUFJLENBQUNtQyxLQUFLLEdBQUc7NEJBQUM0SixJQUFJeEQsTUFBTTt5QkFBQztvQkFDN0I7Z0JBQ0o7WUFDSixFQUNBLE9BQU0sQ0FDTjtRQUNKO1FBQ0EsSUFBSSxDQUFDdEcsWUFBWSxHQUFHOEMsVUFBVWxDLFFBQVEsQ0FBQztRQUN2QyxJQUFJLENBQUNFLFdBQVcsR0FBR2dDLFVBQVV6RixNQUFNO1FBQ25DLE9BQVFTLGNBQWNDO0lBQzFCO0lBQ0FnRCxNQUFNQyxRQUFRLEVBQUVzRCxNQUFNLEVBQUU7UUFDcEIsSUFBSSxJQUFJLENBQUNqQyxhQUFhLEVBQUU7WUFDcEIsT0FBT21HLDJCQUEyQm1CLFNBQVMsQ0FBQzVJLEtBQUssQ0FBQ3lJLElBQUksQ0FBQyxJQUFJLEVBQUV4SSxVQUFVc0Q7UUFDM0U7UUFDQSxJQUFJdEQsVUFBVTtZQUNWLE9BQU8sSUFBSTFCLFlBQVksSUFBSSxDQUFDVSxZQUFZLENBQUN6QyxVQUFVLEdBQUc7UUFDMUQ7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDeUMsWUFBWSxDQUFDekMsVUFBVSxFQUFFO1lBQy9CLE9BQU84QjtRQUNYO1FBQ0EsTUFBTTdCLFVBQVUsSUFBSUMsV0FBVyxJQUFJLENBQUN1QyxZQUFZLENBQUMzQyxNQUFNLEdBQUc7UUFDMURHLE9BQU8sQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDME0sVUFBVTtRQUM1QjFNLFFBQVFFLEdBQUcsQ0FBQyxJQUFJLENBQUNzQyxZQUFZLEVBQUU7UUFDL0IsT0FBT3hDLFFBQVFGLE1BQU07SUFDekI7SUFDQTJELFNBQVM7UUFDTCxPQUFPO1lBQ0gsR0FBRyxLQUFLLENBQUNBLFFBQVE7WUFDakJpSixZQUFZLElBQUksQ0FBQ0EsVUFBVTtZQUMzQjdILGVBQWUsSUFBSSxDQUFDQSxhQUFhO1FBQ3JDO0lBQ0o7QUFDSjtBQUNBNEgseUJBQXlCdkwsSUFBSSxHQUFHO0FBRWhDLElBQUl5TDtBQUNKLE1BQU14RCxrQkFBa0I3QztJQUNwQjVGLFlBQVksRUFBRThELFVBQVUsQ0FBQyxDQUFDLEVBQUV1QixXQUFXLENBQUMsQ0FBQyxFQUFFLEdBQUdXLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUM3RCxJQUFJOUQsSUFBSTZCO1FBQ1A3QixDQUFBQSxLQUFLOEQsV0FBVzdCLGFBQWEsTUFBTSxRQUFRakMsT0FBTyxLQUFLLElBQUlBLEtBQU04RCxXQUFXN0IsYUFBYSxHQUFHLENBQUMsQ0FBRSxFQUFDSixLQUFLaUMsV0FBV2hFLEtBQUssTUFBTSxRQUFRK0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNUUsTUFBTTtRQUN0SyxLQUFLLENBQUM7WUFDRjJFLFNBQVM7Z0JBQ0xLLGVBQWU2QixXQUFXN0IsYUFBYTtnQkFDdkMsR0FBR0wsT0FBTztZQUNkO1lBQ0F1QixVQUFVO2dCQUNOLEdBQUdBLFFBQVE7Z0JBQ1hDLGtCQUFrQixDQUFDLENBQUNVLFdBQVdWLGdCQUFnQjtZQUNuRDtZQUNBLEdBQUdVLFVBQVU7UUFDakIsR0FBRytGO1FBQ0gsSUFBSSxDQUFDakksT0FBTyxDQUFDRyxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSCxPQUFPLENBQUNJLFNBQVMsR0FBRztJQUM3QjtJQUNBM0IsUUFBUTVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUU7UUFDM0MsSUFBSSxDQUFDcUcsVUFBVSxDQUFDL0IsYUFBYSxHQUFHLElBQUksQ0FBQ0wsT0FBTyxDQUFDSyxhQUFhO1FBQzFELElBQUksQ0FBQytCLFVBQVUsQ0FBQ1osZ0JBQWdCLEdBQUcsSUFBSSxDQUFDRCxRQUFRLENBQUNDLGdCQUFnQjtRQUNqRSxPQUFPLEtBQUssQ0FBQy9DLFFBQVE1QyxhQUFhQyxhQUFhQztJQUNuRDtJQUNBK0csa0JBQWtCO1FBQ2QsSUFBSSxJQUFJLENBQUNWLFVBQVUsQ0FBQy9CLGFBQWEsSUFBSyxJQUFJLENBQUMrQixVQUFVLENBQUNsRSxLQUFLLElBQUksSUFBSSxDQUFDa0UsVUFBVSxDQUFDbEUsS0FBSyxDQUFDN0MsTUFBTSxFQUFHO1lBQzFGLE9BQU8rSCxZQUFZdUUsU0FBUyxDQUFDN0UsZUFBZSxDQUFDMEUsSUFBSSxDQUFDLElBQUk7UUFDMUQsT0FDSztZQUNELE1BQU1ZLE9BQU8sRUFBRTtZQUNmLE1BQU1ySyxXQUFXLElBQUksQ0FBQ3FFLFVBQVUsQ0FBQ3BFLFlBQVk7WUFDN0MsS0FBSyxNQUFNcUssUUFBUXRLLFNBQVU7Z0JBQ3pCcUssS0FBSzlMLElBQUksQ0FBQytMLEtBQUt6RixRQUFRLENBQUMsR0FBRzBGLFFBQVEsQ0FBQyxHQUFHO1lBQzNDO1lBQ0EsTUFBTUMsVUFBVUgsS0FBS3BCLElBQUksQ0FBQztZQUMxQixNQUFNakYsT0FBTyxJQUFJLENBQUM3RixXQUFXLENBQUNRLElBQUk7WUFDbEMsTUFBTXdCLFFBQVFxSyxRQUFRQyxTQUFTLENBQUMsR0FBR0QsUUFBUWxOLE1BQU0sR0FBRyxJQUFJLENBQUMrRyxVQUFVLENBQUM4RixVQUFVO1lBQzlFLE9BQU8sQ0FBQyxFQUFFbkcsS0FBSyxHQUFHLEVBQUU3RCxNQUFNLENBQUM7UUFDL0I7SUFDSjtBQUNKO0FBQ0FpSyxPQUFPeEQ7QUFDTjtJQUNHOUMsVUFBVThDLFNBQVMsR0FBR3dEO0FBQzFCO0FBQ0F4RCxVQUFVakksSUFBSSxHQUFHZ0I7QUFFakIsSUFBSStLO0FBQ0osU0FBU0MsUUFBUUMsS0FBSyxFQUFFQyxNQUFNO0lBQzFCLE1BQU1DLElBQUksSUFBSXBOLFdBQVc7UUFBQztLQUFFO0lBQzVCLE1BQU1xTixZQUFZLElBQUlyTixXQUFXa047SUFDakMsTUFBTUksYUFBYSxJQUFJdE4sV0FBV21OO0lBQ2xDLElBQUlJLGdCQUFnQkYsVUFBVTdLLEtBQUssQ0FBQztJQUNwQyxNQUFNZ0wsc0JBQXNCRCxjQUFjM04sTUFBTSxHQUFHO0lBQ25ELE1BQU02TixpQkFBaUJILFdBQVc5SyxLQUFLLENBQUM7SUFDeEMsTUFBTWtMLHVCQUF1QkQsZUFBZTdOLE1BQU0sR0FBRztJQUNyRCxJQUFJNkMsUUFBUTtJQUNaLE1BQU1rTCxNQUFNLHVCQUF3Qkgsc0JBQXVCQSxzQkFBc0JFO0lBQ2pGLElBQUlFLFVBQVU7SUFDZCxJQUFLLElBQUlqTyxJQUFJZ08sS0FBS2hPLEtBQUssR0FBR0EsS0FBS2lPLFVBQVc7UUFDdEMsT0FBUTtZQUNKLEtBQU1BLFVBQVVILGVBQWU3TixNQUFNO2dCQUNqQzZDLFFBQVE4SyxhQUFhLENBQUNDLHNCQUFzQkksUUFBUSxHQUFHSCxjQUFjLENBQUNDLHVCQUF1QkUsUUFBUSxHQUFHUixDQUFDLENBQUMsRUFBRTtnQkFDNUc7WUFDSjtnQkFDSTNLLFFBQVE4SyxhQUFhLENBQUNDLHNCQUFzQkksUUFBUSxHQUFHUixDQUFDLENBQUMsRUFBRTtRQUNuRTtRQUNBQSxDQUFDLENBQUMsRUFBRSxHQUFHM0ssUUFBUTtRQUNmLE9BQVE7WUFDSixLQUFNbUwsV0FBV0wsY0FBYzNOLE1BQU07Z0JBQ2pDMk4sZ0JBQWdCcE8sbUJBQW1CME8sY0FBYyxDQUFDLElBQUk3TixXQUFXO29CQUFDeUMsUUFBUTtpQkFBRyxHQUFHOEs7Z0JBQ2hGO1lBQ0o7Z0JBQ0lBLGFBQWEsQ0FBQ0Msc0JBQXNCSSxRQUFRLEdBQUduTCxRQUFRO1FBQy9EO0lBQ0o7SUFDQSxJQUFJMkssQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUNQRyxnQkFBZ0JwTyxtQkFBbUIwTyxjQUFjLENBQUNULEdBQUdHO0lBQ3pELE9BQU9BO0FBQ1g7QUFDQSxTQUFTTyxPQUFPelAsQ0FBQztJQUNiLElBQUlBLEtBQUswQyxRQUFRbkIsTUFBTSxFQUFFO1FBQ3JCLElBQUssSUFBSW1PLElBQUloTixRQUFRbkIsTUFBTSxFQUFFbU8sS0FBSzFQLEdBQUcwUCxJQUFLO1lBQ3RDLE1BQU1YLElBQUksSUFBSXBOLFdBQVc7Z0JBQUM7YUFBRTtZQUM1QixJQUFJZ08sU0FBUyxPQUFRLENBQUNELElBQUksRUFBRSxDQUFFdkwsS0FBSyxDQUFDO1lBQ3BDLElBQUssSUFBSTdDLElBQUtxTyxPQUFPcE8sTUFBTSxHQUFHLEdBQUlELEtBQUssR0FBR0EsSUFBSztnQkFDM0MsTUFBTXNPLFdBQVcsSUFBSWpPLFdBQVc7b0JBQUVnTyxDQUFBQSxNQUFNLENBQUNyTyxFQUFFLElBQUksS0FBS3lOLENBQUMsQ0FBQyxFQUFFO2lCQUFDO2dCQUN6REEsQ0FBQyxDQUFDLEVBQUUsR0FBR2EsUUFBUSxDQUFDLEVBQUUsR0FBRztnQkFDckJELE1BQU0sQ0FBQ3JPLEVBQUUsR0FBR3NPLFFBQVEsQ0FBQyxFQUFFLEdBQUc7WUFDOUI7WUFDQSxJQUFJYixDQUFDLENBQUMsRUFBRSxHQUFHLEdBQ1BZLFNBQVM3TyxtQkFBbUIwTyxjQUFjLENBQUNULEdBQUdZO1lBQ2xEak4sUUFBUUYsSUFBSSxDQUFDbU47UUFDakI7SUFDSjtJQUNBLE9BQU9qTixPQUFPLENBQUMxQyxFQUFFO0FBQ3JCO0FBQ0EsU0FBUzZQLFFBQVFoQixLQUFLLEVBQUVDLE1BQU07SUFDMUIsSUFBSWdCLElBQUk7SUFDUixNQUFNZCxZQUFZLElBQUlyTixXQUFXa047SUFDakMsTUFBTUksYUFBYSxJQUFJdE4sV0FBV21OO0lBQ2xDLE1BQU1JLGdCQUFnQkYsVUFBVTdLLEtBQUssQ0FBQztJQUN0QyxNQUFNZ0wsc0JBQXNCRCxjQUFjM04sTUFBTSxHQUFHO0lBQ25ELE1BQU02TixpQkFBaUJILFdBQVc5SyxLQUFLLENBQUM7SUFDeEMsTUFBTWtMLHVCQUF1QkQsZUFBZTdOLE1BQU0sR0FBRztJQUNyRCxJQUFJNkM7SUFDSixJQUFJbUwsVUFBVTtJQUNkLElBQUssSUFBSWpPLElBQUkrTixzQkFBc0IvTixLQUFLLEdBQUdBLEtBQUtpTyxVQUFXO1FBQ3ZEbkwsUUFBUThLLGFBQWEsQ0FBQ0Msc0JBQXNCSSxRQUFRLEdBQUdILGNBQWMsQ0FBQ0MsdUJBQXVCRSxRQUFRLEdBQUdPO1FBQ3hHLE9BQVE7WUFDSixLQUFNMUwsUUFBUTtnQkFDVjBMLElBQUk7Z0JBQ0paLGFBQWEsQ0FBQ0Msc0JBQXNCSSxRQUFRLEdBQUduTCxRQUFRO2dCQUN2RDtZQUNKO2dCQUNJMEwsSUFBSTtnQkFDSlosYUFBYSxDQUFDQyxzQkFBc0JJLFFBQVEsR0FBR25MO1FBQ3ZEO0lBQ0o7SUFDQSxJQUFJMEwsSUFBSSxHQUFHO1FBQ1AsSUFBSyxJQUFJeE8sSUFBSzZOLHNCQUFzQkUsdUJBQXVCLEdBQUkvTixLQUFLLEdBQUdBLEtBQUtpTyxVQUFXO1lBQ25GbkwsUUFBUThLLGFBQWEsQ0FBQ0Msc0JBQXNCSSxRQUFRLEdBQUdPO1lBQ3ZELElBQUkxTCxRQUFRLEdBQUc7Z0JBQ1gwTCxJQUFJO2dCQUNKWixhQUFhLENBQUNDLHNCQUFzQkksUUFBUSxHQUFHbkwsUUFBUTtZQUMzRCxPQUNLO2dCQUNEMEwsSUFBSTtnQkFDSlosYUFBYSxDQUFDQyxzQkFBc0JJLFFBQVEsR0FBR25MO2dCQUMvQztZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU84SyxjQUFjL0ssS0FBSztBQUM5QjtBQUNBLE1BQU00TCwrQkFBK0JsTSxTQUFTNkI7SUFDMUNzSyxjQUFjO1FBQ1YsSUFBSSxJQUFJLENBQUM5TCxZQUFZLENBQUMzQyxNQUFNLElBQUksR0FBRztZQUMvQixJQUFJLENBQUN3RCxRQUFRLENBQUN2QyxJQUFJLENBQUM7WUFDbkIsSUFBSSxDQUFDZ0MsU0FBUyxHQUFHO1lBQ2pCLElBQUksQ0FBQ3lMLFNBQVMsR0FBRztRQUNyQixPQUNLO1lBQ0QsSUFBSSxDQUFDekwsU0FBUyxHQUFHO1lBQ2pCLElBQUksSUFBSSxDQUFDTixZQUFZLENBQUMzQyxNQUFNLEdBQUcsR0FBRztnQkFDOUIsSUFBSSxDQUFDME8sU0FBUyxHQUFHblAsbUJBQW1CMk0sWUFBWSxDQUFDQyxJQUFJLENBQUMsSUFBSTtZQUM5RDtRQUNKO0lBQ0o7SUFDQXRMLFlBQVksRUFBRWdDLEtBQUssRUFBRSxHQUFHZ0UsWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3ZDLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUM2SCxTQUFTLEdBQUc7UUFDakIsSUFBSTdILFdBQVduRSxRQUFRLEVBQUU7WUFDckIsSUFBSSxDQUFDK0wsV0FBVztRQUNwQjtRQUNBLElBQUk1TCxVQUFVOEwsV0FBVztZQUNyQixJQUFJLENBQUNDLFFBQVEsR0FBRy9MO1FBQ3BCO0lBQ0o7SUFDQSxJQUFJK0wsU0FBU0MsQ0FBQyxFQUFFO1FBQ1osSUFBSSxDQUFDSCxTQUFTLEdBQUdHO1FBQ2pCLElBQUksQ0FBQzVMLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNOLFlBQVksR0FBRyxJQUFJdkMsV0FBV2IsbUJBQW1CdVAsWUFBWSxDQUFDRDtJQUN2RTtJQUNBLElBQUlELFdBQVc7UUFDWCxPQUFPLElBQUksQ0FBQ0YsU0FBUztJQUN6QjtJQUNBSyxRQUFRdk8sV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRXNPLGlCQUFpQixDQUFDLEVBQUU7UUFDL0QsTUFBTWhHLFNBQVMsSUFBSSxDQUFDNUYsT0FBTyxDQUFDNUMsYUFBYUMsYUFBYUM7UUFDdEQsSUFBSXNJLFdBQVcsQ0FBQyxHQUNaLE9BQU9BO1FBQ1gsTUFBTTNGLE9BQU8sSUFBSSxDQUFDVixZQUFZO1FBQzlCLElBQUksSUFBSyxDQUFDLEVBQUUsS0FBSyxRQUFVLENBQUNVLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBRyxNQUFPLEdBQUk7WUFDaEQsSUFBSSxDQUFDVixZQUFZLEdBQUdVLEtBQUtFLFFBQVEsQ0FBQztRQUN0QyxPQUNLO1lBQ0QsSUFBSXlMLG1CQUFtQixHQUFHO2dCQUN0QixJQUFJM0wsS0FBS3JELE1BQU0sR0FBR2dQLGdCQUFnQjtvQkFDOUIsSUFBSSxpQkFBa0IzTCxLQUFLckQsTUFBTSxHQUFJLEdBQ2pDZ1AsaUJBQWlCM0wsS0FBS3JELE1BQU0sR0FBRztvQkFDbkMsSUFBSSxDQUFDMkMsWUFBWSxHQUFHVSxLQUFLRSxRQUFRLENBQUN5TCxpQkFBaUIzTCxLQUFLckQsTUFBTTtnQkFDbEU7WUFDSjtRQUNKO1FBQ0EsT0FBT2dKO0lBQ1g7SUFDQWlHLE1BQU10TCxXQUFXLEtBQUssRUFBRTtRQUNwQixNQUFNTixPQUFPLElBQUksQ0FBQ1YsWUFBWTtRQUM5QixPQUFRO1lBQ0osS0FBTSxDQUFDVSxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUcsTUFBTztnQkFDdkI7b0JBQ0ksTUFBTTZMLGNBQWMsSUFBSTlPLFdBQVcsSUFBSSxDQUFDdUMsWUFBWSxDQUFDM0MsTUFBTSxHQUFHO29CQUM5RGtQLFdBQVcsQ0FBQyxFQUFFLEdBQUc7b0JBQ2pCQSxZQUFZN08sR0FBRyxDQUFDZ0QsTUFBTTtvQkFDdEIsSUFBSSxDQUFDVixZQUFZLEdBQUd1TTtnQkFDeEI7Z0JBQ0E7WUFDSixLQUFNLElBQUssQ0FBQyxFQUFFLEtBQUssUUFBVSxDQUFDN0wsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFHLE1BQU87Z0JBQzlDO29CQUNJLElBQUksQ0FBQ1YsWUFBWSxHQUFHLElBQUksQ0FBQ0EsWUFBWSxDQUFDWSxRQUFRLENBQUM7Z0JBQ25EO2dCQUNBO1FBQ1I7UUFDQSxPQUFPLElBQUksQ0FBQ0csS0FBSyxDQUFDQztJQUN0QjtJQUNBUCxRQUFRNUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxNQUFNc0csZUFBZSxLQUFLLENBQUM1RCxRQUFRNUMsYUFBYUMsYUFBYUM7UUFDN0QsSUFBSXNHLGlCQUFpQixDQUFDLEdBQUc7WUFDckIsT0FBT0E7UUFDWDtRQUNBLElBQUksQ0FBQ3lILFdBQVc7UUFDaEIsT0FBT3pIO0lBQ1g7SUFDQXRELE1BQU1DLFFBQVEsRUFBRTtRQUNaLE9BQU9BLFdBQ0QsSUFBSTFCLFlBQVksSUFBSSxDQUFDVSxZQUFZLENBQUMzQyxNQUFNLElBQ3hDLElBQUksQ0FBQzJDLFlBQVksQ0FBQ0MsS0FBSyxHQUFHM0MsTUFBTTtJQUMxQztJQUNBMkQsU0FBUztRQUNMLE9BQU87WUFDSCxHQUFHLEtBQUssQ0FBQ0EsUUFBUTtZQUNqQmdMLFVBQVUsSUFBSSxDQUFDQSxRQUFRO1FBQzNCO0lBQ0o7SUFDQXJILFdBQVc7UUFDUCxNQUFNNEgsV0FBVyxJQUFLLENBQUN4TSxZQUFZLENBQUMzQyxNQUFNLEdBQUcsSUFBSztRQUNsRCxJQUFJb08sU0FBUyxJQUFJaE8sV0FBVyxJQUFLLENBQUN1QyxZQUFZLENBQUMzQyxNQUFNLEdBQUcsSUFBSztRQUM3RCxJQUFJb1AsWUFBWTtRQUNoQixJQUFJQztRQUNKLE1BQU1DLFdBQVcsSUFBSSxDQUFDM00sWUFBWTtRQUNsQyxJQUFJc0csU0FBUztRQUNiLElBQUlzRyxPQUFPO1FBQ1gsSUFBSyxJQUFJQyxhQUFjRixTQUFTcFAsVUFBVSxHQUFHLEdBQUlzUCxjQUFjLEdBQUdBLGFBQWM7WUFDNUVILGNBQWNDLFFBQVEsQ0FBQ0UsV0FBVztZQUNsQyxJQUFLLElBQUl6UCxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztnQkFDeEIsSUFBSSxDQUFDc1AsY0FBYyxPQUFPLEdBQUc7b0JBQ3pCLE9BQVFEO3dCQUNKLEtBQUtEOzRCQUNEZixTQUFTRSxRQUFRSixPQUFPa0IsWUFBWWhCOzRCQUNwQ25GLFNBQVM7NEJBQ1Q7d0JBQ0o7NEJBQ0ltRixTQUFTZixRQUFRZSxRQUFRRixPQUFPa0I7b0JBQ3hDO2dCQUNKO2dCQUNBQTtnQkFDQUMsZ0JBQWdCO1lBQ3BCO1FBQ0o7UUFDQSxJQUFLLElBQUl0UCxJQUFJLEdBQUdBLElBQUlxTyxPQUFPcE8sTUFBTSxFQUFFRCxJQUFLO1lBQ3BDLElBQUlxTyxNQUFNLENBQUNyTyxFQUFFLEVBQ1R3UCxPQUFPO1lBQ1gsSUFBSUEsTUFDQXRHLFVBQVU3SCxhQUFhcU8sTUFBTSxDQUFDckIsTUFBTSxDQUFDck8sRUFBRTtRQUMvQztRQUNBLElBQUl3UCxTQUFTLE9BQ1R0RyxVQUFVN0gsYUFBYXFPLE1BQU0sQ0FBQztRQUNsQyxPQUFPeEc7SUFDWDtBQUNKO0FBQ0FtRSxPQUFPb0I7QUFDUEEsdUJBQXVCbk4sSUFBSSxHQUFHO0FBQzdCO0lBQ0czQyxPQUFPTyxjQUFjLENBQUNtTyxLQUFLZCxTQUFTLEVBQUUsWUFBWTtRQUM5Q2pNLEtBQUssU0FBVXdPLENBQUM7WUFDWixJQUFJLENBQUNsTSxZQUFZLEdBQUcsSUFBSXZDLFdBQVd5TztZQUNuQyxJQUFJLENBQUNKLFdBQVc7UUFDcEI7UUFDQXZQLEtBQUs7WUFDRCxPQUFPLElBQUksQ0FBQ3lELFlBQVksQ0FBQ0MsS0FBSyxHQUFHM0MsTUFBTTtRQUMzQztJQUNKO0FBQ0o7QUFFQSxJQUFJeVA7QUFDSixNQUFNckcsZ0JBQWdCNUM7SUFDbEI1RixZQUFZZ0csYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBLFlBQVkySDtRQUNsQixJQUFJLENBQUM3SixPQUFPLENBQUNHLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNILE9BQU8sQ0FBQ0ksU0FBUyxHQUFHO0lBQzdCO0lBQ0E0SyxXQUFXO1FBQ1BuUTtRQUNBLE9BQU9DLE9BQU8sSUFBSSxDQUFDc0gsVUFBVSxDQUFDUSxRQUFRO0lBQzFDO0lBQ0EsT0FBT3FJLFdBQVcvTSxLQUFLLEVBQUU7UUFDckJyRDtRQUNBLE1BQU1xUSxjQUFjcFEsT0FBT29EO1FBQzNCLE1BQU1vRSxTQUFTLElBQUlyRztRQUNuQixNQUFNa1AsTUFBTUQsWUFBWXRJLFFBQVEsQ0FBQyxJQUFJd0ksT0FBTyxDQUFDLE1BQU07UUFDbkQsTUFBTTFNLE9BQU8sSUFBSWpELFdBQVdkLHFCQUFxQnVFLE9BQU8sQ0FBQ21NLE9BQU8sQ0FBQ0Y7UUFDakUsSUFBSUQsY0FBYyxHQUFHO1lBQ2pCLE1BQU12QyxRQUFRLElBQUlsTixXQUFXaUQsS0FBS3JELE1BQU0sR0FBSXFELENBQUFBLElBQUksQ0FBQyxFQUFFLEdBQUcsT0FBTyxJQUFJO1lBQ2pFaUssS0FBSyxDQUFDLEVBQUUsSUFBSTtZQUNaLE1BQU0yQyxXQUFXeFEsT0FBTyxDQUFDLEVBQUUsRUFBRUgscUJBQXFCdUUsT0FBTyxDQUFDQyxLQUFLLENBQUN3SixPQUFPLENBQUM7WUFDeEUsTUFBTTRDLFlBQVlELFdBQVdKO1lBQzdCLE1BQU10QyxTQUFTak8scUJBQXFCNEQscUJBQXFCLENBQUNDLFlBQVksQ0FBQzdELHFCQUFxQnVFLE9BQU8sQ0FBQ21NLE9BQU8sQ0FBQ0UsVUFBVTNJLFFBQVEsQ0FBQztZQUMvSGdHLE1BQU0sQ0FBQyxFQUFFLElBQUk7WUFDYnRHLE9BQU9sRyxLQUFLLENBQUN3TTtRQUNqQixPQUNLO1lBQ0QsSUFBSWxLLElBQUksQ0FBQyxFQUFFLEdBQUcsTUFBTTtnQkFDaEI0RCxPQUFPbEcsS0FBSyxDQUFDLElBQUlYLFdBQVc7b0JBQUM7aUJBQUU7WUFDbkM7WUFDQTZHLE9BQU9sRyxLQUFLLENBQUNzQztRQUNqQjtRQUNBLE1BQU04TSxNQUFNLElBQUlULEtBQUs7WUFBRWhOLFVBQVV1RSxPQUFPL0YsS0FBSztRQUFHO1FBQ2hELE9BQU9pUDtJQUNYO0lBQ0FDLGVBQWU7UUFDWCxNQUFNQyxVQUFVLElBQUlYLEtBQUs7WUFBRWhOLFVBQVUsSUFBSSxDQUFDcUUsVUFBVSxDQUFDcEUsWUFBWTtRQUFDO1FBQ2xFME4sUUFBUXRKLFVBQVUsQ0FBQ2tJLEtBQUs7UUFDeEIsT0FBT29CO0lBQ1g7SUFDQUMsaUJBQWlCO1FBQ2IsT0FBTyxJQUFJWixLQUFLO1lBQ1poTixVQUFVLElBQUksQ0FBQ3FFLFVBQVUsQ0FBQ3BFLFlBQVksQ0FBQyxFQUFFLEtBQUssSUFDeEMsSUFBSSxDQUFDb0UsVUFBVSxDQUFDcEUsWUFBWSxDQUFDWSxRQUFRLENBQUMsS0FDdEMsSUFBSSxDQUFDd0QsVUFBVSxDQUFDcEUsWUFBWTtRQUN0QztJQUNKO0lBQ0E4RSxrQkFBa0I7UUFDZCxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUM1RyxXQUFXLENBQUNRLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDMEYsVUFBVSxDQUFDUSxRQUFRLEdBQUcsQ0FBQztJQUNyRTtBQUNKO0FBQ0FtSSxPQUFPckc7QUFDTjtJQUNHN0MsVUFBVTZDLE9BQU8sR0FBR3FHO0FBQ3hCO0FBQ0FyRyxRQUFRaEksSUFBSSxHQUFHO0FBRWYsSUFBSWtQO0FBQ0osTUFBTTdHLG1CQUFtQkw7SUFDckJ4SSxZQUFZZ0csYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbEMsT0FBTyxDQUFDRyxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSCxPQUFPLENBQUNJLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0F3TCxPQUFPN0c7QUFDTjtJQUNHbEQsVUFBVWtELFVBQVUsR0FBRzZHO0FBQzNCO0FBQ0E3RyxXQUFXckksSUFBSSxHQUFHO0FBRWxCLE1BQU1tUCwyQkFBMkJsTyxTQUFTNkI7SUFDdEN0RCxZQUFZLEVBQUUrTixXQUFXLENBQUMsQ0FBQyxFQUFFNkIsYUFBYSxLQUFLLEVBQUUsR0FBRzVKLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNuRSxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDK0gsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUM2QixVQUFVLEdBQUdBO0lBQ3RCO0lBQ0FyTixRQUFRNUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxJQUFJLENBQUNBLGFBQWE7WUFDZCxPQUFPRDtRQUNYO1FBQ0EsTUFBTStFLFlBQVlsRyxxQkFBcUI0RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDM0M7UUFDMUUsSUFBSSxDQUFDRixrQkFBa0IsSUFBSSxFQUFFa0YsV0FBVy9FLGFBQWFDLGNBQWM7WUFDL0QsT0FBTyxDQUFDO1FBQ1o7UUFDQSxNQUFNK0UsWUFBWUQsVUFBVWpDLFFBQVEsQ0FBQzlDLGFBQWFBLGNBQWNDO1FBQ2hFLElBQUksQ0FBQ2lDLFlBQVksR0FBRyxJQUFJdkMsV0FBV007UUFDbkMsSUFBSyxJQUFJWCxJQUFJLEdBQUdBLElBQUlXLGFBQWFYLElBQUs7WUFDbEMsSUFBSSxDQUFDNEMsWUFBWSxDQUFDNUMsRUFBRSxHQUFHMEYsU0FBUyxDQUFDMUYsRUFBRSxHQUFHO1lBQ3RDLElBQUksQ0FBQzBELFdBQVc7WUFDaEIsSUFBSSxDQUFDZ0MsU0FBUyxDQUFDMUYsRUFBRSxHQUFHLElBQUcsTUFBTyxNQUMxQjtRQUNSO1FBQ0EsTUFBTTJRLFdBQVcsSUFBSXRRLFdBQVcsSUFBSSxDQUFDcUQsV0FBVztRQUNoRCxJQUFLLElBQUkxRCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDMEQsV0FBVyxFQUFFMUQsSUFBSztZQUN2QzJRLFFBQVEsQ0FBQzNRLEVBQUUsR0FBRyxJQUFJLENBQUM0QyxZQUFZLENBQUM1QyxFQUFFO1FBQ3RDO1FBQ0EsSUFBSSxDQUFDNEMsWUFBWSxHQUFHK047UUFDcEIsSUFBSSxDQUFDakwsU0FBUyxDQUFDLElBQUksQ0FBQ2hDLFdBQVcsR0FBRyxFQUFFLEdBQUcsSUFBRyxNQUFPLE1BQU07WUFDbkQsSUFBSSxDQUFDOUMsS0FBSyxHQUFHO1lBQ2IsT0FBTyxDQUFDO1FBQ1o7UUFDQSxJQUFJLElBQUksQ0FBQ2dDLFlBQVksQ0FBQyxFQUFFLEtBQUssTUFDekIsSUFBSSxDQUFDYSxRQUFRLENBQUN2QyxJQUFJLENBQUM7UUFDdkIsSUFBSSxJQUFJLENBQUN3QyxXQUFXLElBQUksR0FDcEIsSUFBSSxDQUFDbUwsUUFBUSxHQUFHclAsbUJBQW1CeUcsWUFBWSxDQUFDLElBQUksQ0FBQ3JELFlBQVksRUFBRTthQUNsRTtZQUNELElBQUksQ0FBQ00sU0FBUyxHQUFHO1lBQ2pCLElBQUksQ0FBQ08sUUFBUSxDQUFDdkMsSUFBSSxDQUFDO1FBQ3ZCO1FBQ0EsT0FBUVIsY0FBYyxJQUFJLENBQUNnRCxXQUFXO0lBQzFDO0lBQ0EsSUFBSWtOLFlBQVk5TixLQUFLLEVBQUU7UUFDbkJyRDtRQUNBLElBQUl1TixPQUFPdE4sT0FBT29ELE9BQU8wRSxRQUFRLENBQUM7UUFDbEMsTUFBT3dGLEtBQUsvTSxNQUFNLEdBQUcsRUFBRztZQUNwQitNLE9BQU8sTUFBTUE7UUFDakI7UUFDQSxNQUFNNkQsUUFBUSxJQUFJeFEsV0FBVzJNLEtBQUsvTSxNQUFNLEdBQUc7UUFDM0MsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLElBQUk2USxNQUFNNVEsTUFBTSxFQUFFRCxJQUFLO1lBQ25DNlEsS0FBSyxDQUFDN1EsRUFBRSxHQUFHOFEsU0FBUzlELEtBQUtuSyxLQUFLLENBQUM3QyxJQUFJLEdBQUdBLElBQUksSUFBSSxJQUFJLEtBQU1BLENBQUFBLElBQUksSUFBSTZRLE1BQU01USxNQUFNLEdBQUcsT0FBTztRQUMxRjtRQUNBLElBQUksQ0FBQ29ELE9BQU8sQ0FBQ3dOLE1BQU0zUSxNQUFNLEVBQUUsR0FBRzJRLE1BQU01USxNQUFNO0lBQzlDO0lBQ0EwRCxNQUFNQyxRQUFRLEVBQUU7UUFDWixJQUFJLElBQUksQ0FBQ1YsU0FBUyxFQUFFO1lBQ2hCLElBQUlVLFVBQ0EsT0FBUSxJQUFJMUIsWUFBWSxJQUFJLENBQUNVLFlBQVksQ0FBQ3pDLFVBQVU7WUFDeEQsTUFBTXFGLFVBQVUsSUFBSSxDQUFDNUMsWUFBWTtZQUNqQyxNQUFNeEMsVUFBVSxJQUFJQyxXQUFXLElBQUksQ0FBQ3FELFdBQVc7WUFDL0MsSUFBSyxJQUFJMUQsSUFBSSxHQUFHQSxJQUFLLElBQUksQ0FBQzBELFdBQVcsR0FBRyxHQUFJMUQsSUFDeENJLE9BQU8sQ0FBQ0osRUFBRSxHQUFHd0YsT0FBTyxDQUFDeEYsRUFBRSxHQUFHO1lBQzlCSSxPQUFPLENBQUMsSUFBSSxDQUFDc0QsV0FBVyxHQUFHLEVBQUUsR0FBRzhCLE9BQU8sQ0FBQyxJQUFJLENBQUM5QixXQUFXLEdBQUcsRUFBRTtZQUM3RCxPQUFPdEQsUUFBUUYsTUFBTTtRQUN6QjtRQUNBLE1BQU1rRixhQUFhNUYsbUJBQW1CNkYsVUFBVSxDQUFDLElBQUksQ0FBQ3dKLFFBQVEsRUFBRTtRQUNoRSxJQUFJekosV0FBV2pGLFVBQVUsS0FBSyxHQUFHO1lBQzdCLElBQUksQ0FBQ1MsS0FBSyxHQUFHO1lBQ2IsT0FBT3FCO1FBQ1g7UUFDQSxNQUFNN0IsVUFBVSxJQUFJQyxXQUFXK0UsV0FBV2pGLFVBQVU7UUFDcEQsSUFBSSxDQUFDeUQsVUFBVTtZQUNYLE1BQU0wQixjQUFjLElBQUlqRixXQUFXK0U7WUFDbkMsTUFBTTJMLE1BQU0zTCxXQUFXakYsVUFBVSxHQUFHO1lBQ3BDLElBQUssSUFBSUgsSUFBSSxHQUFHQSxJQUFJK1EsS0FBSy9RLElBQ3JCSSxPQUFPLENBQUNKLEVBQUUsR0FBR3NGLFdBQVcsQ0FBQ3RGLEVBQUUsR0FBRztZQUNsQ0ksT0FBTyxDQUFDMlEsSUFBSSxHQUFHekwsV0FBVyxDQUFDeUwsSUFBSTtRQUNuQztRQUNBLE9BQU8zUTtJQUNYO0lBQ0FvSCxXQUFXO1FBQ1AsSUFBSTBCLFNBQVM7UUFDYixJQUFJLElBQUksQ0FBQ2hHLFNBQVMsRUFDZGdHLFNBQVMzSixxQkFBcUJ1RSxPQUFPLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUNuQixZQUFZO2FBQzVEO1lBQ0QsSUFBSSxJQUFJLENBQUM4TixVQUFVLEVBQUU7Z0JBQ2pCLElBQUlNLFdBQVcsSUFBSSxDQUFDbkMsUUFBUTtnQkFDNUIsSUFBSSxJQUFJLENBQUNBLFFBQVEsSUFBSSxJQUNqQjNGLFNBQVM7cUJBQ1I7b0JBQ0QsSUFBSSxJQUFJLENBQUMyRixRQUFRLElBQUksSUFBSTt3QkFDckIzRixTQUFTO3dCQUNUOEgsWUFBWTtvQkFDaEIsT0FDSzt3QkFDRDlILFNBQVM7d0JBQ1Q4SCxZQUFZO29CQUNoQjtnQkFDSjtnQkFDQTlILFVBQVU4SCxTQUFTeEosUUFBUTtZQUMvQixPQUVJMEIsU0FBUyxJQUFJLENBQUMyRixRQUFRLENBQUNySCxRQUFRO1FBQ3ZDO1FBQ0EsT0FBTzBCO0lBQ1g7SUFDQXJGLFNBQVM7UUFDTCxPQUFPO1lBQ0gsR0FBRyxLQUFLLENBQUNBLFFBQVE7WUFDakJnTCxVQUFVLElBQUksQ0FBQ0EsUUFBUTtZQUN2QjZCLFlBQVksSUFBSSxDQUFDQSxVQUFVO1FBQy9CO0lBQ0o7QUFDSjtBQUNBRCxtQkFBbUJuUCxJQUFJLEdBQUc7QUFFMUIsTUFBTTJQLHdDQUF3QzdNO0lBQzFDdEQsWUFBWSxFQUFFZ0MsUUFBUWQsWUFBWSxFQUFFLEdBQUc4RSxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDdEQsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ2hFLEtBQUssR0FBRyxFQUFFO1FBQ2YsSUFBSUEsT0FBTztZQUNQLElBQUksQ0FBQ3VGLFVBQVUsQ0FBQ3ZGO1FBQ3BCO0lBQ0o7SUFDQU8sUUFBUTVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUU7UUFDM0MsSUFBSXNHLGVBQWV2RztRQUNuQixNQUFPQyxjQUFjLEVBQUc7WUFDcEIsTUFBTXVRLFdBQVcsSUFBSVQ7WUFDckJ4SixlQUFlaUssU0FBUzdOLE9BQU8sQ0FBQzVDLGFBQWF3RyxjQUFjdEc7WUFDM0QsSUFBSXNHLGlCQUFpQixDQUFDLEdBQUc7Z0JBQ3JCLElBQUksQ0FBQ3ZELFdBQVcsR0FBRztnQkFDbkIsSUFBSSxDQUFDOUMsS0FBSyxHQUFHc1EsU0FBU3RRLEtBQUs7Z0JBQzNCLE9BQU9xRztZQUNYO1lBQ0EsSUFBSSxJQUFJLENBQUNuRSxLQUFLLENBQUM3QyxNQUFNLEtBQUssR0FDdEJpUixTQUFTUixVQUFVLEdBQUc7WUFDMUIsSUFBSSxDQUFDaE4sV0FBVyxJQUFJd04sU0FBU3hOLFdBQVc7WUFDeEMvQyxlQUFldVEsU0FBU3hOLFdBQVc7WUFDbkMsSUFBSSxDQUFDWixLQUFLLENBQUM1QixJQUFJLENBQUNnUTtRQUNwQjtRQUNBLE9BQU9qSztJQUNYO0lBQ0F0RCxNQUFNQyxRQUFRLEVBQUU7UUFDWixNQUFNdU4sYUFBYSxFQUFFO1FBQ3JCLElBQUssSUFBSW5SLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM4QyxLQUFLLENBQUM3QyxNQUFNLEVBQUVELElBQUs7WUFDeEMsTUFBTW9SLFdBQVcsSUFBSSxDQUFDdE8sS0FBSyxDQUFDOUMsRUFBRSxDQUFDMkQsS0FBSyxDQUFDQztZQUNyQyxJQUFJd04sU0FBU2pSLFVBQVUsS0FBSyxHQUFHO2dCQUMzQixJQUFJLENBQUNTLEtBQUssR0FBRyxJQUFJLENBQUNrQyxLQUFLLENBQUM5QyxFQUFFLENBQUNZLEtBQUs7Z0JBQ2hDLE9BQU9xQjtZQUNYO1lBQ0FrUCxXQUFXalEsSUFBSSxDQUFDa1E7UUFDcEI7UUFDQSxPQUFPeFIsT0FBT3VSO0lBQ2xCO0lBQ0E5SSxXQUFXZ0osTUFBTSxFQUFFO1FBQ2YsSUFBSSxDQUFDdk8sS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJd08sT0FBTztRQUNYLElBQUlDLE9BQU87UUFDWCxJQUFJQyxNQUFNO1FBQ1YsSUFBSWhDLE9BQU87UUFDWCxHQUFHO1lBQ0MrQixPQUFPRixPQUFPSSxPQUFPLENBQUMsS0FBS0g7WUFDM0IsSUFBSUMsU0FBUyxDQUFDLEdBQ1ZDLE1BQU1ILE9BQU9qRSxTQUFTLENBQUNrRTtpQkFFdkJFLE1BQU1ILE9BQU9qRSxTQUFTLENBQUNrRSxNQUFNQztZQUNqQ0QsT0FBT0MsT0FBTztZQUNkLElBQUkvQixNQUFNO2dCQUNOLE1BQU0wQixXQUFXLElBQUksQ0FBQ3BPLEtBQUssQ0FBQyxFQUFFO2dCQUM5QixJQUFJNE8sT0FBTztnQkFDWCxPQUFRUixTQUFTckMsUUFBUTtvQkFDckIsS0FBSzt3QkFDRDtvQkFDSixLQUFLO3dCQUNENkMsT0FBTzt3QkFDUDtvQkFDSixLQUFLO3dCQUNEQSxPQUFPO3dCQUNQO29CQUNKO3dCQUNJLElBQUksQ0FBQzVPLEtBQUssR0FBRyxFQUFFO3dCQUNmO2dCQUNSO2dCQUNBLE1BQU02TyxZQUFZYixTQUFTVSxLQUFLO2dCQUNoQyxJQUFJSSxNQUFNRCxZQUNOO2dCQUNKVCxTQUFTckMsUUFBUSxHQUFHOEMsWUFBWUQ7Z0JBQ2hDbEMsT0FBTztZQUNYLE9BQ0s7Z0JBQ0QsTUFBTTBCLFdBQVcsSUFBSVQ7Z0JBQ3JCLElBQUllLE1BQU1LLE9BQU9DLGdCQUFnQixFQUFFO29CQUMvQnJTO29CQUNBLE1BQU11UixXQUFXdFIsT0FBTzhSO29CQUN4Qk4sU0FBU04sV0FBVyxHQUFHSTtnQkFDM0IsT0FDSztvQkFDREUsU0FBU3JDLFFBQVEsR0FBR2lDLFNBQVNVLEtBQUs7b0JBQ2xDLElBQUlJLE1BQU1WLFNBQVNyQyxRQUFRLEdBQ3ZCO2dCQUNSO2dCQUNBLElBQUksQ0FBQyxJQUFJLENBQUMvTCxLQUFLLENBQUM3QyxNQUFNLEVBQUU7b0JBQ3BCaVIsU0FBU1IsVUFBVSxHQUFHO29CQUN0QmxCLE9BQU87Z0JBQ1g7Z0JBQ0EsSUFBSSxDQUFDMU0sS0FBSyxDQUFDNUIsSUFBSSxDQUFDZ1E7WUFDcEI7UUFDSixRQUFTSyxTQUFTLENBQUMsR0FBRztJQUMxQjtJQUNBL0osV0FBVztRQUNQLElBQUkwQixTQUFTO1FBQ2IsSUFBSWhHLFlBQVk7UUFDaEIsSUFBSyxJQUFJbEQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzhDLEtBQUssQ0FBQzdDLE1BQU0sRUFBRUQsSUFBSztZQUN4Q2tELFlBQVksSUFBSSxDQUFDSixLQUFLLENBQUM5QyxFQUFFLENBQUNrRCxTQUFTO1lBQ25DLElBQUk2TyxTQUFTLElBQUksQ0FBQ2pQLEtBQUssQ0FBQzlDLEVBQUUsQ0FBQ3dILFFBQVE7WUFDbkMsSUFBSXhILE1BQU0sR0FDTmtKLFNBQVMsQ0FBQyxFQUFFQSxPQUFPLENBQUMsQ0FBQztZQUN6QixJQUFJaEcsV0FBVztnQkFDWDZPLFNBQVMsQ0FBQyxDQUFDLEVBQUVBLE9BQU8sQ0FBQyxDQUFDO2dCQUN0QixJQUFJLElBQUksQ0FBQ2pQLEtBQUssQ0FBQzlDLEVBQUUsQ0FBQzBRLFVBQVUsRUFDeEJ4SCxTQUFTLENBQUMsR0FBRyxFQUFFNkksT0FBTyxNQUFNLENBQUM7cUJBRTdCN0ksVUFBVTZJO1lBQ2xCLE9BRUk3SSxVQUFVNkk7UUFDbEI7UUFDQSxPQUFPN0k7SUFDWDtJQUNBckYsU0FBUztRQUNMLE1BQU0wRCxTQUFTO1lBQ1gsR0FBRyxLQUFLLENBQUMxRCxRQUFRO1lBQ2pCZixPQUFPLElBQUksQ0FBQzBFLFFBQVE7WUFDcEJ3SyxVQUFVLEVBQUU7UUFDaEI7UUFDQSxJQUFLLElBQUloUyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDOEMsS0FBSyxDQUFDN0MsTUFBTSxFQUFFRCxJQUFLO1lBQ3hDdUgsT0FBT3lLLFFBQVEsQ0FBQzlRLElBQUksQ0FBQyxJQUFJLENBQUM0QixLQUFLLENBQUM5QyxFQUFFLENBQUM2RCxNQUFNO1FBQzdDO1FBQ0EsT0FBTzBEO0lBQ1g7QUFDSjtBQUNBMEosZ0NBQWdDM1AsSUFBSSxHQUFHO0FBRXZDLElBQUkyUTtBQUNKLE1BQU12SSx5QkFBeUJoRDtJQUMzQndCLFdBQVc7UUFDUCxPQUFPLElBQUksQ0FBQ2xCLFVBQVUsQ0FBQ1EsUUFBUTtJQUNuQztJQUNBVyxTQUFTckYsS0FBSyxFQUFFO1FBQ1osSUFBSSxDQUFDa0UsVUFBVSxDQUFDcUIsVUFBVSxDQUFDdkY7SUFDL0I7SUFDQWhDLFlBQVlnRyxhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0EsWUFBWW1LO1FBQ2xCLElBQUksQ0FBQ3JNLE9BQU8sQ0FBQ0csUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLEdBQUc7SUFDN0I7SUFDQTBDLGtCQUFrQjtRQUNkLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQzVHLFdBQVcsQ0FBQ1EsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMwRixVQUFVLENBQUNRLFFBQVEsTUFBTSxRQUFRLENBQUM7SUFDaEY7SUFDQTNELFNBQVM7UUFDTCxPQUFPO1lBQ0gsR0FBRyxLQUFLLENBQUNBLFFBQVE7WUFDakJmLE9BQU8sSUFBSSxDQUFDb0YsUUFBUTtRQUN4QjtJQUNKO0FBQ0o7QUFDQStKLE9BQU92STtBQUNOO0lBQ0dqRCxVQUFVaUQsZ0JBQWdCLEdBQUd1STtBQUNqQztBQUNBdkksaUJBQWlCcEksSUFBSSxHQUFHO0FBRXhCLE1BQU00USxtQ0FBbUMzUCxTQUFTeUI7SUFDOUNsRCxZQUFZLEVBQUUrTixXQUFXLENBQUMsRUFBRSxHQUFHL0gsWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQzlDLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUMrSCxRQUFRLEdBQUdBO0lBQ3BCO0lBQ0F4TCxRQUFRNUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxJQUFJQSxnQkFBZ0IsR0FDaEIsT0FBT0Q7UUFDWCxNQUFNK0UsWUFBWWxHLHFCQUFxQjRELHFCQUFxQixDQUFDQyxZQUFZLENBQUMzQztRQUMxRSxJQUFJLENBQUNGLGtCQUFrQixJQUFJLEVBQUVrRixXQUFXL0UsYUFBYUMsY0FDakQsT0FBTyxDQUFDO1FBQ1osTUFBTStFLFlBQVlELFVBQVVqQyxRQUFRLENBQUM5QyxhQUFhQSxjQUFjQztRQUNoRSxJQUFJLENBQUNpQyxZQUFZLEdBQUcsSUFBSXZDLFdBQVdNO1FBQ25DLElBQUssSUFBSVgsSUFBSSxHQUFHQSxJQUFJVyxhQUFhWCxJQUFLO1lBQ2xDLElBQUksQ0FBQzRDLFlBQVksQ0FBQzVDLEVBQUUsR0FBRzBGLFNBQVMsQ0FBQzFGLEVBQUUsR0FBRztZQUN0QyxJQUFJLENBQUMwRCxXQUFXO1lBQ2hCLElBQUksQ0FBQ2dDLFNBQVMsQ0FBQzFGLEVBQUUsR0FBRyxJQUFHLE1BQU8sTUFDMUI7UUFDUjtRQUNBLE1BQU0yUSxXQUFXLElBQUl0USxXQUFXLElBQUksQ0FBQ3FELFdBQVc7UUFDaEQsSUFBSyxJQUFJMUQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzBELFdBQVcsRUFBRTFELElBQ2xDMlEsUUFBUSxDQUFDM1EsRUFBRSxHQUFHLElBQUksQ0FBQzRDLFlBQVksQ0FBQzVDLEVBQUU7UUFDdEMsSUFBSSxDQUFDNEMsWUFBWSxHQUFHK047UUFDcEIsSUFBSSxDQUFDakwsU0FBUyxDQUFDLElBQUksQ0FBQ2hDLFdBQVcsR0FBRyxFQUFFLEdBQUcsSUFBRyxNQUFPLE1BQU07WUFDbkQsSUFBSSxDQUFDOUMsS0FBSyxHQUFHO1lBQ2IsT0FBTyxDQUFDO1FBQ1o7UUFDQSxJQUFJLElBQUksQ0FBQ2dDLFlBQVksQ0FBQyxFQUFFLEtBQUssTUFDekIsSUFBSSxDQUFDYSxRQUFRLENBQUN2QyxJQUFJLENBQUM7UUFDdkIsSUFBSSxJQUFJLENBQUN3QyxXQUFXLElBQUksR0FDcEIsSUFBSSxDQUFDbUwsUUFBUSxHQUFHclAsbUJBQW1CeUcsWUFBWSxDQUFDLElBQUksQ0FBQ3JELFlBQVksRUFBRTthQUNsRTtZQUNELElBQUksQ0FBQ00sU0FBUyxHQUFHO1lBQ2pCLElBQUksQ0FBQ08sUUFBUSxDQUFDdkMsSUFBSSxDQUFDO1FBQ3ZCO1FBQ0EsT0FBUVIsY0FBYyxJQUFJLENBQUNnRCxXQUFXO0lBQzFDO0lBQ0FDLE1BQU1DLFFBQVEsRUFBRTtRQUNaLElBQUksSUFBSSxDQUFDVixTQUFTLEVBQUU7WUFDaEIsSUFBSVUsVUFDQSxPQUFRLElBQUkxQixZQUFZLElBQUksQ0FBQ1UsWUFBWSxDQUFDekMsVUFBVTtZQUN4RCxNQUFNcUYsVUFBVSxJQUFJLENBQUM1QyxZQUFZO1lBQ2pDLE1BQU14QyxVQUFVLElBQUlDLFdBQVcsSUFBSSxDQUFDcUQsV0FBVztZQUMvQyxJQUFLLElBQUkxRCxJQUFJLEdBQUdBLElBQUssSUFBSSxDQUFDMEQsV0FBVyxHQUFHLEdBQUkxRCxJQUN4Q0ksT0FBTyxDQUFDSixFQUFFLEdBQUd3RixPQUFPLENBQUN4RixFQUFFLEdBQUc7WUFDOUJJLE9BQU8sQ0FBQyxJQUFJLENBQUNzRCxXQUFXLEdBQUcsRUFBRSxHQUFHOEIsT0FBTyxDQUFDLElBQUksQ0FBQzlCLFdBQVcsR0FBRyxFQUFFO1lBQzdELE9BQU90RCxRQUFRRixNQUFNO1FBQ3pCO1FBQ0EsTUFBTWtGLGFBQWE1RixtQkFBbUI2RixVQUFVLENBQUMsSUFBSSxDQUFDd0osUUFBUSxFQUFFO1FBQ2hFLElBQUl6SixXQUFXakYsVUFBVSxLQUFLLEdBQUc7WUFDN0IsSUFBSSxDQUFDUyxLQUFLLEdBQUc7WUFDYixPQUFPcUI7UUFDWDtRQUNBLE1BQU03QixVQUFVLElBQUlDLFdBQVcrRSxXQUFXakYsVUFBVTtRQUNwRCxJQUFJLENBQUN5RCxVQUFVO1lBQ1gsTUFBTTBCLGNBQWMsSUFBSWpGLFdBQVcrRTtZQUNuQyxNQUFNMkwsTUFBTTNMLFdBQVdqRixVQUFVLEdBQUc7WUFDcEMsSUFBSyxJQUFJSCxJQUFJLEdBQUdBLElBQUkrUSxLQUFLL1EsSUFDckJJLE9BQU8sQ0FBQ0osRUFBRSxHQUFHc0YsV0FBVyxDQUFDdEYsRUFBRSxHQUFHO1lBQ2xDSSxPQUFPLENBQUMyUSxJQUFJLEdBQUd6TCxXQUFXLENBQUN5TCxJQUFJO1FBQ25DO1FBQ0EsT0FBTzNRLFFBQVFGLE1BQU07SUFDekI7SUFDQXNILFdBQVc7UUFDUCxJQUFJMEIsU0FBUztRQUNiLElBQUksSUFBSSxDQUFDaEcsU0FBUyxFQUNkZ0csU0FBUzNKLHFCQUFxQnVFLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLElBQUksQ0FBQ25CLFlBQVk7YUFDNUQ7WUFDRHNHLFNBQVMsSUFBSSxDQUFDMkYsUUFBUSxDQUFDckgsUUFBUTtRQUNuQztRQUNBLE9BQU8wQjtJQUNYO0lBQ0FyRixTQUFTO1FBQ0wsT0FBTztZQUNILEdBQUcsS0FBSyxDQUFDQSxRQUFRO1lBQ2pCZ0wsVUFBVSxJQUFJLENBQUNBLFFBQVE7UUFDM0I7SUFDSjtBQUNKO0FBQ0FxRCwyQkFBMkI1USxJQUFJLEdBQUc7QUFFbEMsTUFBTTZRLGdEQUFnRC9OO0lBQ2xEdEQsWUFBWSxFQUFFZ0MsUUFBUWQsWUFBWSxFQUFFLEdBQUc4RSxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDdEQsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ2hFLEtBQUssR0FBRyxFQUFFO1FBQ2YsSUFBSUEsT0FBTztZQUNQLElBQUksQ0FBQ3VGLFVBQVUsQ0FBQ3ZGO1FBQ3BCO0lBQ0o7SUFDQU8sUUFBUTVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUU7UUFDM0MsSUFBSXNHLGVBQWV2RztRQUNuQixNQUFPQyxjQUFjLEVBQUc7WUFDcEIsTUFBTXVRLFdBQVcsSUFBSWdCO1lBQ3JCakwsZUFBZWlLLFNBQVM3TixPQUFPLENBQUM1QyxhQUFhd0csY0FBY3RHO1lBQzNELElBQUlzRyxpQkFBaUIsQ0FBQyxHQUFHO2dCQUNyQixJQUFJLENBQUN2RCxXQUFXLEdBQUc7Z0JBQ25CLElBQUksQ0FBQzlDLEtBQUssR0FBR3NRLFNBQVN0USxLQUFLO2dCQUMzQixPQUFPcUc7WUFDWDtZQUNBLElBQUksQ0FBQ3ZELFdBQVcsSUFBSXdOLFNBQVN4TixXQUFXO1lBQ3hDL0MsZUFBZXVRLFNBQVN4TixXQUFXO1lBQ25DLElBQUksQ0FBQ1osS0FBSyxDQUFDNUIsSUFBSSxDQUFDZ1E7UUFDcEI7UUFDQSxPQUFPaks7SUFDWDtJQUNBdEQsTUFBTUMsUUFBUSxFQUFFYyxPQUFPLEVBQUU7UUFDckIsTUFBTXlNLGFBQWEsRUFBRTtRQUNyQixJQUFLLElBQUluUixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDOEMsS0FBSyxDQUFDN0MsTUFBTSxFQUFFRCxJQUFLO1lBQ3hDLE1BQU1vUixXQUFXLElBQUksQ0FBQ3RPLEtBQUssQ0FBQzlDLEVBQUUsQ0FBQzJELEtBQUssQ0FBQ0M7WUFDckMsSUFBSXdOLFNBQVNqUixVQUFVLEtBQUssR0FBRztnQkFDM0IsSUFBSSxDQUFDUyxLQUFLLEdBQUcsSUFBSSxDQUFDa0MsS0FBSyxDQUFDOUMsRUFBRSxDQUFDWSxLQUFLO2dCQUNoQyxPQUFPcUI7WUFDWDtZQUNBa1AsV0FBV2pRLElBQUksQ0FBQ2tRO1FBQ3BCO1FBQ0EsT0FBT3hSLE9BQU91UjtJQUNsQjtJQUNBOUksV0FBV2dKLE1BQU0sRUFBRTtRQUNmLElBQUksQ0FBQ3ZPLEtBQUssR0FBRyxFQUFFO1FBQ2YsSUFBSXdPLE9BQU87UUFDWCxJQUFJQyxPQUFPO1FBQ1gsSUFBSUMsTUFBTTtRQUNWLEdBQUc7WUFDQ0QsT0FBT0YsT0FBT0ksT0FBTyxDQUFDLEtBQUtIO1lBQzNCLElBQUlDLFNBQVMsQ0FBQyxHQUNWQyxNQUFNSCxPQUFPakUsU0FBUyxDQUFDa0U7aUJBRXZCRSxNQUFNSCxPQUFPakUsU0FBUyxDQUFDa0UsTUFBTUM7WUFDakNELE9BQU9DLE9BQU87WUFDZCxNQUFNTCxXQUFXLElBQUlnQjtZQUNyQmhCLFNBQVNyQyxRQUFRLEdBQUdpQyxTQUFTVSxLQUFLO1lBQ2xDLElBQUlJLE1BQU1WLFNBQVNyQyxRQUFRLEdBQ3ZCLE9BQU87WUFDWCxJQUFJLENBQUMvTCxLQUFLLENBQUM1QixJQUFJLENBQUNnUTtRQUNwQixRQUFTSyxTQUFTLENBQUMsR0FBRztRQUN0QixPQUFPO0lBQ1g7SUFDQS9KLFdBQVc7UUFDUCxJQUFJMEIsU0FBUztRQUNiLElBQUloRyxZQUFZO1FBQ2hCLElBQUssSUFBSWxELElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM4QyxLQUFLLENBQUM3QyxNQUFNLEVBQUVELElBQUs7WUFDeENrRCxZQUFZLElBQUksQ0FBQ0osS0FBSyxDQUFDOUMsRUFBRSxDQUFDa0QsU0FBUztZQUNuQyxJQUFJNk8sU0FBUyxJQUFJLENBQUNqUCxLQUFLLENBQUM5QyxFQUFFLENBQUN3SCxRQUFRO1lBQ25DLElBQUl4SCxNQUFNLEdBQ05rSixTQUFTLENBQUMsRUFBRUEsT0FBTyxDQUFDLENBQUM7WUFDekIsSUFBSWhHLFdBQVc7Z0JBQ1g2TyxTQUFTLENBQUMsQ0FBQyxFQUFFQSxPQUFPLENBQUMsQ0FBQztnQkFDdEI3SSxVQUFVNkk7WUFDZCxPQUVJN0ksVUFBVTZJO1FBQ2xCO1FBQ0EsT0FBTzdJO0lBQ1g7SUFDQXJGLFNBQVM7UUFDTCxNQUFNMEQsU0FBUztZQUNYLEdBQUcsS0FBSyxDQUFDMUQsUUFBUTtZQUNqQmYsT0FBTyxJQUFJLENBQUMwRSxRQUFRO1lBQ3BCd0ssVUFBVSxFQUFFO1FBQ2hCO1FBQ0EsSUFBSyxJQUFJaFMsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzhDLEtBQUssQ0FBQzdDLE1BQU0sRUFBRUQsSUFDbkN1SCxPQUFPeUssUUFBUSxDQUFDOVEsSUFBSSxDQUFDLElBQUksQ0FBQzRCLEtBQUssQ0FBQzlDLEVBQUUsQ0FBQzZELE1BQU07UUFDN0MsT0FBTzBEO0lBQ1g7QUFDSjtBQUNBNEssd0NBQXdDN1EsSUFBSSxHQUFHO0FBRS9DLElBQUk4UTtBQUNKLE1BQU12SSxpQ0FBaUNuRDtJQUNuQ3dCLFdBQVc7UUFDUCxPQUFPLElBQUksQ0FBQ2xCLFVBQVUsQ0FBQ1EsUUFBUTtJQUNuQztJQUNBVyxTQUFTckYsS0FBSyxFQUFFO1FBQ1osSUFBSSxDQUFDa0UsVUFBVSxDQUFDcUIsVUFBVSxDQUFDdkY7SUFDL0I7SUFDQWhDLFlBQVlnRyxhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0EsWUFBWXFMO1FBQ2xCLElBQUksQ0FBQ3ZOLE9BQU8sQ0FBQ0csUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLEdBQUc7SUFDN0I7SUFDQTBDLGtCQUFrQjtRQUNkLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQzVHLFdBQVcsQ0FBQ1EsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMwRixVQUFVLENBQUNRLFFBQVEsTUFBTSxRQUFRLENBQUM7SUFDaEY7SUFDQTNELFNBQVM7UUFDTCxPQUFPO1lBQ0gsR0FBRyxLQUFLLENBQUNBLFFBQVE7WUFDakJmLE9BQU8sSUFBSSxDQUFDb0YsUUFBUTtRQUN4QjtJQUNKO0FBQ0o7QUFDQWtLLE9BQU92STtBQUNOO0lBQ0dwRCxVQUFVb0Qsd0JBQXdCLEdBQUd1STtBQUN6QztBQUNBdkkseUJBQXlCdkksSUFBSSxHQUFHO0FBRWhDLElBQUkrUTtBQUNKLE1BQU10SSxpQkFBaUIvQjtJQUNuQmxILFlBQVlnRyxhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNsQyxPQUFPLENBQUNHLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNILE9BQU8sQ0FBQ0ksU0FBUyxHQUFHO0lBQzdCO0FBQ0o7QUFDQXFOLE9BQU90STtBQUNOO0lBQ0d0RCxVQUFVc0QsUUFBUSxHQUFHc0k7QUFDekI7QUFDQXRJLFNBQVN6SSxJQUFJLEdBQUc7QUFFaEIsSUFBSWdSO0FBQ0osTUFBTXRJLFlBQVloQztJQUNkbEgsWUFBWWdHLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ2xDLE9BQU8sQ0FBQ0csUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBc04sT0FBT3RJO0FBQ047SUFDR3ZELFVBQVV1RCxHQUFHLEdBQUdzSTtBQUNwQjtBQUNBdEksSUFBSTFJLElBQUksR0FBRztBQUVYLE1BQU1pUiw4QkFBOEJoUSxTQUFTNkI7SUFDekN0RCxZQUFZLEVBQUUsR0FBR2dHLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNoQyxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDNUQsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0osS0FBSyxHQUFHZDtJQUNqQjtJQUNBNkIsU0FBUztRQUNMLE9BQU87WUFDSCxHQUFHLEtBQUssQ0FBQ0EsUUFBUTtZQUNqQmYsT0FBTyxJQUFJLENBQUNBLEtBQUs7UUFDckI7SUFDSjtBQUNKO0FBQ0F5UCxzQkFBc0JqUixJQUFJLEdBQUc7QUFFN0IsTUFBTWtSLG9DQUFvQ0Q7QUFDMUM7QUFDQUMsNEJBQTRCbFIsSUFBSSxHQUFHO0FBRW5DLE1BQU1tUiwrQkFBK0J4SztJQUNqQ25ILFlBQVksRUFBRSxHQUFHZ0csWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ2hDLEtBQUssQ0FBQ0EsWUFBWTBMO0lBQ3RCO0lBQ0FsSyxXQUFXN0gsV0FBVyxFQUFFO1FBQ3BCLElBQUksQ0FBQ3VHLFVBQVUsQ0FBQ2xFLEtBQUssR0FBRzRQLE9BQU9DLFlBQVksQ0FBQ0MsS0FBSyxDQUFDLE1BQU1yVCxxQkFBcUI0RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDM0M7SUFDcEg7SUFDQTRILFdBQVd3SyxXQUFXLEVBQUU7UUFDcEIsTUFBTUMsU0FBU0QsWUFBWTVTLE1BQU07UUFDakMsTUFBTXFELE9BQU8sSUFBSSxDQUFDMEQsVUFBVSxDQUFDcEUsWUFBWSxHQUFHLElBQUl2QyxXQUFXeVM7UUFDM0QsSUFBSyxJQUFJOVMsSUFBSSxHQUFHQSxJQUFJOFMsUUFBUTlTLElBQ3hCc0QsSUFBSSxDQUFDdEQsRUFBRSxHQUFHNlMsWUFBWUUsVUFBVSxDQUFDL1M7UUFDckMsSUFBSSxDQUFDZ0gsVUFBVSxDQUFDbEUsS0FBSyxHQUFHK1A7SUFDNUI7QUFDSjtBQUNBSix1QkFBdUJuUixJQUFJLEdBQUc7QUFFOUIsTUFBTTBSLGtDQUFrQ1A7SUFDcENuSyxXQUFXN0gsV0FBVyxFQUFFO1FBQ3BCLElBQUksQ0FBQ3VHLFVBQVUsQ0FBQ3BFLFlBQVksR0FBR3JELHFCQUFxQjRELHFCQUFxQixDQUFDQyxZQUFZLENBQUMzQztRQUN2RixJQUFJO1lBQ0EsSUFBSSxDQUFDdUcsVUFBVSxDQUFDbEUsS0FBSyxHQUFHdkQscUJBQXFCdUUsT0FBTyxDQUFDbVAsWUFBWSxDQUFDeFM7UUFDdEUsRUFDQSxPQUFPeVMsSUFBSTtZQUNQLElBQUksQ0FBQ3pQLFFBQVEsQ0FBQ3ZDLElBQUksQ0FBQyxDQUFDLG1DQUFtQyxFQUFFZ1MsR0FBRyxrQkFBa0IsQ0FBQztZQUMvRSxJQUFJLENBQUNsTSxVQUFVLENBQUNsRSxLQUFLLEdBQUd2RCxxQkFBcUJ1RSxPQUFPLENBQUNxUCxRQUFRLENBQUMxUztRQUNsRTtJQUNKO0lBQ0E0SCxXQUFXd0ssV0FBVyxFQUFFO1FBQ3BCLElBQUksQ0FBQzdMLFVBQVUsQ0FBQ3BFLFlBQVksR0FBRyxJQUFJdkMsV0FBV2QscUJBQXFCdUUsT0FBTyxDQUFDc1AsY0FBYyxDQUFDUDtRQUMxRixJQUFJLENBQUM3TCxVQUFVLENBQUNsRSxLQUFLLEdBQUcrUDtJQUM1QjtBQUNKO0FBQ0FHLDBCQUEwQjFSLElBQUksR0FBRztBQUVqQyxJQUFJK1I7QUFDSixNQUFNekosbUJBQW1Cb0o7SUFDckJsUyxZQUFZZ0csYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbEMsT0FBTyxDQUFDRyxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSCxPQUFPLENBQUNJLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0FxTyxPQUFPeko7QUFDTjtJQUNHbkQsVUFBVW1ELFVBQVUsR0FBR3lKO0FBQzNCO0FBQ0F6SixXQUFXdEksSUFBSSxHQUFHO0FBRWxCLE1BQU1nUyxpQ0FBaUNiO0lBQ25DbkssV0FBVzdILFdBQVcsRUFBRTtRQUNwQixJQUFJLENBQUN1RyxVQUFVLENBQUNsRSxLQUFLLEdBQUd2RCxxQkFBcUJ1RSxPQUFPLENBQUN5UCxhQUFhLENBQUM5UztRQUNuRSxJQUFJLENBQUN1RyxVQUFVLENBQUNwRSxZQUFZLEdBQUdyRCxxQkFBcUI0RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDM0M7SUFDM0Y7SUFDQTRILFdBQVd3SyxXQUFXLEVBQUU7UUFDcEIsSUFBSSxDQUFDN0wsVUFBVSxDQUFDbEUsS0FBSyxHQUFHK1A7UUFDeEIsSUFBSSxDQUFDN0wsVUFBVSxDQUFDcEUsWUFBWSxHQUFHLElBQUl2QyxXQUFXZCxxQkFBcUJ1RSxPQUFPLENBQUMwUCxlQUFlLENBQUNYO0lBQy9GO0FBQ0o7QUFDQVMseUJBQXlCaFMsSUFBSSxHQUFHO0FBRWhDLElBQUltUztBQUNKLE1BQU01SSxrQkFBa0J5STtJQUNwQnhTLFlBQVksRUFBRSxHQUFHZ0csWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ2hDLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNsQyxPQUFPLENBQUNHLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNILE9BQU8sQ0FBQ0ksU0FBUyxHQUFHO0lBQzdCO0FBQ0o7QUFDQXlPLE9BQU81STtBQUNOO0lBQ0dwRSxVQUFVb0UsU0FBUyxHQUFHNEk7QUFDMUI7QUFDQTVJLFVBQVV2SixJQUFJLEdBQUc7QUFFakIsTUFBTW9TLHVDQUF1Q2pCO0lBQ3pDbkssV0FBVzdILFdBQVcsRUFBRTtRQUNwQixNQUFNa1QsYUFBYXpSLFlBQVkwUixNQUFNLENBQUNuVCxlQUFlQSxZQUFZb0MsS0FBSyxHQUFHM0MsTUFBTSxHQUFHTyxZQUFZb0MsS0FBSyxDQUFDO1FBQ3BHLE1BQU1nUixZQUFZLElBQUl4VCxXQUFXc1Q7UUFDakMsSUFBSyxJQUFJM1QsSUFBSSxHQUFHQSxJQUFJNlQsVUFBVTVULE1BQU0sRUFBRUQsS0FBSyxFQUFHO1lBQzFDNlQsU0FBUyxDQUFDN1QsRUFBRSxHQUFHNlQsU0FBUyxDQUFDN1QsSUFBSSxFQUFFO1lBQy9CNlQsU0FBUyxDQUFDN1QsSUFBSSxFQUFFLEdBQUc2VCxTQUFTLENBQUM3VCxJQUFJLEVBQUU7WUFDbkM2VCxTQUFTLENBQUM3VCxJQUFJLEVBQUUsR0FBRztZQUNuQjZULFNBQVMsQ0FBQzdULElBQUksRUFBRSxHQUFHO1FBQ3ZCO1FBQ0EsSUFBSSxDQUFDZ0gsVUFBVSxDQUFDbEUsS0FBSyxHQUFHNFAsT0FBT0MsWUFBWSxDQUFDQyxLQUFLLENBQUMsTUFBTSxJQUFJa0IsWUFBWUg7SUFDNUU7SUFDQXRMLFdBQVd3SyxXQUFXLEVBQUU7UUFDcEIsTUFBTWtCLFlBQVlsQixZQUFZNVMsTUFBTTtRQUNwQyxNQUFNMkMsZUFBZSxJQUFJLENBQUNvRSxVQUFVLENBQUNwRSxZQUFZLEdBQUcsSUFBSXZDLFdBQVcwVCxZQUFZO1FBQy9FLElBQUssSUFBSS9ULElBQUksR0FBR0EsSUFBSStULFdBQVcvVCxJQUFLO1lBQ2hDLE1BQU1nVSxVQUFVeFUsbUJBQW1CNkYsVUFBVSxDQUFDd04sWUFBWUUsVUFBVSxDQUFDL1MsSUFBSTtZQUN6RSxNQUFNaVUsV0FBVyxJQUFJNVQsV0FBVzJUO1lBQ2hDLElBQUlDLFNBQVNoVSxNQUFNLEdBQUcsR0FDbEI7WUFDSixNQUFNaVUsTUFBTSxJQUFJRCxTQUFTaFUsTUFBTTtZQUMvQixJQUFLLElBQUlrVSxJQUFLRixTQUFTaFUsTUFBTSxHQUFHLEdBQUlrVSxLQUFLLEdBQUdBLElBQ3hDdlIsWUFBWSxDQUFDNUMsSUFBSSxJQUFJbVUsSUFBSUQsSUFBSSxHQUFHRCxRQUFRLENBQUNFLEVBQUU7UUFDbkQ7UUFDQSxJQUFJLENBQUNuTixVQUFVLENBQUNsRSxLQUFLLEdBQUcrUDtJQUM1QjtBQUNKO0FBQ0FhLCtCQUErQnBTLElBQUksR0FBRztBQUV0QyxJQUFJOFM7QUFDSixNQUFNekosd0JBQXdCK0k7SUFDMUI1UyxZQUFZLEVBQUUsR0FBR2dHLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNoQyxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbEMsT0FBTyxDQUFDRyxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSCxPQUFPLENBQUNJLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0FvUCxPQUFPeko7QUFDTjtJQUNHbEUsVUFBVWtFLGVBQWUsR0FBR3lKO0FBQ2hDO0FBQ0F6SixnQkFBZ0JySixJQUFJLEdBQUc7QUFFdkIsSUFBSStTO0FBQ0osTUFBTXBLLHNCQUFzQndJO0lBQ3hCM1IsWUFBWWdHLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ2xDLE9BQU8sQ0FBQ0csUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBcVAsT0FBT3BLO0FBQ047SUFDR3hELFVBQVV3RCxhQUFhLEdBQUdvSztBQUM5QjtBQUNBcEssY0FBYzNJLElBQUksR0FBRztBQUVyQixJQUFJZ1Q7QUFDSixNQUFNcEssd0JBQXdCdUk7SUFDMUIzUixZQUFZZ0csYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbEMsT0FBTyxDQUFDRyxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSCxPQUFPLENBQUNJLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0FzUCxPQUFPcEs7QUFDTjtJQUNHekQsVUFBVXlELGVBQWUsR0FBR29LO0FBQ2hDO0FBQ0FwSyxnQkFBZ0I1SSxJQUFJLEdBQUc7QUFFdkIsSUFBSWlUO0FBQ0osTUFBTXBLLHNCQUFzQnNJO0lBQ3hCM1IsWUFBWWdHLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ2xDLE9BQU8sQ0FBQ0csUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBdVAsT0FBT3BLO0FBQ047SUFDRzFELFVBQVUwRCxhQUFhLEdBQUdvSztBQUM5QjtBQUNBcEssY0FBYzdJLElBQUksR0FBRztBQUVyQixJQUFJa1Q7QUFDSixNQUFNcEssdUJBQXVCcUk7SUFDekIzUixZQUFZZ0csYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbEMsT0FBTyxDQUFDRyxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSCxPQUFPLENBQUNJLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0F3UCxPQUFPcEs7QUFDTjtJQUNHM0QsVUFBVTJELGNBQWMsR0FBR29LO0FBQy9CO0FBQ0FwSyxlQUFlOUksSUFBSSxHQUFHO0FBRXRCLElBQUltVDtBQUNKLE1BQU1wSyxrQkFBa0JvSTtJQUNwQjNSLFlBQVlnRyxhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNsQyxPQUFPLENBQUNHLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNILE9BQU8sQ0FBQ0ksU0FBUyxHQUFHO0lBQzdCO0FBQ0o7QUFDQXlQLE9BQU9wSztBQUNOO0lBQ0c1RCxVQUFVNEQsU0FBUyxHQUFHb0s7QUFDMUI7QUFDQXBLLFVBQVUvSSxJQUFJLEdBQUc7QUFFakIsSUFBSW9UO0FBQ0osTUFBTWxLLHNCQUFzQmlJO0lBQ3hCM1IsWUFBWWdHLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ2xDLE9BQU8sQ0FBQ0csUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBMFAsT0FBT2xLO0FBQ047SUFDRy9ELFVBQVUrRCxhQUFhLEdBQUdrSztBQUM5QjtBQUNBbEssY0FBY2xKLElBQUksR0FBRztBQUVyQixJQUFJcVQ7QUFDSixNQUFNbEssc0JBQXNCZ0k7SUFDeEIzUixZQUFZZ0csYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbEMsT0FBTyxDQUFDRyxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSCxPQUFPLENBQUNJLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0EyUCxPQUFPbEs7QUFDTjtJQUNHaEUsVUFBVWdFLGFBQWEsR0FBR2tLO0FBQzlCO0FBQ0FsSyxjQUFjbkosSUFBSSxHQUFHO0FBRXJCLElBQUlzVDtBQUNKLE1BQU1sSyxzQkFBc0IrSDtJQUN4QjNSLFlBQVlnRyxhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNsQyxPQUFPLENBQUNHLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNILE9BQU8sQ0FBQ0ksU0FBUyxHQUFHO0lBQzdCO0FBQ0o7QUFDQTRQLE9BQU9sSztBQUNOO0lBQ0dqRSxVQUFVaUUsYUFBYSxHQUFHa0s7QUFDOUI7QUFDQWxLLGNBQWNwSixJQUFJLEdBQUc7QUFFckIsSUFBSXVUO0FBQ0osTUFBTWpLLHdCQUF3QjZIO0lBQzFCM1IsWUFBWWdHLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ2xDLE9BQU8sQ0FBQ0csUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBNlAsT0FBT2pLO0FBQ047SUFDR25FLFVBQVVtRSxlQUFlLEdBQUdpSztBQUNoQztBQUNBakssZ0JBQWdCdEosSUFBSSxHQUFHO0FBRXZCLElBQUl3VDtBQUNKLE1BQU14SyxnQkFBZ0JHO0lBQ2xCM0osWUFBWSxFQUFFZ0MsS0FBSyxFQUFFaVMsU0FBUyxFQUFFLEdBQUdqTyxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDbEQsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ2tPLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDNUgsTUFBTSxHQUFHO1FBQ2QsSUFBSTFLLE9BQU87WUFDUCxJQUFJLENBQUN1RixVQUFVLENBQUN2RjtZQUNoQixJQUFJLENBQUNrRSxVQUFVLENBQUNwRSxZQUFZLEdBQUcsSUFBSXZDLFdBQVd5QyxNQUFNN0MsTUFBTTtZQUMxRCxJQUFLLElBQUlELElBQUksR0FBR0EsSUFBSThDLE1BQU03QyxNQUFNLEVBQUVELElBQzlCLElBQUksQ0FBQ2dILFVBQVUsQ0FBQ3BFLFlBQVksQ0FBQzVDLEVBQUUsR0FBRzhDLE1BQU1pUSxVQUFVLENBQUMvUztRQUMzRDtRQUNBLElBQUkrVSxXQUFXO1lBQ1gsSUFBSSxDQUFDTSxRQUFRLENBQUNOO1lBQ2QsSUFBSSxDQUFDL04sVUFBVSxDQUFDcEUsWUFBWSxHQUFHLElBQUl2QyxXQUFXLElBQUksQ0FBQ2lWLFFBQVE7UUFDL0Q7UUFDQSxJQUFJLENBQUMxUSxPQUFPLENBQUNHLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNILE9BQU8sQ0FBQ0ksU0FBUyxHQUFHO0lBQzdCO0lBQ0FzRCxXQUFXN0gsV0FBVyxFQUFFO1FBQ3BCLElBQUksQ0FBQzRILFVBQVUsQ0FBQ3FLLE9BQU9DLFlBQVksQ0FBQ0MsS0FBSyxDQUFDLE1BQU1yVCxxQkFBcUI0RCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDM0M7SUFDNUc7SUFDQTZVLFdBQVc7UUFDUCxNQUFNQyxNQUFNLElBQUksQ0FBQy9OLFFBQVE7UUFDekIsTUFBTXRILFNBQVMsSUFBSWdDLFlBQVlxVCxJQUFJdFYsTUFBTTtRQUN6QyxNQUFNcUQsT0FBTyxJQUFJakQsV0FBV0g7UUFDNUIsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUl1VixJQUFJdFYsTUFBTSxFQUFFRCxJQUM1QnNELElBQUksQ0FBQ3RELEVBQUUsR0FBR3VWLElBQUl4QyxVQUFVLENBQUMvUztRQUM3QixPQUFPRTtJQUNYO0lBQ0FtVixTQUFTRyxTQUFTLEVBQUU7UUFDaEIsSUFBSSxDQUFDUixJQUFJLEdBQUdRLFVBQVVDLGNBQWM7UUFDcEMsSUFBSSxDQUFDUixLQUFLLEdBQUdPLFVBQVVFLFdBQVcsS0FBSztRQUN2QyxJQUFJLENBQUNSLEdBQUcsR0FBR00sVUFBVUcsVUFBVTtRQUMvQixJQUFJLENBQUNSLElBQUksR0FBR0ssVUFBVUksV0FBVztRQUNqQyxJQUFJLENBQUNSLE1BQU0sR0FBR0ksVUFBVUssYUFBYTtRQUNyQyxJQUFJLENBQUNySSxNQUFNLEdBQUdnSSxVQUFVTSxhQUFhO0lBQ3pDO0lBQ0FDLFNBQVM7UUFDTCxPQUFRLElBQUlDLEtBQUtBLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNqQixJQUFJLEVBQUUsSUFBSSxDQUFDQyxLQUFLLEdBQUcsR0FBRyxJQUFJLENBQUNDLEdBQUcsRUFBRSxJQUFJLENBQUNDLElBQUksRUFBRSxJQUFJLENBQUNDLE1BQU0sRUFBRSxJQUFJLENBQUM1SCxNQUFNO0lBQ3RHO0lBQ0FuRixXQUFXd0ssV0FBVyxFQUFFO1FBQ3BCLE1BQU1xRCxTQUFTO1FBQ2YsTUFBTUMsY0FBY0QsT0FBT0UsSUFBSSxDQUFDdkQ7UUFDaEMsSUFBSXNELGdCQUFnQixNQUFNO1lBQ3RCLElBQUksQ0FBQ3ZWLEtBQUssR0FBRztZQUNiO1FBQ0o7UUFDQSxNQUFNb1UsT0FBT2xFLFNBQVNxRixXQUFXLENBQUMsRUFBRSxFQUFFO1FBQ3RDLElBQUluQixRQUFRLElBQ1IsSUFBSSxDQUFDQSxJQUFJLEdBQUcsT0FBT0E7YUFFbkIsSUFBSSxDQUFDQSxJQUFJLEdBQUcsT0FBT0E7UUFDdkIsSUFBSSxDQUFDQyxLQUFLLEdBQUduRSxTQUFTcUYsV0FBVyxDQUFDLEVBQUUsRUFBRTtRQUN0QyxJQUFJLENBQUNqQixHQUFHLEdBQUdwRSxTQUFTcUYsV0FBVyxDQUFDLEVBQUUsRUFBRTtRQUNwQyxJQUFJLENBQUNoQixJQUFJLEdBQUdyRSxTQUFTcUYsV0FBVyxDQUFDLEVBQUUsRUFBRTtRQUNyQyxJQUFJLENBQUNmLE1BQU0sR0FBR3RFLFNBQVNxRixXQUFXLENBQUMsRUFBRSxFQUFFO1FBQ3ZDLElBQUksQ0FBQzNJLE1BQU0sR0FBR3NELFNBQVNxRixXQUFXLENBQUMsRUFBRSxFQUFFO0lBQzNDO0lBQ0EzTyxTQUFTQyxXQUFXLEtBQUssRUFBRTtRQUN2QixJQUFJQSxhQUFhLE9BQU87WUFDcEIsTUFBTTRPLGNBQWMsSUFBSUMsTUFBTTtZQUM5QkQsV0FBVyxDQUFDLEVBQUUsR0FBRzdXLG1CQUFtQitXLFNBQVMsQ0FBRSxJQUFLLENBQUN2QixJQUFJLEdBQUcsT0FBUyxJQUFJLENBQUNBLElBQUksR0FBRyxPQUFTLElBQUksQ0FBQ0EsSUFBSSxHQUFHLE1BQVE7WUFDOUdxQixXQUFXLENBQUMsRUFBRSxHQUFHN1csbUJBQW1CK1csU0FBUyxDQUFDLElBQUksQ0FBQ3RCLEtBQUssRUFBRTtZQUMxRG9CLFdBQVcsQ0FBQyxFQUFFLEdBQUc3VyxtQkFBbUIrVyxTQUFTLENBQUMsSUFBSSxDQUFDckIsR0FBRyxFQUFFO1lBQ3hEbUIsV0FBVyxDQUFDLEVBQUUsR0FBRzdXLG1CQUFtQitXLFNBQVMsQ0FBQyxJQUFJLENBQUNwQixJQUFJLEVBQUU7WUFDekRrQixXQUFXLENBQUMsRUFBRSxHQUFHN1csbUJBQW1CK1csU0FBUyxDQUFDLElBQUksQ0FBQ25CLE1BQU0sRUFBRTtZQUMzRGlCLFdBQVcsQ0FBQyxFQUFFLEdBQUc3VyxtQkFBbUIrVyxTQUFTLENBQUMsSUFBSSxDQUFDL0ksTUFBTSxFQUFFO1lBQzNENkksV0FBVyxDQUFDLEVBQUUsR0FBRztZQUNqQixPQUFPQSxZQUFZekssSUFBSSxDQUFDO1FBQzVCO1FBQ0EsT0FBTyxLQUFLLENBQUNwRSxTQUFTQztJQUMxQjtJQUNBQyxrQkFBa0I7UUFDZCxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUM1RyxXQUFXLENBQUNRLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDeVUsTUFBTSxHQUFHUyxXQUFXLEdBQUcsQ0FBQztJQUN0RTtJQUNBM1MsU0FBUztRQUNMLE9BQU87WUFDSCxHQUFHLEtBQUssQ0FBQ0EsUUFBUTtZQUNqQm1SLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZDLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1lBQ2pCQyxLQUFLLElBQUksQ0FBQ0EsR0FBRztZQUNiQyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmQyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQjVILFFBQVEsSUFBSSxDQUFDQSxNQUFNO1FBQ3ZCO0lBQ0o7QUFDSjtBQUNBc0gsT0FBT3hLO0FBQ047SUFDRzdELFVBQVU2RCxPQUFPLEdBQUd3SztBQUN4QjtBQUNBeEssUUFBUWhKLElBQUksR0FBRztBQUVmLElBQUltVjtBQUNKLE1BQU1sTSx3QkFBd0JEO0lBQzFCeEosWUFBWWdHLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsSUFBSTlEO1FBQ0osS0FBSyxDQUFDOEQ7UUFDTDlELENBQUFBLEtBQUssSUFBSSxDQUFDMFQsV0FBVyxNQUFNLFFBQVExVCxPQUFPLEtBQUssSUFBSUEsS0FBTSxJQUFJLENBQUMwVCxXQUFXLEdBQUc7UUFDN0UsSUFBSSxDQUFDOVIsT0FBTyxDQUFDRyxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSCxPQUFPLENBQUNJLFNBQVMsR0FBRztJQUM3QjtJQUNBcVEsU0FBU0csU0FBUyxFQUFFO1FBQ2hCLEtBQUssQ0FBQ0gsU0FBU0c7UUFDZixJQUFJLENBQUNrQixXQUFXLEdBQUdsQixVQUFVbUIsa0JBQWtCO0lBQ25EO0lBQ0FaLFNBQVM7UUFDTCxNQUFNYSxVQUFVWixLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDakIsSUFBSSxFQUFFLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEdBQUcsSUFBSSxDQUFDQyxHQUFHLEVBQUUsSUFBSSxDQUFDQyxJQUFJLEVBQUUsSUFBSSxDQUFDQyxNQUFNLEVBQUUsSUFBSSxDQUFDNUgsTUFBTSxFQUFFLElBQUksQ0FBQ2tKLFdBQVc7UUFDbkgsT0FBUSxJQUFJVixLQUFLWTtJQUNyQjtJQUNBdk8sV0FBV3dLLFdBQVcsRUFBRTtRQUNwQixJQUFJZ0UsUUFBUTtRQUNaLElBQUlDLGFBQWE7UUFDakIsSUFBSUMsaUJBQWlCO1FBQ3JCLElBQUlDLGVBQWU7UUFDbkIsSUFBSWQ7UUFDSixJQUFJZSxpQkFBaUI7UUFDckIsSUFBSUMsbUJBQW1CO1FBQ3ZCLElBQUlyRSxXQUFXLENBQUNBLFlBQVk1UyxNQUFNLEdBQUcsRUFBRSxLQUFLLEtBQUs7WUFDN0M2VyxhQUFhakUsWUFBWXpGLFNBQVMsQ0FBQyxHQUFHeUYsWUFBWTVTLE1BQU0sR0FBRztZQUMzRDRXLFFBQVE7UUFDWixPQUNLO1lBQ0QsTUFBTTFSLFNBQVMsSUFBSTBNLE9BQU9nQixXQUFXLENBQUNBLFlBQVk1UyxNQUFNLEdBQUcsRUFBRTtZQUM3RCxJQUFJMlIsTUFBTXpNLE9BQU9nUyxPQUFPLEtBQ3BCLE1BQU0sSUFBSXhYLE1BQU07WUFDcEJtWCxhQUFhakU7UUFDakI7UUFDQSxJQUFJZ0UsT0FBTztZQUNQLElBQUlDLFdBQVdyRixPQUFPLENBQUMsU0FBUyxDQUFDLEdBQzdCLE1BQU0sSUFBSTlSLE1BQU07WUFDcEIsSUFBSW1YLFdBQVdyRixPQUFPLENBQUMsU0FBUyxDQUFDLEdBQzdCLE1BQU0sSUFBSTlSLE1BQU07UUFDeEIsT0FDSztZQUNELElBQUl5WCxhQUFhO1lBQ2pCLElBQUlDLHFCQUFxQlAsV0FBV3JGLE9BQU8sQ0FBQztZQUM1QyxJQUFJNkYsbUJBQW1CO1lBQ3ZCLElBQUlELHVCQUF1QixDQUFDLEdBQUc7Z0JBQzNCQSxxQkFBcUJQLFdBQVdyRixPQUFPLENBQUM7Z0JBQ3hDMkYsYUFBYSxDQUFDO1lBQ2xCO1lBQ0EsSUFBSUMsdUJBQXVCLENBQUMsR0FBRztnQkFDM0JDLG1CQUFtQlIsV0FBVzFKLFNBQVMsQ0FBQ2lLLHFCQUFxQjtnQkFDN0RQLGFBQWFBLFdBQVcxSixTQUFTLENBQUMsR0FBR2lLO2dCQUNyQyxJQUFJLGlCQUFrQnBYLE1BQU0sS0FBSyxLQUFPcVgsaUJBQWlCclgsTUFBTSxLQUFLLEdBQ2hFLE1BQU0sSUFBSU4sTUFBTTtnQkFDcEIsSUFBSXdGLFNBQVMyTCxTQUFTd0csaUJBQWlCbEssU0FBUyxDQUFDLEdBQUcsSUFBSTtnQkFDeEQsSUFBSXdFLE1BQU16TSxPQUFPZ1MsT0FBTyxLQUNwQixNQUFNLElBQUl4WCxNQUFNO2dCQUNwQnNYLGlCQUFpQkcsYUFBYWpTO2dCQUM5QixJQUFJbVMsaUJBQWlCclgsTUFBTSxLQUFLLEdBQUc7b0JBQy9Ca0YsU0FBUzJMLFNBQVN3RyxpQkFBaUJsSyxTQUFTLENBQUMsR0FBRyxJQUFJO29CQUNwRCxJQUFJd0UsTUFBTXpNLE9BQU9nUyxPQUFPLEtBQ3BCLE1BQU0sSUFBSXhYLE1BQU07b0JBQ3BCdVgsbUJBQW1CRSxhQUFhalM7Z0JBQ3BDO1lBQ0o7UUFDSjtRQUNBLElBQUlvUyx3QkFBd0JULFdBQVdyRixPQUFPLENBQUM7UUFDL0MsSUFBSThGLDBCQUEwQixDQUFDLEdBQzNCQSx3QkFBd0JULFdBQVdyRixPQUFPLENBQUM7UUFDL0MsSUFBSThGLDBCQUEwQixDQUFDLEdBQUc7WUFDOUIsTUFBTUMsb0JBQW9CLElBQUkzRixPQUFPLENBQUMsQ0FBQyxFQUFFaUYsV0FBVzFKLFNBQVMsQ0FBQ21LLHVCQUF1QixDQUFDO1lBQ3RGLElBQUkzRixNQUFNNEYsa0JBQWtCTCxPQUFPLEtBQy9CLE1BQU0sSUFBSXhYLE1BQU07WUFDcEJxWCxlQUFlUSxrQkFBa0JMLE9BQU87WUFDeENKLGlCQUFpQkQsV0FBVzFKLFNBQVMsQ0FBQyxHQUFHbUs7UUFDN0MsT0FFSVIsaUJBQWlCRDtRQUNyQixPQUFRO1lBQ0osS0FBTUMsZUFBZTlXLE1BQU0sS0FBSztnQkFDNUJpVyxTQUFTO2dCQUNULElBQUlxQiwwQkFBMEIsQ0FBQyxHQUMzQixNQUFNLElBQUk1WCxNQUFNO2dCQUNwQjtZQUNKLEtBQU1vWCxlQUFlOVcsTUFBTSxLQUFLO2dCQUM1QmlXLFNBQVM7Z0JBQ1QsSUFBSXFCLDBCQUEwQixDQUFDLEdBQUc7b0JBQzlCLElBQUlFLGlCQUFpQixLQUFLVDtvQkFDMUIsSUFBSSxDQUFDNUIsTUFBTSxHQUFHc0MsS0FBS0MsS0FBSyxDQUFDRjtvQkFDekJBLGlCQUFpQixLQUFNQSxDQUFBQSxpQkFBaUIsSUFBSSxDQUFDckMsTUFBTTtvQkFDbkQsSUFBSSxDQUFDNUgsTUFBTSxHQUFHa0ssS0FBS0MsS0FBSyxDQUFDRjtvQkFDekJBLGlCQUFpQixPQUFRQSxDQUFBQSxpQkFBaUIsSUFBSSxDQUFDakssTUFBTTtvQkFDckQsSUFBSSxDQUFDa0osV0FBVyxHQUFHZ0IsS0FBS0MsS0FBSyxDQUFDRjtnQkFDbEM7Z0JBQ0E7WUFDSixLQUFNVixlQUFlOVcsTUFBTSxLQUFLO2dCQUM1QmlXLFNBQVM7Z0JBQ1QsSUFBSXFCLDBCQUEwQixDQUFDLEdBQUc7b0JBQzlCLElBQUlFLGlCQUFpQixLQUFLVDtvQkFDMUIsSUFBSSxDQUFDeEosTUFBTSxHQUFHa0ssS0FBS0MsS0FBSyxDQUFDRjtvQkFDekJBLGlCQUFpQixPQUFRQSxDQUFBQSxpQkFBaUIsSUFBSSxDQUFDakssTUFBTTtvQkFDckQsSUFBSSxDQUFDa0osV0FBVyxHQUFHZ0IsS0FBS0MsS0FBSyxDQUFDRjtnQkFDbEM7Z0JBQ0E7WUFDSixLQUFNVixlQUFlOVcsTUFBTSxLQUFLO2dCQUM1QmlXLFNBQVM7Z0JBQ1QsSUFBSXFCLDBCQUEwQixDQUFDLEdBQUc7b0JBQzlCLE1BQU1FLGlCQUFpQixPQUFPVDtvQkFDOUIsSUFBSSxDQUFDTixXQUFXLEdBQUdnQixLQUFLQyxLQUFLLENBQUNGO2dCQUNsQztnQkFDQTtZQUNKO2dCQUNJLE1BQU0sSUFBSTlYLE1BQU07UUFDeEI7UUFDQSxNQUFNd1csY0FBY0QsT0FBT0UsSUFBSSxDQUFDVztRQUNoQyxJQUFJWixnQkFBZ0IsTUFDaEIsTUFBTSxJQUFJeFcsTUFBTTtRQUNwQixJQUFLLElBQUl3VSxJQUFJLEdBQUdBLElBQUlnQyxZQUFZbFcsTUFBTSxFQUFFa1UsSUFBSztZQUN6QyxPQUFRQTtnQkFDSixLQUFLO29CQUNELElBQUksQ0FBQ2EsSUFBSSxHQUFHbEUsU0FBU3FGLFdBQVcsQ0FBQ2hDLEVBQUUsRUFBRTtvQkFDckM7Z0JBQ0osS0FBSztvQkFDRCxJQUFJLENBQUNjLEtBQUssR0FBR25FLFNBQVNxRixXQUFXLENBQUNoQyxFQUFFLEVBQUU7b0JBQ3RDO2dCQUNKLEtBQUs7b0JBQ0QsSUFBSSxDQUFDZSxHQUFHLEdBQUdwRSxTQUFTcUYsV0FBVyxDQUFDaEMsRUFBRSxFQUFFO29CQUNwQztnQkFDSixLQUFLO29CQUNELElBQUksQ0FBQ2dCLElBQUksR0FBR3JFLFNBQVNxRixXQUFXLENBQUNoQyxFQUFFLEVBQUUsTUFBTThDO29CQUMzQztnQkFDSixLQUFLO29CQUNELElBQUksQ0FBQzdCLE1BQU0sR0FBR3RFLFNBQVNxRixXQUFXLENBQUNoQyxFQUFFLEVBQUUsTUFBTStDO29CQUM3QztnQkFDSixLQUFLO29CQUNELElBQUksQ0FBQzFKLE1BQU0sR0FBR3NELFNBQVNxRixXQUFXLENBQUNoQyxFQUFFLEVBQUU7b0JBQ3ZDO2dCQUNKO29CQUNJLE1BQU0sSUFBSXhVLE1BQU07WUFDeEI7UUFDSjtRQUNBLElBQUlrWCxVQUFVLE9BQU87WUFDakIsTUFBTWUsV0FBVyxJQUFJNUIsS0FBSyxJQUFJLENBQUNoQixJQUFJLEVBQUUsSUFBSSxDQUFDQyxLQUFLLEVBQUUsSUFBSSxDQUFDQyxHQUFHLEVBQUUsSUFBSSxDQUFDQyxJQUFJLEVBQUUsSUFBSSxDQUFDQyxNQUFNLEVBQUUsSUFBSSxDQUFDNUgsTUFBTSxFQUFFLElBQUksQ0FBQ2tKLFdBQVc7WUFDaEgsSUFBSSxDQUFDMUIsSUFBSSxHQUFHNEMsU0FBU25DLGNBQWM7WUFDbkMsSUFBSSxDQUFDUixLQUFLLEdBQUcyQyxTQUFTbEMsV0FBVztZQUNqQyxJQUFJLENBQUNSLEdBQUcsR0FBRzBDLFNBQVNDLFNBQVM7WUFDN0IsSUFBSSxDQUFDMUMsSUFBSSxHQUFHeUMsU0FBU2hDLFdBQVc7WUFDaEMsSUFBSSxDQUFDUixNQUFNLEdBQUd3QyxTQUFTL0IsYUFBYTtZQUNwQyxJQUFJLENBQUNySSxNQUFNLEdBQUdvSyxTQUFTOUIsYUFBYTtZQUNwQyxJQUFJLENBQUNZLFdBQVcsR0FBR2tCLFNBQVNqQixrQkFBa0I7UUFDbEQ7SUFDSjtJQUNBblAsU0FBU0MsV0FBVyxLQUFLLEVBQUU7UUFDdkIsSUFBSUEsYUFBYSxPQUFPO1lBQ3BCLE1BQU00TyxjQUFjLEVBQUU7WUFDdEJBLFlBQVluVixJQUFJLENBQUMxQixtQkFBbUIrVyxTQUFTLENBQUMsSUFBSSxDQUFDdkIsSUFBSSxFQUFFO1lBQ3pEcUIsWUFBWW5WLElBQUksQ0FBQzFCLG1CQUFtQitXLFNBQVMsQ0FBQyxJQUFJLENBQUN0QixLQUFLLEVBQUU7WUFDMURvQixZQUFZblYsSUFBSSxDQUFDMUIsbUJBQW1CK1csU0FBUyxDQUFDLElBQUksQ0FBQ3JCLEdBQUcsRUFBRTtZQUN4RG1CLFlBQVluVixJQUFJLENBQUMxQixtQkFBbUIrVyxTQUFTLENBQUMsSUFBSSxDQUFDcEIsSUFBSSxFQUFFO1lBQ3pEa0IsWUFBWW5WLElBQUksQ0FBQzFCLG1CQUFtQitXLFNBQVMsQ0FBQyxJQUFJLENBQUNuQixNQUFNLEVBQUU7WUFDM0RpQixZQUFZblYsSUFBSSxDQUFDMUIsbUJBQW1CK1csU0FBUyxDQUFDLElBQUksQ0FBQy9JLE1BQU0sRUFBRTtZQUMzRCxJQUFJLElBQUksQ0FBQ2tKLFdBQVcsS0FBSyxHQUFHO2dCQUN4QkwsWUFBWW5WLElBQUksQ0FBQztnQkFDakJtVixZQUFZblYsSUFBSSxDQUFDMUIsbUJBQW1CK1csU0FBUyxDQUFDLElBQUksQ0FBQ0csV0FBVyxFQUFFO1lBQ3BFO1lBQ0FMLFlBQVluVixJQUFJLENBQUM7WUFDakIsT0FBT21WLFlBQVl6SyxJQUFJLENBQUM7UUFDNUI7UUFDQSxPQUFPLEtBQUssQ0FBQ3BFLFNBQVNDO0lBQzFCO0lBQ0E1RCxTQUFTO1FBQ0wsT0FBTztZQUNILEdBQUcsS0FBSyxDQUFDQSxRQUFRO1lBQ2pCNlMsYUFBYSxJQUFJLENBQUNBLFdBQVc7UUFDakM7SUFDSjtBQUNKO0FBQ0FELE9BQU9sTTtBQUNOO0lBQ0c5RCxVQUFVOEQsZUFBZSxHQUFHa007QUFDaEM7QUFDQWxNLGdCQUFnQmpKLElBQUksR0FBRztBQUV2QixJQUFJd1c7QUFDSixNQUFNaE4sYUFBYWxCO0lBQ2Y5SSxZQUFZZ0csYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbEMsT0FBTyxDQUFDRyxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSCxPQUFPLENBQUNJLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0E4UyxPQUFPaE47QUFDTjtJQUNHckUsVUFBVXFFLElBQUksR0FBR2dOO0FBQ3JCO0FBQ0FoTixLQUFLeEosSUFBSSxHQUFHO0FBRVosSUFBSXlXO0FBQ0osTUFBTWhOLGtCQUFrQm5CO0lBQ3BCOUksWUFBWWdHLGFBQWEsQ0FBQyxDQUFDLENBQUU7UUFDekIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ2xDLE9BQU8sQ0FBQ0csUUFBUSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxTQUFTLEdBQUc7SUFDN0I7QUFDSjtBQUNBK1MsT0FBT2hOO0FBQ047SUFDR3RFLFVBQVVzRSxTQUFTLEdBQUdnTjtBQUMxQjtBQUNBaE4sVUFBVXpKLElBQUksR0FBRztBQUVqQixJQUFJMFc7QUFDSixNQUFNaE4saUJBQWlCcEI7SUFDbkI5SSxZQUFZZ0csYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbEMsT0FBTyxDQUFDRyxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSCxPQUFPLENBQUNJLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0FnVCxPQUFPaE47QUFDTjtJQUNHdkUsVUFBVXVFLFFBQVEsR0FBR2dOO0FBQ3pCO0FBQ0FoTixTQUFTMUosSUFBSSxHQUFHO0FBRWhCLElBQUkyVztBQUNKLE1BQU1oTixpQkFBaUJyQjtJQUNuQjlJLFlBQVlnRyxhQUFhLENBQUMsQ0FBQyxDQUFFO1FBQ3pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNsQyxPQUFPLENBQUNHLFFBQVEsR0FBRztRQUN4QixJQUFJLENBQUNILE9BQU8sQ0FBQ0ksU0FBUyxHQUFHO0lBQzdCO0FBQ0o7QUFDQWlULE9BQU9oTjtBQUNOO0lBQ0d4RSxVQUFVd0UsUUFBUSxHQUFHZ047QUFDekI7QUFDQWhOLFNBQVMzSixJQUFJLEdBQUc7QUFFaEIsSUFBSW1CO0FBQ0osTUFBTXFILGFBQWFGO0lBQ2Y5SSxZQUFZZ0csYUFBYSxDQUFDLENBQUMsQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDbEMsT0FBTyxDQUFDRyxRQUFRLEdBQUc7UUFDeEIsSUFBSSxDQUFDSCxPQUFPLENBQUNJLFNBQVMsR0FBRztJQUM3QjtBQUNKO0FBQ0F2QyxLQUFLcUg7QUFDSjtJQUNHckQsVUFBVXFELElBQUksR0FBR3JIO0FBQ3JCO0FBQ0FxSCxLQUFLeEksSUFBSSxHQUFHO0FBRVosTUFBTTRXO0lBQ0ZwWCxZQUFZLEVBQUU2RixPQUFPM0UsWUFBWSxFQUFFNEUsV0FBVyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUN4RCxJQUFJLENBQUNELElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLFFBQVEsR0FBR0E7SUFDcEI7QUFDSjtBQUVBLE1BQU11UixlQUFlRDtJQUNqQnBYLFlBQVksRUFBRWdDLFFBQVEsRUFBRSxFQUFFLEdBQUdnRSxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDNUMsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ2hFLEtBQUssR0FBR0E7SUFDakI7QUFDSjtBQUVBLE1BQU1zVixpQkFBaUJGO0lBQ25CcFgsWUFBWSxFQUFFZ0MsUUFBUSxJQUFJb1YsS0FBSyxFQUFFRyxRQUFRLEtBQUssRUFBRSxHQUFHdlIsWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ2xFLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNoRSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDdVYsS0FBSyxHQUFHQTtJQUNqQjtBQUNKO0FBRUEsTUFBTUM7SUFDRixJQUFJQyxPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUNDLFFBQVEsQ0FBQzNWLEtBQUssR0FBRzNDLE1BQU07SUFDdkM7SUFDQSxJQUFJcVksS0FBS3pWLEtBQUssRUFBRTtRQUNaLElBQUksQ0FBQzBWLFFBQVEsR0FBR2paLHFCQUFxQjRELHFCQUFxQixDQUFDQyxZQUFZLENBQUNOO0lBQzVFO0lBQ0FoQyxZQUFZLEVBQUV5WCxPQUFPcFcsVUFBVSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDcEMsSUFBSSxDQUFDcVcsUUFBUSxHQUFHaloscUJBQXFCNEQscUJBQXFCLENBQUNDLFlBQVksQ0FBQ21WO0lBQzVFO0lBQ0FsVixRQUFRNUMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUMzQyxNQUFNNEMsWUFBWTdDLGNBQWNDO1FBQ2hDLElBQUksQ0FBQzZYLFFBQVEsR0FBR2paLHFCQUFxQjRELHFCQUFxQixDQUFDQyxZQUFZLENBQUMzQyxhQUFhK0MsUUFBUSxDQUFDOUMsYUFBYTZDO1FBQzNHLE9BQU9BO0lBQ1g7SUFDQUksTUFBTWMsU0FBUyxFQUFFO1FBQ2IsT0FBTyxJQUFJLENBQUMrVCxRQUFRLENBQUMzVixLQUFLLEdBQUczQyxNQUFNO0lBQ3ZDO0FBQ0o7QUFFQSxTQUFTdVksY0FBY0MsSUFBSSxFQUFFQyxTQUFTLEVBQUVDLFdBQVc7SUFDL0MsSUFBSUEsdUJBQXVCVCxRQUFRO1FBQy9CLEtBQUssTUFBTVUsV0FBV0QsWUFBWTlWLEtBQUssQ0FBRTtZQUNyQyxNQUFNb0csU0FBU3VQLGNBQWNDLE1BQU1DLFdBQVdFO1lBQzlDLElBQUkzUCxPQUFPNFAsUUFBUSxFQUFFO2dCQUNqQixPQUFPO29CQUNIQSxVQUFVO29CQUNWNVAsUUFBUXdQO2dCQUNaO1lBQ0o7UUFDSjtRQUNBO1lBQ0ksTUFBTUssVUFBVTtnQkFDWkQsVUFBVTtnQkFDVjVQLFFBQVE7b0JBQUV0SSxPQUFPO2dCQUErQjtZQUNwRDtZQUNBLElBQUlnWSxZQUFZSSxjQUFjLENBQUMxWCxPQUMzQnlYLFFBQVFwUyxJQUFJLEdBQUdpUyxZQUFZalMsSUFBSTtZQUNuQyxPQUFPb1M7UUFDWDtJQUNKO0lBQ0EsSUFBSUgsdUJBQXVCVixLQUFLO1FBQzVCLElBQUlVLFlBQVlJLGNBQWMsQ0FBQzFYLE9BQzNCb1gsSUFBSSxDQUFDRSxZQUFZalMsSUFBSSxDQUFDLEdBQUdnUztRQUM3QixPQUFPO1lBQ0hHLFVBQVU7WUFDVjVQLFFBQVF3UDtRQUNaO0lBQ0o7SUFDQSxJQUFJLGdCQUFpQi9aLFdBQVksT0FBTztRQUNwQyxPQUFPO1lBQ0htYSxVQUFVO1lBQ1Y1UCxRQUFRO2dCQUFFdEksT0FBTztZQUFvQjtRQUN6QztJQUNKO0lBQ0EsSUFBSSxxQkFBc0JqQyxXQUFZLE9BQU87UUFDekMsT0FBTztZQUNIbWEsVUFBVTtZQUNWNVAsUUFBUTtnQkFBRXRJLE9BQU87WUFBbUI7UUFDeEM7SUFDSjtJQUNBLElBQUksdUJBQXdCakMsV0FBWSxPQUFPO1FBQzNDLE9BQU87WUFDSG1hLFVBQVU7WUFDVjVQLFFBQVE7Z0JBQUV0SSxPQUFPO1lBQXFCO1FBQzFDO0lBQ0o7SUFDQSxJQUFJLFlBQWFnWSxnQkFBaUIsT0FBTztRQUNyQyxPQUFPO1lBQ0hFLFVBQVU7WUFDVjVQLFFBQVE7Z0JBQUV0SSxPQUFPO1lBQXFCO1FBQzFDO0lBQ0o7SUFDQSxJQUFJLFlBQWFnWSxZQUFZaFUsT0FBTyxLQUFNLE9BQU87UUFDN0MsT0FBTztZQUNIa1UsVUFBVTtZQUNWNVAsUUFBUTtnQkFBRXRJLE9BQU87WUFBcUI7UUFDMUM7SUFDSjtJQUNBLElBQUksVUFBV2dZLFlBQVloVSxPQUFPLEtBQU0sT0FBTztRQUMzQyxPQUFPO1lBQ0hrVSxVQUFVO1lBQ1Y1UCxRQUFRO2dCQUFFdEksT0FBTztZQUFxQjtRQUMxQztJQUNKO0lBQ0EsTUFBTXFZLFlBQVlMLFlBQVloVSxPQUFPLENBQUNqQixLQUFLLENBQUM7SUFDNUMsSUFBSXNWLFVBQVU5WSxVQUFVLEtBQUssR0FBRztRQUM1QixPQUFPO1lBQ0gyWSxVQUFVO1lBQ1Y1UCxRQUFRO2dCQUFFdEksT0FBTztZQUEwQztRQUMvRDtJQUNKO0lBQ0EsTUFBTXNZLGdCQUFnQk4sWUFBWWhVLE9BQU8sQ0FBQ3ZCLE9BQU8sQ0FBQzRWLFdBQVcsR0FBR0EsVUFBVTlZLFVBQVU7SUFDcEYsSUFBSStZLGtCQUFrQixDQUFDLEdBQUc7UUFDdEIsT0FBTztZQUNISixVQUFVO1lBQ1Y1UCxRQUFRO2dCQUFFdEksT0FBTztZQUEwQztRQUMvRDtJQUNKO0lBQ0EsSUFBSWdZLFlBQVloVSxPQUFPLENBQUNvVSxjQUFjLENBQUN0WCxlQUFlLE9BQU87UUFDekQsT0FBTztZQUNIb1gsVUFBVTtZQUNWNVAsUUFBUTtnQkFBRXRJLE9BQU87WUFBcUI7UUFDMUM7SUFDSjtJQUNBLElBQUlnWSxZQUFZaFUsT0FBTyxDQUFDRyxRQUFRLEtBQUs0VCxVQUFVL1QsT0FBTyxDQUFDRyxRQUFRLEVBQUU7UUFDN0QsT0FBTztZQUNIK1QsVUFBVTtZQUNWNVAsUUFBUXdQO1FBQ1o7SUFDSjtJQUNBLElBQUlFLFlBQVloVSxPQUFPLENBQUNvVSxjQUFjLENBQUNyWCxnQkFBZ0IsT0FBTztRQUMxRCxPQUFPO1lBQ0htWCxVQUFVO1lBQ1Y1UCxRQUFRO2dCQUFFdEksT0FBTztZQUFxQjtRQUMxQztJQUNKO0lBQ0EsSUFBSWdZLFlBQVloVSxPQUFPLENBQUNJLFNBQVMsS0FBSzJULFVBQVUvVCxPQUFPLENBQUNJLFNBQVMsRUFBRTtRQUMvRCxPQUFPO1lBQ0g4VCxVQUFVO1lBQ1Y1UCxRQUFRd1A7UUFDWjtJQUNKO0lBQ0EsSUFBSUUsWUFBWWhVLE9BQU8sQ0FBQ29VLGNBQWMsQ0FBQ3BYLG9CQUFvQixPQUFPO1FBQzlELE9BQU87WUFDSGtYLFVBQVU7WUFDVjVQLFFBQVE7Z0JBQUV0SSxPQUFPO1lBQXFCO1FBQzFDO0lBQ0o7SUFDQSxJQUFJZ1ksWUFBWWhVLE9BQU8sQ0FBQ0ssYUFBYSxLQUFLMFQsVUFBVS9ULE9BQU8sQ0FBQ0ssYUFBYSxFQUFFO1FBQ3ZFLE9BQU87WUFDSDZULFVBQVU7WUFDVjVQLFFBQVF3UDtRQUNaO0lBQ0o7SUFDQSxJQUFJLENBQUVsWCxDQUFBQSxlQUFlb1gsWUFBWWhVLE9BQU8sR0FBRztRQUN2QyxPQUFPO1lBQ0hrVSxVQUFVO1lBQ1Y1UCxRQUFRO2dCQUFFdEksT0FBTztZQUFxQjtRQUMxQztJQUNKO0lBQ0EsSUFBSWdZLFlBQVloVSxPQUFPLENBQUMxQixTQUFTLEtBQUt5VixVQUFVL1QsT0FBTyxDQUFDMUIsU0FBUyxFQUFFO1FBQy9ELE9BQU87WUFDSDRWLFVBQVU7WUFDVjVQLFFBQVF3UDtRQUNaO0lBQ0o7SUFDQSxJQUFJRSxZQUFZaFUsT0FBTyxDQUFDMUIsU0FBUyxFQUFFO1FBQy9CLElBQUksa0JBQW1CMFYsWUFBWWhVLE9BQU8sS0FBTSxPQUFPO1lBQ25ELE9BQU87Z0JBQ0hrVSxVQUFVO2dCQUNWNVAsUUFBUTtvQkFBRXRJLE9BQU87Z0JBQXFCO1lBQzFDO1FBQ0o7UUFDQSxNQUFNdVksYUFBYVAsWUFBWWhVLE9BQU8sQ0FBQ2hDLFlBQVk7UUFDbkQsTUFBTTJNLFdBQVdvSixVQUFVL1QsT0FBTyxDQUFDaEMsWUFBWTtRQUMvQyxJQUFJdVcsV0FBV2xaLE1BQU0sS0FBS3NQLFNBQVN0UCxNQUFNLEVBQUU7WUFDdkMsT0FBTztnQkFDSDZZLFVBQVU7Z0JBQ1Y1UCxRQUFRd1A7WUFDWjtRQUNKO1FBQ0EsSUFBSyxJQUFJMVksSUFBSSxHQUFHQSxJQUFJbVosV0FBV2xaLE1BQU0sRUFBRUQsSUFBSztZQUN4QyxJQUFJbVosVUFBVSxDQUFDblosRUFBRSxLQUFLdVAsUUFBUSxDQUFDLEVBQUUsRUFBRTtnQkFDL0IsT0FBTztvQkFDSHVKLFVBQVU7b0JBQ1Y1UCxRQUFRd1A7Z0JBQ1o7WUFDSjtRQUNKO0lBQ0o7SUFDQSxJQUFJRSxZQUFZalMsSUFBSSxFQUFFO1FBQ2xCaVMsWUFBWWpTLElBQUksR0FBR2lTLFlBQVlqUyxJQUFJLENBQUNxSixPQUFPLENBQUMsY0FBY2hPO1FBQzFELElBQUk0VyxZQUFZalMsSUFBSSxFQUNoQitSLElBQUksQ0FBQ0UsWUFBWWpTLElBQUksQ0FBQyxHQUFHZ1M7SUFDakM7SUFDQSxJQUFJQyx1QkFBdUJuUyxVQUFVdUIsV0FBVyxFQUFFO1FBQzlDLElBQUlvUixZQUFZO1FBQ2hCLElBQUlsUSxTQUFTO1lBQ1Q0UCxVQUFVO1lBQ1Y1UCxRQUFRO2dCQUFFdEksT0FBTztZQUFnQjtRQUNyQztRQUNBLElBQUl5WSxZQUFZVCxZQUFZNVIsVUFBVSxDQUFDbEUsS0FBSyxDQUFDN0MsTUFBTTtRQUNuRCxJQUFJb1osWUFBWSxHQUFHO1lBQ2YsSUFBSVQsWUFBWTVSLFVBQVUsQ0FBQ2xFLEtBQUssQ0FBQyxFQUFFLFlBQVlzVixVQUFVO2dCQUNyRGlCLFlBQVlWLFVBQVUzUixVQUFVLENBQUNsRSxLQUFLLENBQUM3QyxNQUFNO1lBQ2pEO1FBQ0o7UUFDQSxJQUFJb1osY0FBYyxHQUFHO1lBQ2pCLE9BQU87Z0JBQ0hQLFVBQVU7Z0JBQ1Y1UCxRQUFRd1A7WUFDWjtRQUNKO1FBQ0EsSUFBSSxVQUFXMVIsVUFBVSxDQUFDbEUsS0FBSyxDQUFDN0MsTUFBTSxLQUFLLEtBQ25DMlksWUFBWTVSLFVBQVUsQ0FBQ2xFLEtBQUssQ0FBQzdDLE1BQU0sS0FBSyxHQUFJO1lBQ2hELElBQUlxWixZQUFZO1lBQ2hCLElBQUssSUFBSXRaLElBQUksR0FBR0EsSUFBSTRZLFlBQVk1UixVQUFVLENBQUNsRSxLQUFLLENBQUM3QyxNQUFNLEVBQUVELElBQ3JEc1osWUFBWUEsYUFBY1YsQ0FBQUEsWUFBWTVSLFVBQVUsQ0FBQ2xFLEtBQUssQ0FBQzlDLEVBQUUsQ0FBQzRHLFFBQVEsSUFBSSxLQUFJO1lBQzlFLElBQUkwUyxXQUFXO2dCQUNYLE9BQU87b0JBQ0hSLFVBQVU7b0JBQ1Y1UCxRQUFRd1A7Z0JBQ1o7WUFDSjtZQUNBLElBQUlFLFlBQVlqUyxJQUFJLEVBQUU7Z0JBQ2xCaVMsWUFBWWpTLElBQUksR0FBR2lTLFlBQVlqUyxJQUFJLENBQUNxSixPQUFPLENBQUMsY0FBY2hPO2dCQUMxRCxJQUFJNFcsWUFBWWpTLElBQUksRUFDaEIsT0FBTytSLElBQUksQ0FBQ0UsWUFBWWpTLElBQUksQ0FBQztZQUNyQztZQUNBK1IsS0FBSzlYLEtBQUssR0FBRztZQUNiLE9BQU87Z0JBQ0hrWSxVQUFVO2dCQUNWNVAsUUFBUXdQO1lBQ1o7UUFDSjtRQUNBLElBQUssSUFBSTFZLElBQUksR0FBR0EsSUFBSXFaLFdBQVdyWixJQUFLO1lBQ2hDLElBQUksSUFBS29aLGFBQWNULFVBQVUzUixVQUFVLENBQUNsRSxLQUFLLENBQUM3QyxNQUFNLEVBQUU7Z0JBQ3RELElBQUkyWSxZQUFZNVIsVUFBVSxDQUFDbEUsS0FBSyxDQUFDOUMsRUFBRSxDQUFDNEcsUUFBUSxLQUFLLE9BQU87b0JBQ3BELE1BQU1tUyxVQUFVO3dCQUNaRCxVQUFVO3dCQUNWNVAsUUFBUXdQO29CQUNaO29CQUNBQSxLQUFLOVgsS0FBSyxHQUFHO29CQUNiLElBQUlnWSxZQUFZalMsSUFBSSxFQUFFO3dCQUNsQmlTLFlBQVlqUyxJQUFJLEdBQUdpUyxZQUFZalMsSUFBSSxDQUFDcUosT0FBTyxDQUFDLGNBQWNoTzt3QkFDMUQsSUFBSTRXLFlBQVlqUyxJQUFJLEVBQUU7NEJBQ2xCLE9BQU8rUixJQUFJLENBQUNFLFlBQVlqUyxJQUFJLENBQUM7NEJBQzdCb1MsUUFBUXBTLElBQUksR0FBR2lTLFlBQVlqUyxJQUFJO3dCQUNuQztvQkFDSjtvQkFDQSxPQUFPb1M7Z0JBQ1g7WUFDSixPQUNLO2dCQUNELElBQUlILFlBQVk1UixVQUFVLENBQUNsRSxLQUFLLENBQUMsRUFBRSxZQUFZc1YsVUFBVTtvQkFDckRsUCxTQUFTdVAsY0FBY0MsTUFBTUMsVUFBVTNSLFVBQVUsQ0FBQ2xFLEtBQUssQ0FBQzlDLEVBQUUsRUFBRTRZLFlBQVk1UixVQUFVLENBQUNsRSxLQUFLLENBQUMsRUFBRSxDQUFDQSxLQUFLO29CQUNqRyxJQUFJb0csT0FBTzRQLFFBQVEsS0FBSyxPQUFPO3dCQUMzQixJQUFJRixZQUFZNVIsVUFBVSxDQUFDbEUsS0FBSyxDQUFDLEVBQUUsQ0FBQzhELFFBQVEsRUFDeEN3Uzs2QkFDQzs0QkFDRCxJQUFJUixZQUFZalMsSUFBSSxFQUFFO2dDQUNsQmlTLFlBQVlqUyxJQUFJLEdBQUdpUyxZQUFZalMsSUFBSSxDQUFDcUosT0FBTyxDQUFDLGNBQWNoTztnQ0FDMUQsSUFBSTRXLFlBQVlqUyxJQUFJLEVBQ2hCLE9BQU8rUixJQUFJLENBQUNFLFlBQVlqUyxJQUFJLENBQUM7NEJBQ3JDOzRCQUNBLE9BQU91Qzt3QkFDWDtvQkFDSjtvQkFDQSxJQUFJLFFBQVMwUCxZQUFZNVIsVUFBVSxDQUFDbEUsS0FBSyxDQUFDLEVBQUUsSUFBTThWLFlBQVk1UixVQUFVLENBQUNsRSxLQUFLLENBQUMsRUFBRSxDQUFDNkQsSUFBSSxDQUFDMUcsTUFBTSxHQUFHLEdBQUk7d0JBQ2hHLElBQUlzWixZQUFZLENBQUM7d0JBQ2pCLElBQUksU0FBVVgsWUFBWTVSLFVBQVUsQ0FBQ2xFLEtBQUssQ0FBQyxFQUFFLElBQU04VixZQUFZNVIsVUFBVSxDQUFDbEUsS0FBSyxDQUFDLEVBQUUsQ0FBQ3VWLEtBQUssRUFDcEZrQixZQUFZWjs2QkFFWlksWUFBWWI7d0JBQ2hCLElBQUksT0FBT2EsU0FBUyxDQUFDWCxZQUFZNVIsVUFBVSxDQUFDbEUsS0FBSyxDQUFDLEVBQUUsQ0FBQzZELElBQUksQ0FBQyxLQUFLLGFBQzNENFMsU0FBUyxDQUFDWCxZQUFZNVIsVUFBVSxDQUFDbEUsS0FBSyxDQUFDLEVBQUUsQ0FBQzZELElBQUksQ0FBQyxHQUFHLEVBQUU7d0JBQ3hENFMsU0FBUyxDQUFDWCxZQUFZNVIsVUFBVSxDQUFDbEUsS0FBSyxDQUFDLEVBQUUsQ0FBQzZELElBQUksQ0FBQyxDQUFDekYsSUFBSSxDQUFDeVgsVUFBVTNSLFVBQVUsQ0FBQ2xFLEtBQUssQ0FBQzlDLEVBQUU7b0JBQ3RGO2dCQUNKLE9BQ0s7b0JBQ0RrSixTQUFTdVAsY0FBY0MsTUFBTUMsVUFBVTNSLFVBQVUsQ0FBQ2xFLEtBQUssQ0FBQzlDLElBQUlvWixVQUFVLEVBQUVSLFlBQVk1UixVQUFVLENBQUNsRSxLQUFLLENBQUM5QyxFQUFFO29CQUN2RyxJQUFJa0osT0FBTzRQLFFBQVEsS0FBSyxPQUFPO3dCQUMzQixJQUFJRixZQUFZNVIsVUFBVSxDQUFDbEUsS0FBSyxDQUFDOUMsRUFBRSxDQUFDNEcsUUFBUSxFQUN4Q3dTOzZCQUNDOzRCQUNELElBQUlSLFlBQVlqUyxJQUFJLEVBQUU7Z0NBQ2xCaVMsWUFBWWpTLElBQUksR0FBR2lTLFlBQVlqUyxJQUFJLENBQUNxSixPQUFPLENBQUMsY0FBY2hPO2dDQUMxRCxJQUFJNFcsWUFBWWpTLElBQUksRUFDaEIsT0FBTytSLElBQUksQ0FBQ0UsWUFBWWpTLElBQUksQ0FBQzs0QkFDckM7NEJBQ0EsT0FBT3VDO3dCQUNYO29CQUNKO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLElBQUlBLE9BQU80UCxRQUFRLEtBQUssT0FBTztZQUMzQixNQUFNQyxVQUFVO2dCQUNaRCxVQUFVO2dCQUNWNVAsUUFBUXdQO1lBQ1o7WUFDQSxJQUFJRSxZQUFZalMsSUFBSSxFQUFFO2dCQUNsQmlTLFlBQVlqUyxJQUFJLEdBQUdpUyxZQUFZalMsSUFBSSxDQUFDcUosT0FBTyxDQUFDLGNBQWNoTztnQkFDMUQsSUFBSTRXLFlBQVlqUyxJQUFJLEVBQUU7b0JBQ2xCLE9BQU8rUixJQUFJLENBQUNFLFlBQVlqUyxJQUFJLENBQUM7b0JBQzdCb1MsUUFBUXBTLElBQUksR0FBR2lTLFlBQVlqUyxJQUFJO2dCQUNuQztZQUNKO1lBQ0EsT0FBT29TO1FBQ1g7UUFDQSxPQUFPO1lBQ0hELFVBQVU7WUFDVjVQLFFBQVF3UDtRQUNaO0lBQ0o7SUFDQSxJQUFJRSxZQUFZL1IsZUFBZSxJQUN2QnRGLGtCQUFrQm9YLFVBQVUzUixVQUFVLEVBQUc7UUFDN0MsTUFBTXdTLE9BQU8xUSxhQUFhNlAsVUFBVTNSLFVBQVUsQ0FBQ3BFLFlBQVk7UUFDM0QsSUFBSTRXLEtBQUt2USxNQUFNLEtBQUssQ0FBQyxHQUFHO1lBQ3BCLE1BQU04UCxVQUFVO2dCQUNaRCxVQUFVO2dCQUNWNVAsUUFBUXNRLEtBQUt0USxNQUFNO1lBQ3ZCO1lBQ0EsSUFBSTBQLFlBQVlqUyxJQUFJLEVBQUU7Z0JBQ2xCaVMsWUFBWWpTLElBQUksR0FBR2lTLFlBQVlqUyxJQUFJLENBQUNxSixPQUFPLENBQUMsY0FBY2hPO2dCQUMxRCxJQUFJNFcsWUFBWWpTLElBQUksRUFBRTtvQkFDbEIsT0FBTytSLElBQUksQ0FBQ0UsWUFBWWpTLElBQUksQ0FBQztvQkFDN0JvUyxRQUFRcFMsSUFBSSxHQUFHaVMsWUFBWWpTLElBQUk7Z0JBQ25DO1lBQ0o7WUFDQSxPQUFPb1M7UUFDWDtRQUNBLE9BQU9OLGNBQWNDLE1BQU1jLEtBQUt0USxNQUFNLEVBQUUwUCxZQUFZL1IsZUFBZTtJQUN2RTtJQUNBLE9BQU87UUFDSGlTLFVBQVU7UUFDVjVQLFFBQVF3UDtJQUNaO0FBQ0o7QUFDQSxTQUFTZSxhQUFhaFosV0FBVyxFQUFFbVksV0FBVztJQUMxQyxJQUFJLHVCQUF3QmphLFdBQVksT0FBTztRQUMzQyxPQUFPO1lBQ0htYSxVQUFVO1lBQ1Y1UCxRQUFRO2dCQUFFdEksT0FBTztZQUEwQjtRQUMvQztJQUNKO0lBQ0EsTUFBTTRZLE9BQU8xUSxhQUFhdkoscUJBQXFCNEQscUJBQXFCLENBQUNDLFlBQVksQ0FBQzNDO0lBQ2xGLElBQUkrWSxLQUFLdlEsTUFBTSxLQUFLLENBQUMsR0FBRztRQUNwQixPQUFPO1lBQ0g2UCxVQUFVO1lBQ1Y1UCxRQUFRc1EsS0FBS3RRLE1BQU07UUFDdkI7SUFDSjtJQUNBLE9BQU91UCxjQUFjZSxLQUFLdFEsTUFBTSxFQUFFc1EsS0FBS3RRLE1BQU0sRUFBRTBQO0FBQ25EO0FBRUFjLFdBQVcsR0FBR3hCO0FBQ2R3QixpQkFBaUIsR0FBR2hUO0FBQ3BCZ1QsdUJBQXVCLEdBQUd6UjtBQUMxQnlSLGlCQUFpQixHQUFHblE7QUFDcEJtUSxpQkFBaUIsR0FBRzdPO0FBQ3BCNk8sZUFBZSxHQUFHclE7QUFDbEJxUSx1QkFBdUIsR0FBRzlPO0FBQzFCOE8sY0FBYyxHQUFHdkI7QUFDakJ1QixtQkFBbUIsR0FBRzFSO0FBQ3RCMFIsWUFBWSxHQUFHNU87QUFDZjRPLGdCQUFnQixHQUFHMU87QUFDbkIwTyxnQkFBZ0IsR0FBR3pPO0FBQ25CeU8sb0JBQW9CLEdBQUd0UTtBQUN2QnNRLGtCQUFrQixHQUFHL1A7QUFDckIrUCxxQkFBcUIsR0FBR2hQO0FBQ3hCZ1AsdUJBQXVCLEdBQUduUDtBQUMxQm1QLHFCQUFxQixHQUFHbFA7QUFDeEJrUCxnQkFBZ0IsR0FBR25YO0FBQ25CbVgsaUJBQWlCLEdBQUdyUDtBQUNwQnFQLGVBQWUsR0FBR3BRO0FBQ2xCb1EsWUFBWSxHQUFHalE7QUFDZmlRLHFCQUFxQixHQUFHelA7QUFDeEJ5UCx3QkFBd0IsR0FBR2hRO0FBQzNCZ1EsbUJBQW1CLEdBQUdsUTtBQUN0QmtRLGlCQUFpQixHQUFHalI7QUFDcEJpUix1QkFBdUIsR0FBR3hQO0FBQzFCd1AsZUFBZSxHQUFHcEI7QUFDbEJvQixnQ0FBZ0MsR0FBRzdQO0FBQ25DNlAsZ0JBQWdCLEdBQUd0QjtBQUNuQnNCLGdCQUFnQixHQUFHM1A7QUFDbkIyUCxXQUFXLEdBQUcxUDtBQUNkMFAsWUFBWSxHQUFHNVA7QUFDZjRQLHFCQUFxQixHQUFHdlA7QUFDeEJ1UCxpQkFBaUIsR0FBRzNPO0FBQ3BCMk8sZUFBZSxHQUFHcFA7QUFDbEJvUCx1QkFBdUIsR0FBRy9PO0FBQzFCK08sa0JBQWtCLEdBQUc5UDtBQUNyQjhQLGtCQUFrQixHQUFHdFY7QUFDckJzVixzQkFBc0IsR0FBR3RQO0FBQ3pCc1Asa0JBQWtCLEdBQUc3WTtBQUNyQjZZLHFCQUFxQixHQUFHalA7QUFDeEJpUCxxQkFBcUIsR0FBR2pCO0FBQ3hCaUIsZUFBZSxHQUFHclc7QUFDbEJxVyxvQkFBb0IsR0FBR0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYXNuMWpzL2J1aWxkL2luZGV4LmpzP2NhODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEdNTyBHbG9iYWxTaWduXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAyMiwgUGVjdWxpYXIgVmVudHVyZXNcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBcbiAqIEF1dGhvciAyMDE0LTIwMTksIFl1cnkgU3Ryb3poZXZza3lcbiAqIFxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqIFxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiBcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vclxuICogICBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqICAgdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqIFxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbiAqIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICogKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICogTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG4gKiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHZ0c3V0aWxzID0gcmVxdWlyZSgncHZ0c3V0aWxzJyk7XG52YXIgcHZ1dGlscyA9IHJlcXVpcmUoJ3B2dXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGUpIHtcbiAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG4uZGVmYXVsdCA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgcHZ0c3V0aWxzX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KHB2dHN1dGlscyk7XG52YXIgcHZ1dGlsc19fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChwdnV0aWxzKTtcblxuZnVuY3Rpb24gYXNzZXJ0QmlnSW50KCkge1xuICAgIGlmICh0eXBlb2YgQmlnSW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJpZ0ludCBpcyBub3QgZGVmaW5lZC4gWW91ciBlbnZpcm9ubWVudCBkb2Vzbid0IGltcGxlbWVudCBCaWdJbnQuXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbmNhdChidWZmZXJzKSB7XG4gICAgbGV0IG91dHB1dExlbmd0aCA9IDA7XG4gICAgbGV0IHByZXZMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2ldO1xuICAgICAgICBvdXRwdXRMZW5ndGggKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheShvdXRwdXRMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2ldO1xuICAgICAgICByZXRWaWV3LnNldChuZXcgVWludDhBcnJheShidWZmZXIpLCBwcmV2TGVuZ3RoKTtcbiAgICAgICAgcHJldkxlbmd0aCArPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJldFZpZXcuYnVmZmVyO1xufVxuZnVuY3Rpb24gY2hlY2tCdWZmZXJQYXJhbXMoYmFzZUJsb2NrLCBpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XG4gICAgaWYgKCEoaW5wdXRCdWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICBiYXNlQmxvY2suZXJyb3IgPSBcIldyb25nIHBhcmFtZXRlcjogaW5wdXRCdWZmZXIgbXVzdCBiZSAnVWludDhBcnJheSdcIjtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlucHV0QnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgYmFzZUJsb2NrLmVycm9yID0gXCJXcm9uZyBwYXJhbWV0ZXI6IGlucHV0QnVmZmVyIGhhcyB6ZXJvIGxlbmd0aFwiO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbnB1dE9mZnNldCA8IDApIHtcbiAgICAgICAgYmFzZUJsb2NrLmVycm9yID0gXCJXcm9uZyBwYXJhbWV0ZXI6IGlucHV0T2Zmc2V0IGxlc3MgdGhhbiB6ZXJvXCI7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlucHV0TGVuZ3RoIDwgMCkge1xuICAgICAgICBiYXNlQmxvY2suZXJyb3IgPSBcIldyb25nIHBhcmFtZXRlcjogaW5wdXRMZW5ndGggbGVzcyB0aGFuIHplcm9cIjtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKGlucHV0QnVmZmVyLmJ5dGVMZW5ndGggLSBpbnB1dE9mZnNldCAtIGlucHV0TGVuZ3RoKSA8IDApIHtcbiAgICAgICAgYmFzZUJsb2NrLmVycm9yID0gXCJFbmQgb2YgaW5wdXQgcmVhY2hlZCBiZWZvcmUgbWVzc2FnZSB3YXMgZnVsbHkgZGVjb2RlZCAoaW5jb25zaXN0ZW50IG9mZnNldCBhbmQgbGVuZ3RoIHZhbHVlcylcIjtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuY2xhc3MgVmlld1dyaXRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB9XG4gICAgd3JpdGUoYnVmKSB7XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaChidWYpO1xuICAgIH1cbiAgICBmaW5hbCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCh0aGlzLml0ZW1zKTtcbiAgICB9XG59XG5cbmNvbnN0IHBvd2VyczIgPSBbbmV3IFVpbnQ4QXJyYXkoWzFdKV07XG5jb25zdCBkaWdpdHNTdHJpbmcgPSBcIjAxMjM0NTY3ODlcIjtcbmNvbnN0IE5BTUUgPSBcIm5hbWVcIjtcbmNvbnN0IFZBTFVFX0hFWF9WSUVXID0gXCJ2YWx1ZUhleFZpZXdcIjtcbmNvbnN0IElTX0hFWF9PTkxZID0gXCJpc0hleE9ubHlcIjtcbmNvbnN0IElEX0JMT0NLID0gXCJpZEJsb2NrXCI7XG5jb25zdCBUQUdfQ0xBU1MgPSBcInRhZ0NsYXNzXCI7XG5jb25zdCBUQUdfTlVNQkVSID0gXCJ0YWdOdW1iZXJcIjtcbmNvbnN0IElTX0NPTlNUUlVDVEVEID0gXCJpc0NvbnN0cnVjdGVkXCI7XG5jb25zdCBGUk9NX0JFUiA9IFwiZnJvbUJFUlwiO1xuY29uc3QgVE9fQkVSID0gXCJ0b0JFUlwiO1xuY29uc3QgTE9DQUwgPSBcImxvY2FsXCI7XG5jb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xuY29uc3QgRU1QVFlfQlVGRkVSID0gbmV3IEFycmF5QnVmZmVyKDApO1xuY29uc3QgRU1QVFlfVklFVyA9IG5ldyBVaW50OEFycmF5KDApO1xuY29uc3QgRU5EX09GX0NPTlRFTlRfTkFNRSA9IFwiRW5kT2ZDb250ZW50XCI7XG5jb25zdCBPQ1RFVF9TVFJJTkdfTkFNRSA9IFwiT0NURVQgU1RSSU5HXCI7XG5jb25zdCBCSVRfU1RSSU5HX05BTUUgPSBcIkJJVCBTVFJJTkdcIjtcblxuZnVuY3Rpb24gSGV4QmxvY2soQmFzZUNsYXNzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfYSA9IGNsYXNzIFNvbWUgZXh0ZW5kcyBCYXNlQ2xhc3Mge1xuICAgICAgICAgICAgZ2V0IHZhbHVlSGV4KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlSGV4Vmlldy5zbGljZSgpLmJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldCB2YWx1ZUhleCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBhcmdzWzBdIHx8IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gKF9iID0gcGFyYW1zLmlzSGV4T25seSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSBwYXJhbXMudmFsdWVIZXggPyBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHBhcmFtcy52YWx1ZUhleCkgOiBFTVBUWV9WSUVXO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IGlucHV0QnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShpbnB1dEJ1ZmZlcikgOiBpbnB1dEJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrQnVmZmVyUGFyYW1zKHRoaXMsIHZpZXcsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlbmRMZW5ndGggPSBpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gdmlldy5zdWJhcnJheShpbnB1dE9mZnNldCwgZW5kTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmFsdWVIZXhWaWV3Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2goXCJaZXJvIGJ1ZmZlciBsZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IGlucHV0TGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b0JFUihzaXplT25seSA9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGV4T25seSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gXCJGbGFnICdpc0hleE9ubHknIGlzIG5vdCBzZXQsIGFib3J0XCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaXplT25seSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKHRoaXMudmFsdWVIZXhWaWV3LmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMudmFsdWVIZXhWaWV3LmJ5dGVMZW5ndGggPT09IHRoaXMudmFsdWVIZXhWaWV3LmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMudmFsdWVIZXhWaWV3LmJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMudmFsdWVIZXhWaWV3LnNsaWNlKCkuYnVmZmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9KU09OKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgICAgICAgICBpc0hleE9ubHk6IHRoaXMuaXNIZXhPbmx5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhleDogcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0hleCh0aGlzLnZhbHVlSGV4VmlldyksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX2EuTkFNRSA9IFwiaGV4QmxvY2tcIixcbiAgICAgICAgX2E7XG59XG5cbmNsYXNzIExvY2FsQmFzZUJsb2NrIHtcbiAgICBzdGF0aWMgYmxvY2tOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5OQU1FO1xuICAgIH1cbiAgICBnZXQgdmFsdWVCZWZvcmVEZWNvZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlQmVmb3JlRGVjb2RlVmlldy5zbGljZSgpLmJ1ZmZlcjtcbiAgICB9XG4gICAgc2V0IHZhbHVlQmVmb3JlRGVjb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVCZWZvcmVEZWNvZGVWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IGJsb2NrTGVuZ3RoID0gMCwgZXJyb3IgPSBFTVBUWV9TVFJJTkcsIHdhcm5pbmdzID0gW10sIHZhbHVlQmVmb3JlRGVjb2RlID0gRU1QVFlfVklFVywgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSBibG9ja0xlbmd0aDtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgICAgIHRoaXMudmFsdWVCZWZvcmVEZWNvZGVWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheSh2YWx1ZUJlZm9yZURlY29kZSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJsb2NrTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5OQU1FLFxuICAgICAgICAgICAgYmxvY2tMZW5ndGg6IHRoaXMuYmxvY2tMZW5ndGgsXG4gICAgICAgICAgICBlcnJvcjogdGhpcy5lcnJvcixcbiAgICAgICAgICAgIHdhcm5pbmdzOiB0aGlzLndhcm5pbmdzLFxuICAgICAgICAgICAgdmFsdWVCZWZvcmVEZWNvZGU6IHB2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuVG9IZXgodGhpcy52YWx1ZUJlZm9yZURlY29kZVZpZXcpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbkxvY2FsQmFzZUJsb2NrLk5BTUUgPSBcImJhc2VCbG9ja1wiO1xuXG5jbGFzcyBWYWx1ZUJsb2NrIGV4dGVuZHMgTG9jYWxCYXNlQmxvY2sge1xuICAgIGZyb21CRVIoX2lucHV0QnVmZmVyLCBfaW5wdXRPZmZzZXQsIF9pbnB1dExlbmd0aCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJVc2VyIG5lZWQgdG8gbWFrZSBhIHNwZWNpZmljIGZ1bmN0aW9uIGluIGEgY2xhc3Mgd2hpY2ggZXh0ZW5kcyAnVmFsdWVCbG9jaydcIik7XG4gICAgfVxuICAgIHRvQkVSKF9zaXplT25seSwgX3dyaXRlcikge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJVc2VyIG5lZWQgdG8gbWFrZSBhIHNwZWNpZmljIGZ1bmN0aW9uIGluIGEgY2xhc3Mgd2hpY2ggZXh0ZW5kcyAnVmFsdWVCbG9jaydcIik7XG4gICAgfVxufVxuVmFsdWVCbG9jay5OQU1FID0gXCJ2YWx1ZUJsb2NrXCI7XG5cbmNsYXNzIExvY2FsSWRlbnRpZmljYXRpb25CbG9jayBleHRlbmRzIEhleEJsb2NrKExvY2FsQmFzZUJsb2NrKSB7XG4gICAgY29uc3RydWN0b3IoeyBpZEJsb2NrID0ge30gfSA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKGlkQmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gKF9hID0gaWRCbG9jay5pc0hleE9ubHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSBpZEJsb2NrLnZhbHVlSGV4XG4gICAgICAgICAgICAgICAgPyBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGlkQmxvY2sudmFsdWVIZXgpXG4gICAgICAgICAgICAgICAgOiBFTVBUWV9WSUVXO1xuICAgICAgICAgICAgdGhpcy50YWdDbGFzcyA9IChfYiA9IGlkQmxvY2sudGFnQ2xhc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IC0xO1xuICAgICAgICAgICAgdGhpcy50YWdOdW1iZXIgPSAoX2MgPSBpZEJsb2NrLnRhZ051bWJlcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogLTE7XG4gICAgICAgICAgICB0aGlzLmlzQ29uc3RydWN0ZWQgPSAoX2QgPSBpZEJsb2NrLmlzQ29uc3RydWN0ZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YWdDbGFzcyA9IC0xO1xuICAgICAgICAgICAgdGhpcy50YWdOdW1iZXIgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuaXNDb25zdHJ1Y3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvQkVSKHNpemVPbmx5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGZpcnN0T2N0ZXQgPSAwO1xuICAgICAgICBzd2l0Y2ggKHRoaXMudGFnQ2xhc3MpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBmaXJzdE9jdGV0IHw9IDB4MDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZmlyc3RPY3RldCB8PSAweDQwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGZpcnN0T2N0ZXQgfD0gMHg4MDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBmaXJzdE9jdGV0IHw9IDB4QzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIlVua25vd24gdGFnIGNsYXNzXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKVxuICAgICAgICAgICAgZmlyc3RPY3RldCB8PSAweDIwO1xuICAgICAgICBpZiAodGhpcy50YWdOdW1iZXIgPCAzMSAmJiAhdGhpcy5pc0hleE9ubHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgICAgICAgIGlmICghc2l6ZU9ubHkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbnVtYmVyID0gdGhpcy50YWdOdW1iZXI7XG4gICAgICAgICAgICAgICAgbnVtYmVyICY9IDB4MUY7XG4gICAgICAgICAgICAgICAgZmlyc3RPY3RldCB8PSBudW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0Vmlld1swXSA9IGZpcnN0T2N0ZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0Vmlldy5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzSGV4T25seSkge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZEJ1ZiA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsVG9CYXNlKHRoaXMudGFnTnVtYmVyLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEJ1Zik7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcmV0VmlldyA9IG5ldyBVaW50OEFycmF5KHNpemUgKyAxKTtcbiAgICAgICAgICAgIHJldFZpZXdbMF0gPSAoZmlyc3RPY3RldCB8IDB4MUYpO1xuICAgICAgICAgICAgaWYgKCFzaXplT25seSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHNpemUgLSAxKTsgaSsrKVxuICAgICAgICAgICAgICAgICAgICByZXRWaWV3W2kgKyAxXSA9IGVuY29kZWRWaWV3W2ldIHwgMHg4MDtcbiAgICAgICAgICAgICAgICByZXRWaWV3W3NpemVdID0gZW5jb2RlZFZpZXdbc2l6ZSAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldFZpZXcuYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLnZhbHVlSGV4Vmlldy5ieXRlTGVuZ3RoICsgMSk7XG4gICAgICAgIHJldFZpZXdbMF0gPSAoZmlyc3RPY3RldCB8IDB4MUYpO1xuICAgICAgICBpZiAoIXNpemVPbmx5KSB7XG4gICAgICAgICAgICBjb25zdCBjdXJWaWV3ID0gdGhpcy52YWx1ZUhleFZpZXc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChjdXJWaWV3Lmxlbmd0aCAtIDEpOyBpKyspXG4gICAgICAgICAgICAgICAgcmV0Vmlld1tpICsgMV0gPSBjdXJWaWV3W2ldIHwgMHg4MDtcbiAgICAgICAgICAgIHJldFZpZXdbdGhpcy52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aF0gPSBjdXJWaWV3W2N1clZpZXcubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldFZpZXcuYnVmZmVyO1xuICAgIH1cbiAgICBmcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaW5wdXRWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XG4gICAgICAgIGlmICghY2hlY2tCdWZmZXJQYXJhbXModGhpcywgaW5wdXRWaWV3LCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW50QnVmZmVyID0gaW5wdXRWaWV3LnN1YmFycmF5KGlucHV0T2Zmc2V0LCBpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKTtcbiAgICAgICAgaWYgKGludEJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIlplcm8gYnVmZmVyIGxlbmd0aFwiO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ0NsYXNzTWFzayA9IGludEJ1ZmZlclswXSAmIDB4QzA7XG4gICAgICAgIHN3aXRjaCAodGFnQ2xhc3NNYXNrKSB7XG4gICAgICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICAgICAgdGhpcy50YWdDbGFzcyA9ICgxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHg0MDpcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ0NsYXNzID0gKDIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweDgwOlxuICAgICAgICAgICAgICAgIHRoaXMudGFnQ2xhc3MgPSAoMyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4QzA6XG4gICAgICAgICAgICAgICAgdGhpcy50YWdDbGFzcyA9ICg0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiVW5rbm93biB0YWcgY2xhc3NcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NvbnN0cnVjdGVkID0gKGludEJ1ZmZlclswXSAmIDB4MjApID09PSAweDIwO1xuICAgICAgICB0aGlzLmlzSGV4T25seSA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0YWdOdW1iZXJNYXNrID0gaW50QnVmZmVyWzBdICYgMHgxRjtcbiAgICAgICAgaWYgKHRhZ051bWJlck1hc2sgIT09IDB4MUYpIHtcbiAgICAgICAgICAgIHRoaXMudGFnTnVtYmVyID0gKHRhZ051bWJlck1hc2spO1xuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAxO1xuICAgICAgICAgICAgbGV0IGludFRhZ051bWJlckJ1ZmZlciA9IHRoaXMudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMjU1KTtcbiAgICAgICAgICAgIGxldCB0YWdOdW1iZXJCdWZmZXJNYXhMZW5ndGggPSAyNTU7XG4gICAgICAgICAgICB3aGlsZSAoaW50QnVmZmVyW2NvdW50XSAmIDB4ODApIHtcbiAgICAgICAgICAgICAgICBpbnRUYWdOdW1iZXJCdWZmZXJbY291bnQgLSAxXSA9IGludEJ1ZmZlcltjb3VudF0gJiAweDdGO1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID49IGludEJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRW5kIG9mIGlucHV0IHJlYWNoZWQgYmVmb3JlIG1lc3NhZ2Ugd2FzIGZ1bGx5IGRlY29kZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IHRhZ051bWJlckJ1ZmZlck1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXJCdWZmZXJNYXhMZW5ndGggKz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wQnVmZmVyVmlldyA9IG5ldyBVaW50OEFycmF5KHRhZ051bWJlckJ1ZmZlck1heExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW50VGFnTnVtYmVyQnVmZmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEJ1ZmZlclZpZXdbaV0gPSBpbnRUYWdOdW1iZXJCdWZmZXJbaV07XG4gICAgICAgICAgICAgICAgICAgIGludFRhZ051bWJlckJ1ZmZlciA9IHRoaXMudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGFnTnVtYmVyQnVmZmVyTWF4TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoID0gKGNvdW50ICsgMSk7XG4gICAgICAgICAgICBpbnRUYWdOdW1iZXJCdWZmZXJbY291bnQgLSAxXSA9IGludEJ1ZmZlcltjb3VudF0gJiAweDdGO1xuICAgICAgICAgICAgY29uc3QgdGVtcEJ1ZmZlclZpZXcgPSBuZXcgVWludDhBcnJheShjb3VudCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspXG4gICAgICAgICAgICAgICAgdGVtcEJ1ZmZlclZpZXdbaV0gPSBpbnRUYWdOdW1iZXJCdWZmZXJbaV07XG4gICAgICAgICAgICBpbnRUYWdOdW1iZXJCdWZmZXIgPSB0aGlzLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KGNvdW50KTtcbiAgICAgICAgICAgIGludFRhZ051bWJlckJ1ZmZlci5zZXQodGVtcEJ1ZmZlclZpZXcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tMZW5ndGggPD0gOSlcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ051bWJlciA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsRnJvbUJhc2UoaW50VGFnTnVtYmVyQnVmZmVyLCA3KTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2goXCJUYWcgdG9vIGxvbmcsIHJlcHJlc2VudGVkIGFzIGhleC1jb2RlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKCh0aGlzLnRhZ0NsYXNzID09PSAxKSlcbiAgICAgICAgICAgICYmICh0aGlzLmlzQ29uc3RydWN0ZWQpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudGFnTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIkNvbnN0cnVjdGVkIGVuY29kaW5nIHVzZWQgZm9yIHByaW1pdGl2ZSB0eXBlXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGlucHV0T2Zmc2V0ICsgdGhpcy5ibG9ja0xlbmd0aCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgdGFnQ2xhc3M6IHRoaXMudGFnQ2xhc3MsXG4gICAgICAgICAgICB0YWdOdW1iZXI6IHRoaXMudGFnTnVtYmVyLFxuICAgICAgICAgICAgaXNDb25zdHJ1Y3RlZDogdGhpcy5pc0NvbnN0cnVjdGVkLFxuICAgICAgICB9O1xuICAgIH1cbn1cbkxvY2FsSWRlbnRpZmljYXRpb25CbG9jay5OQU1FID0gXCJpZGVudGlmaWNhdGlvbkJsb2NrXCI7XG5cbmNsYXNzIExvY2FsTGVuZ3RoQmxvY2sgZXh0ZW5kcyBMb2NhbEJhc2VCbG9jayB7XG4gICAgY29uc3RydWN0b3IoeyBsZW5CbG9jayA9IHt9IH0gPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc0luZGVmaW5pdGVGb3JtID0gKF9hID0gbGVuQmxvY2suaXNJbmRlZmluaXRlRm9ybSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIHRoaXMubG9uZ0Zvcm1Vc2VkID0gKF9iID0gbGVuQmxvY2subG9uZ0Zvcm1Vc2VkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAoX2MgPSBsZW5CbG9jay5sZW5ndGgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDA7XG4gICAgfVxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xuICAgICAgICBjb25zdCB2aWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XG4gICAgICAgIGlmICghY2hlY2tCdWZmZXJQYXJhbXModGhpcywgdmlldywgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludEJ1ZmZlciA9IHZpZXcuc3ViYXJyYXkoaW5wdXRPZmZzZXQsIGlucHV0T2Zmc2V0ICsgaW5wdXRMZW5ndGgpO1xuICAgICAgICBpZiAoaW50QnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiWmVybyBidWZmZXIgbGVuZ3RoXCI7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludEJ1ZmZlclswXSA9PT0gMHhGRikge1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiTGVuZ3RoIGJsb2NrIDB4RkYgaXMgcmVzZXJ2ZWQgYnkgc3RhbmRhcmRcIjtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzSW5kZWZpbml0ZUZvcm0gPSBpbnRCdWZmZXJbMF0gPT09IDB4ODA7XG4gICAgICAgIGlmICh0aGlzLmlzSW5kZWZpbml0ZUZvcm0pIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSAxO1xuICAgICAgICAgICAgcmV0dXJuIChpbnB1dE9mZnNldCArIHRoaXMuYmxvY2tMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9uZ0Zvcm1Vc2VkID0gISEoaW50QnVmZmVyWzBdICYgMHg4MCk7XG4gICAgICAgIGlmICh0aGlzLmxvbmdGb3JtVXNlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gKGludEJ1ZmZlclswXSk7XG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIHJldHVybiAoaW5wdXRPZmZzZXQgKyB0aGlzLmJsb2NrTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb3VudCA9IGludEJ1ZmZlclswXSAmIDB4N0Y7XG4gICAgICAgIGlmIChjb3VudCA+IDgpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIlRvbyBiaWcgaW50ZWdlclwiO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoY291bnQgKyAxKSA+IGludEJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIkVuZCBvZiBpbnB1dCByZWFjaGVkIGJlZm9yZSBtZXNzYWdlIHdhcyBmdWxseSBkZWNvZGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuT2Zmc2V0ID0gaW5wdXRPZmZzZXQgKyAxO1xuICAgICAgICBjb25zdCBsZW5ndGhCdWZmZXJWaWV3ID0gdmlldy5zdWJhcnJheShsZW5PZmZzZXQsIGxlbk9mZnNldCArIGNvdW50KTtcbiAgICAgICAgaWYgKGxlbmd0aEJ1ZmZlclZpZXdbY291bnQgLSAxXSA9PT0gMHgwMClcbiAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChcIk5lZWRsZXNzbHkgbG9uZyBlbmNvZGVkIGxlbmd0aFwiKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBwdnV0aWxzX19uYW1lc3BhY2UudXRpbEZyb21CYXNlKGxlbmd0aEJ1ZmZlclZpZXcsIDgpO1xuICAgICAgICBpZiAodGhpcy5sb25nRm9ybVVzZWQgJiYgKHRoaXMubGVuZ3RoIDw9IDEyNykpXG4gICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2goXCJVbm5lY2Vzc2FyeSB1c2FnZSBvZiBsb25nIGxlbmd0aCBmb3JtXCIpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoID0gY291bnQgKyAxO1xuICAgICAgICByZXR1cm4gKGlucHV0T2Zmc2V0ICsgdGhpcy5ibG9ja0xlbmd0aCk7XG4gICAgfVxuICAgIHRvQkVSKHNpemVPbmx5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJldEJ1ZjtcbiAgICAgICAgbGV0IHJldFZpZXc7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEyNylcbiAgICAgICAgICAgIHRoaXMubG9uZ0Zvcm1Vc2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmRlZmluaXRlRm9ybSkge1xuICAgICAgICAgICAgcmV0QnVmID0gbmV3IEFycmF5QnVmZmVyKDEpO1xuICAgICAgICAgICAgaWYgKHNpemVPbmx5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldFZpZXcgPSBuZXcgVWludDhBcnJheShyZXRCdWYpO1xuICAgICAgICAgICAgICAgIHJldFZpZXdbMF0gPSAweDgwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldEJ1ZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb25nRm9ybVVzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRCdWYgPSBwdnV0aWxzX19uYW1lc3BhY2UudXRpbFRvQmFzZSh0aGlzLmxlbmd0aCwgOCk7XG4gICAgICAgICAgICBpZiAoZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoID4gMTI3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiVG9vIGJpZyBsZW5ndGhcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKEVNUFRZX0JVRkZFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXRCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoICsgMSk7XG4gICAgICAgICAgICBpZiAoc2l6ZU9ubHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldEJ1ZjtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEJ1Zik7XG4gICAgICAgICAgICByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkocmV0QnVmKTtcbiAgICAgICAgICAgIHJldFZpZXdbMF0gPSBlbmNvZGVkQnVmLmJ5dGVMZW5ndGggfCAweDgwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVkQnVmLmJ5dGVMZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICByZXRWaWV3W2kgKyAxXSA9IGVuY29kZWRWaWV3W2ldO1xuICAgICAgICAgICAgcmV0dXJuIHJldEJ1ZjtcbiAgICAgICAgfVxuICAgICAgICByZXRCdWYgPSBuZXcgQXJyYXlCdWZmZXIoMSk7XG4gICAgICAgIGlmIChzaXplT25seSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldFZpZXcgPSBuZXcgVWludDhBcnJheShyZXRCdWYpO1xuICAgICAgICAgICAgcmV0Vmlld1swXSA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRCdWY7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgaXNJbmRlZmluaXRlRm9ybTogdGhpcy5pc0luZGVmaW5pdGVGb3JtLFxuICAgICAgICAgICAgbG9uZ0Zvcm1Vc2VkOiB0aGlzLmxvbmdGb3JtVXNlZCxcbiAgICAgICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGgsXG4gICAgICAgIH07XG4gICAgfVxufVxuTG9jYWxMZW5ndGhCbG9jay5OQU1FID0gXCJsZW5ndGhCbG9ja1wiO1xuXG5jb25zdCB0eXBlU3RvcmUgPSB7fTtcblxuY2xhc3MgQmFzZUJsb2NrIGV4dGVuZHMgTG9jYWxCYXNlQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKHsgbmFtZSA9IEVNUFRZX1NUUklORywgb3B0aW9uYWwgPSBmYWxzZSwgcHJpbWl0aXZlU2NoZW1hLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSwgdmFsdWVCbG9ja1R5cGUpIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgaWYgKHByaW1pdGl2ZVNjaGVtYSkge1xuICAgICAgICAgICAgdGhpcy5wcmltaXRpdmVTY2hlbWEgPSBwcmltaXRpdmVTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZEJsb2NrID0gbmV3IExvY2FsSWRlbnRpZmljYXRpb25CbG9jayhwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5sZW5CbG9jayA9IG5ldyBMb2NhbExlbmd0aEJsb2NrKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLnZhbHVlQmxvY2sgPSB2YWx1ZUJsb2NrVHlwZSA/IG5ldyB2YWx1ZUJsb2NrVHlwZShwYXJhbWV0ZXJzKSA6IG5ldyBWYWx1ZUJsb2NrKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBmcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0T2Zmc2V0ID0gdGhpcy52YWx1ZUJsb2NrLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCAodGhpcy5sZW5CbG9jay5pc0luZGVmaW5pdGVGb3JtKVxuICAgICAgICAgICAgPyBpbnB1dExlbmd0aFxuICAgICAgICAgICAgOiB0aGlzLmxlbkJsb2NrLmxlbmd0aCk7XG4gICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gdGhpcy52YWx1ZUJsb2NrLmVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaWRCbG9jay5lcnJvci5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoICs9IHRoaXMuaWRCbG9jay5ibG9ja0xlbmd0aDtcbiAgICAgICAgaWYgKCF0aGlzLmxlbkJsb2NrLmVycm9yLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggKz0gdGhpcy5sZW5CbG9jay5ibG9ja0xlbmd0aDtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlQmxvY2suZXJyb3IubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLnZhbHVlQmxvY2suYmxvY2tMZW5ndGg7XG4gICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XG4gICAgfVxuICAgIHRvQkVSKHNpemVPbmx5LCB3cml0ZXIpIHtcbiAgICAgICAgY29uc3QgX3dyaXRlciA9IHdyaXRlciB8fCBuZXcgVmlld1dyaXRlcigpO1xuICAgICAgICBpZiAoIXdyaXRlcikge1xuICAgICAgICAgICAgcHJlcGFyZUluZGVmaW5pdGVGb3JtKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkQmxvY2tCdWYgPSB0aGlzLmlkQmxvY2sudG9CRVIoc2l6ZU9ubHkpO1xuICAgICAgICBfd3JpdGVyLndyaXRlKGlkQmxvY2tCdWYpO1xuICAgICAgICBpZiAodGhpcy5sZW5CbG9jay5pc0luZGVmaW5pdGVGb3JtKSB7XG4gICAgICAgICAgICBfd3JpdGVyLndyaXRlKG5ldyBVaW50OEFycmF5KFsweDgwXSkuYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVCbG9jay50b0JFUihzaXplT25seSwgX3dyaXRlcik7XG4gICAgICAgICAgICBfd3JpdGVyLndyaXRlKG5ldyBBcnJheUJ1ZmZlcigyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUJsb2NrQnVmID0gdGhpcy52YWx1ZUJsb2NrLnRvQkVSKHNpemVPbmx5KTtcbiAgICAgICAgICAgIHRoaXMubGVuQmxvY2subGVuZ3RoID0gdmFsdWVCbG9ja0J1Zi5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbGVuQmxvY2tCdWYgPSB0aGlzLmxlbkJsb2NrLnRvQkVSKHNpemVPbmx5KTtcbiAgICAgICAgICAgIF93cml0ZXIud3JpdGUobGVuQmxvY2tCdWYpO1xuICAgICAgICAgICAgX3dyaXRlci53cml0ZSh2YWx1ZUJsb2NrQnVmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIF93cml0ZXIuZmluYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgaWRCbG9jazogdGhpcy5pZEJsb2NrLnRvSlNPTigpLFxuICAgICAgICAgICAgbGVuQmxvY2s6IHRoaXMubGVuQmxvY2sudG9KU09OKCksXG4gICAgICAgICAgICB2YWx1ZUJsb2NrOiB0aGlzLnZhbHVlQmxvY2sudG9KU09OKCksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25hbDogdGhpcy5vcHRpb25hbCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucHJpbWl0aXZlU2NoZW1hKVxuICAgICAgICAgICAgb2JqZWN0LnByaW1pdGl2ZVNjaGVtYSA9IHRoaXMucHJpbWl0aXZlU2NoZW1hLnRvSlNPTigpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICB0b1N0cmluZyhlbmNvZGluZyA9IFwiYXNjaWlcIikge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09IFwiYXNjaWlcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25Bc2NpaUVuY29kaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuVG9IZXgodGhpcy50b0JFUigpKTtcbiAgICB9XG4gICAgb25Bc2NpaUVuY29kaW5nKCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5OQU1FO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuVG9IZXgodGhpcy52YWx1ZUJsb2NrLnZhbHVlQmVmb3JlRGVjb2RlVmlldyk7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfSA6ICR7dmFsdWV9YDtcbiAgICB9XG4gICAgaXNFcXVhbChvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGlzUmF3ID0gdGhpcy50b0JFUigpO1xuICAgICAgICBjb25zdCBvdGhlclJhdyA9IG90aGVyLnRvQkVSKCk7XG4gICAgICAgIHJldHVybiBwdnV0aWxzX19uYW1lc3BhY2UuaXNFcXVhbEJ1ZmZlcih0aGlzUmF3LCBvdGhlclJhdyk7XG4gICAgfVxufVxuQmFzZUJsb2NrLk5BTUUgPSBcIkJhc2VCbG9ja1wiO1xuZnVuY3Rpb24gcHJlcGFyZUluZGVmaW5pdGVGb3JtKGJhc2VCbG9jaykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoYmFzZUJsb2NrIGluc3RhbmNlb2YgdHlwZVN0b3JlLkNvbnN0cnVjdGVkKSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYmFzZUJsb2NrLnZhbHVlQmxvY2sudmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlSW5kZWZpbml0ZUZvcm0odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgYmFzZUJsb2NrLmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhISgoX2EgPSBiYXNlQmxvY2subGVuQmxvY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0luZGVmaW5pdGVGb3JtKTtcbn1cblxuY2xhc3MgQmFzZVN0cmluZ0Jsb2NrIGV4dGVuZHMgQmFzZUJsb2NrIHtcbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVCbG9jay52YWx1ZTtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgPSBFTVBUWV9TVFJJTkcsIC4uLnBhcmFtZXRlcnMgfSA9IHt9LCBzdHJpbmdWYWx1ZUJsb2NrVHlwZSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzLCBzdHJpbmdWYWx1ZUJsb2NrVHlwZSk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0T2Zmc2V0ID0gdGhpcy52YWx1ZUJsb2NrLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCAodGhpcy5sZW5CbG9jay5pc0luZGVmaW5pdGVGb3JtKVxuICAgICAgICAgICAgPyBpbnB1dExlbmd0aFxuICAgICAgICAgICAgOiB0aGlzLmxlbkJsb2NrLmxlbmd0aCk7XG4gICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gdGhpcy52YWx1ZUJsb2NrLmVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyb21CdWZmZXIodGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4Vmlldyk7XG4gICAgICAgIGlmICghdGhpcy5pZEJsb2NrLmVycm9yLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggKz0gdGhpcy5pZEJsb2NrLmJsb2NrTGVuZ3RoO1xuICAgICAgICBpZiAoIXRoaXMubGVuQmxvY2suZXJyb3IubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmxlbkJsb2NrLmJsb2NrTGVuZ3RoO1xuICAgICAgICBpZiAoIXRoaXMudmFsdWVCbG9jay5lcnJvci5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoICs9IHRoaXMudmFsdWVCbG9jay5ibG9ja0xlbmd0aDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcbiAgICB9XG4gICAgb25Bc2NpaUVuY29kaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfSA6ICcke3RoaXMudmFsdWVCbG9jay52YWx1ZX0nYDtcbiAgICB9XG59XG5CYXNlU3RyaW5nQmxvY2suTkFNRSA9IFwiQmFzZVN0cmluZ0Jsb2NrXCI7XG5cbmNsYXNzIExvY2FsUHJpbWl0aXZlVmFsdWVCbG9jayBleHRlbmRzIEhleEJsb2NrKFZhbHVlQmxvY2spIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGlzSGV4T25seSA9IHRydWUsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLmlzSGV4T25seSA9IGlzSGV4T25seTtcbiAgICB9XG59XG5Mb2NhbFByaW1pdGl2ZVZhbHVlQmxvY2suTkFNRSA9IFwiUHJpbWl0aXZlVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkdztcbmNsYXNzIFByaW1pdGl2ZSBleHRlbmRzIEJhc2VCbG9jayB7XG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMsIExvY2FsUHJpbWl0aXZlVmFsdWVCbG9jayk7XG4gICAgICAgIHRoaXMuaWRCbG9jay5pc0NvbnN0cnVjdGVkID0gZmFsc2U7XG4gICAgfVxufVxuX2EkdyA9IFByaW1pdGl2ZTtcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLlByaW1pdGl2ZSA9IF9hJHc7XG59KSgpO1xuUHJpbWl0aXZlLk5BTUUgPSBcIlBSSU1JVElWRVwiO1xuXG5mdW5jdGlvbiBsb2NhbENoYW5nZVR5cGUoaW5wdXRPYmplY3QsIG5ld1R5cGUpIHtcbiAgICBpZiAoaW5wdXRPYmplY3QgaW5zdGFuY2VvZiBuZXdUeXBlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dE9iamVjdDtcbiAgICB9XG4gICAgY29uc3QgbmV3T2JqZWN0ID0gbmV3IG5ld1R5cGUoKTtcbiAgICBuZXdPYmplY3QuaWRCbG9jayA9IGlucHV0T2JqZWN0LmlkQmxvY2s7XG4gICAgbmV3T2JqZWN0LmxlbkJsb2NrID0gaW5wdXRPYmplY3QubGVuQmxvY2s7XG4gICAgbmV3T2JqZWN0Lndhcm5pbmdzID0gaW5wdXRPYmplY3Qud2FybmluZ3M7XG4gICAgbmV3T2JqZWN0LnZhbHVlQmVmb3JlRGVjb2RlVmlldyA9IGlucHV0T2JqZWN0LnZhbHVlQmVmb3JlRGVjb2RlVmlldztcbiAgICByZXR1cm4gbmV3T2JqZWN0O1xufVxuZnVuY3Rpb24gbG9jYWxGcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCA9IDAsIGlucHV0TGVuZ3RoID0gaW5wdXRCdWZmZXIubGVuZ3RoKSB7XG4gICAgY29uc3QgaW5jb21pbmdPZmZzZXQgPSBpbnB1dE9mZnNldDtcbiAgICBsZXQgcmV0dXJuT2JqZWN0ID0gbmV3IEJhc2VCbG9jayh7fSwgVmFsdWVCbG9jayk7XG4gICAgY29uc3QgYmFzZUJsb2NrID0gbmV3IExvY2FsQmFzZUJsb2NrKCk7XG4gICAgaWYgKCFjaGVja0J1ZmZlclBhcmFtcyhiYXNlQmxvY2ssIGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybk9iamVjdC5lcnJvciA9IGJhc2VCbG9jay5lcnJvcjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9mZnNldDogLTEsXG4gICAgICAgICAgICByZXN1bHQ6IHJldHVybk9iamVjdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaW50QnVmZmVyID0gaW5wdXRCdWZmZXIuc3ViYXJyYXkoaW5wdXRPZmZzZXQsIGlucHV0T2Zmc2V0ICsgaW5wdXRMZW5ndGgpO1xuICAgIGlmICghaW50QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm5PYmplY3QuZXJyb3IgPSBcIlplcm8gYnVmZmVyIGxlbmd0aFwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2Zmc2V0OiAtMSxcbiAgICAgICAgICAgIHJlc3VsdDogcmV0dXJuT2JqZWN0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgcmVzdWx0T2Zmc2V0ID0gcmV0dXJuT2JqZWN0LmlkQmxvY2suZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKTtcbiAgICBpZiAocmV0dXJuT2JqZWN0LmlkQmxvY2sud2FybmluZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybk9iamVjdC53YXJuaW5ncy5jb25jYXQocmV0dXJuT2JqZWN0LmlkQmxvY2sud2FybmluZ3MpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0T2Zmc2V0ID09PSAtMSkge1xuICAgICAgICByZXR1cm5PYmplY3QuZXJyb3IgPSByZXR1cm5PYmplY3QuaWRCbG9jay5lcnJvcjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9mZnNldDogLTEsXG4gICAgICAgICAgICByZXN1bHQ6IHJldHVybk9iamVjdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaW5wdXRPZmZzZXQgPSByZXN1bHRPZmZzZXQ7XG4gICAgaW5wdXRMZW5ndGggLT0gcmV0dXJuT2JqZWN0LmlkQmxvY2suYmxvY2tMZW5ndGg7XG4gICAgcmVzdWx0T2Zmc2V0ID0gcmV0dXJuT2JqZWN0LmxlbkJsb2NrLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCk7XG4gICAgaWYgKHJldHVybk9iamVjdC5sZW5CbG9jay53YXJuaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuT2JqZWN0Lndhcm5pbmdzLmNvbmNhdChyZXR1cm5PYmplY3QubGVuQmxvY2sud2FybmluZ3MpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0T2Zmc2V0ID09PSAtMSkge1xuICAgICAgICByZXR1cm5PYmplY3QuZXJyb3IgPSByZXR1cm5PYmplY3QubGVuQmxvY2suZXJyb3I7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvZmZzZXQ6IC0xLFxuICAgICAgICAgICAgcmVzdWx0OiByZXR1cm5PYmplY3QsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlucHV0T2Zmc2V0ID0gcmVzdWx0T2Zmc2V0O1xuICAgIGlucHV0TGVuZ3RoIC09IHJldHVybk9iamVjdC5sZW5CbG9jay5ibG9ja0xlbmd0aDtcbiAgICBpZiAoIXJldHVybk9iamVjdC5pZEJsb2NrLmlzQ29uc3RydWN0ZWRcbiAgICAgICAgJiYgcmV0dXJuT2JqZWN0LmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm0pIHtcbiAgICAgICAgcmV0dXJuT2JqZWN0LmVycm9yID0gXCJJbmRlZmluaXRlIGxlbmd0aCBmb3JtIHVzZWQgZm9yIHByaW1pdGl2ZSBlbmNvZGluZyBmb3JtXCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvZmZzZXQ6IC0xLFxuICAgICAgICAgICAgcmVzdWx0OiByZXR1cm5PYmplY3QsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCBuZXdBU04xVHlwZSA9IEJhc2VCbG9jaztcbiAgICBzd2l0Y2ggKHJldHVybk9iamVjdC5pZEJsb2NrLnRhZ0NsYXNzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGlmICgocmV0dXJuT2JqZWN0LmlkQmxvY2sudGFnTnVtYmVyID49IDM3KVxuICAgICAgICAgICAgICAgICYmIChyZXR1cm5PYmplY3QuaWRCbG9jay5pc0hleE9ubHkgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybk9iamVjdC5lcnJvciA9IFwiVU5JVkVSU0FMIDM3IGFuZCB1cHBlciB0YWdzIGFyZSByZXNlcnZlZCBieSBBU04uMSBzdGFuZGFyZFwiO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogLTEsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmV0dXJuT2JqZWN0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHJldHVybk9iamVjdC5pZEJsb2NrLnRhZ051bWJlcikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKChyZXR1cm5PYmplY3QuaWRCbG9jay5pc0NvbnN0cnVjdGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHJldHVybk9iamVjdC5sZW5CbG9jay5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqZWN0LmVycm9yID0gXCJUeXBlIFtVTklWRVJTQUwgMF0gaXMgcmVzZXJ2ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJldHVybk9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuRW5kT2ZDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkJvb2xlYW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuSW50ZWdlcjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5CaXRTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuT2N0ZXRTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuTnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5PYmplY3RJZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5FbnVtZXJhdGVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5VdGY4U3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5SZWxhdGl2ZU9iamVjdElkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlRJTUU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybk9iamVjdC5lcnJvciA9IFwiW1VOSVZFUlNBTCAxNV0gaXMgcmVzZXJ2ZWQgYnkgQVNOLjEgc3RhbmRhcmRcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJldHVybk9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5TZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuU2V0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5OdW1lcmljU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5QcmludGFibGVTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlRlbGV0ZXhTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlZpZGVvdGV4U3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5JQTVTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlVUQ1RpbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkdlbmVyYWxpemVkVGltZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuR3JhcGhpY1N0cmluZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuVmlzaWJsZVN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuR2VuZXJhbFN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuVW5pdmVyc2FsU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5DaGFyYWN0ZXJTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkJtcFN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuREFURTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuVGltZU9mRGF5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5EYXRlVGltZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuRHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3T2JqZWN0ID0gcmV0dXJuT2JqZWN0LmlkQmxvY2suaXNDb25zdHJ1Y3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgdHlwZVN0b3JlLkNvbnN0cnVjdGVkKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IHR5cGVTdG9yZS5QcmltaXRpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqZWN0LmlkQmxvY2sgPSByZXR1cm5PYmplY3QuaWRCbG9jaztcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqZWN0LmxlbkJsb2NrID0gcmV0dXJuT2JqZWN0LmxlbkJsb2NrO1xuICAgICAgICAgICAgICAgICAgICBuZXdPYmplY3Qud2FybmluZ3MgPSByZXR1cm5PYmplY3Qud2FybmluZ3M7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybk9iamVjdCA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSByZXR1cm5PYmplY3QuaWRCbG9jay5pc0NvbnN0cnVjdGVkXG4gICAgICAgICAgICAgICAgPyB0eXBlU3RvcmUuQ29uc3RydWN0ZWRcbiAgICAgICAgICAgICAgICA6IHR5cGVTdG9yZS5QcmltaXRpdmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuT2JqZWN0ID0gbG9jYWxDaGFuZ2VUeXBlKHJldHVybk9iamVjdCwgbmV3QVNOMVR5cGUpO1xuICAgIHJlc3VsdE9mZnNldCA9IHJldHVybk9iamVjdC5mcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgcmV0dXJuT2JqZWN0LmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm0gPyBpbnB1dExlbmd0aCA6IHJldHVybk9iamVjdC5sZW5CbG9jay5sZW5ndGgpO1xuICAgIHJldHVybk9iamVjdC52YWx1ZUJlZm9yZURlY29kZVZpZXcgPSBpbnB1dEJ1ZmZlci5zdWJhcnJheShpbmNvbWluZ09mZnNldCwgaW5jb21pbmdPZmZzZXQgKyByZXR1cm5PYmplY3QuYmxvY2tMZW5ndGgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldDogcmVzdWx0T2Zmc2V0LFxuICAgICAgICByZXN1bHQ6IHJldHVybk9iamVjdCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbUJFUihpbnB1dEJ1ZmZlcikge1xuICAgIGlmICghaW5wdXRCdWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQmFzZUJsb2NrKHt9LCBWYWx1ZUJsb2NrKTtcbiAgICAgICAgcmVzdWx0LmVycm9yID0gXCJJbnB1dCBidWZmZXIgaGFzIHplcm8gbGVuZ3RoXCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvZmZzZXQ6IC0xLFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxGcm9tQkVSKHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpLnNsaWNlKCksIDAsIGlucHV0QnVmZmVyLmJ5dGVMZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBjaGVja0xlbihpbmRlZmluaXRlTGVuZ3RoLCBsZW5ndGgpIHtcbiAgICBpZiAoaW5kZWZpbml0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmNsYXNzIExvY2FsQ29uc3RydWN0ZWRWYWx1ZUJsb2NrIGV4dGVuZHMgVmFsdWVCbG9jayB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSA9IFtdLCBpc0luZGVmaW5pdGVGb3JtID0gZmFsc2UsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaXNJbmRlZmluaXRlRm9ybSA9IGlzSW5kZWZpbml0ZUZvcm07XG4gICAgfVxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xuICAgICAgICBjb25zdCB2aWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XG4gICAgICAgIGlmICghY2hlY2tCdWZmZXJQYXJhbXModGhpcywgdmlldywgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVCZWZvcmVEZWNvZGVWaWV3ID0gdmlldy5zdWJhcnJheShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aCk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlQmVmb3JlRGVjb2RlVmlldy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChcIlplcm8gYnVmZmVyIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudE9mZnNldCA9IGlucHV0T2Zmc2V0O1xuICAgICAgICB3aGlsZSAoY2hlY2tMZW4odGhpcy5pc0luZGVmaW5pdGVGb3JtLCBpbnB1dExlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCByZXR1cm5PYmplY3QgPSBsb2NhbEZyb21CRVIodmlldywgY3VycmVudE9mZnNldCwgaW5wdXRMZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHJldHVybk9iamVjdC5vZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHJldHVybk9iamVjdC5yZXN1bHQuZXJyb3I7XG4gICAgICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5jb25jYXQocmV0dXJuT2JqZWN0LnJlc3VsdC53YXJuaW5ncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudE9mZnNldCA9IHJldHVybk9iamVjdC5vZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoICs9IHJldHVybk9iamVjdC5yZXN1bHQuYmxvY2tMZW5ndGg7XG4gICAgICAgICAgICBpbnB1dExlbmd0aCAtPSByZXR1cm5PYmplY3QucmVzdWx0LmJsb2NrTGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5wdXNoKHJldHVybk9iamVjdC5yZXN1bHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbmRlZmluaXRlRm9ybSAmJiByZXR1cm5PYmplY3QucmVzdWx0LmNvbnN0cnVjdG9yLk5BTUUgPT09IEVORF9PRl9DT05URU5UX05BTUUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0luZGVmaW5pdGVGb3JtKSB7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZVt0aGlzLnZhbHVlLmxlbmd0aCAtIDFdLmNvbnN0cnVjdG9yLk5BTUUgPT09IEVORF9PRl9DT05URU5UX05BTUUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiTm8gRW5kT2ZDb250ZW50IGJsb2NrIGVuY29kZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIHRvQkVSKHNpemVPbmx5LCB3cml0ZXIpIHtcbiAgICAgICAgY29uc3QgX3dyaXRlciA9IHdyaXRlciB8fCBuZXcgVmlld1dyaXRlcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVbaV0udG9CRVIoc2l6ZU9ubHksIF93cml0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3dyaXRlci5maW5hbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICBpc0luZGVmaW5pdGVGb3JtOiB0aGlzLmlzSW5kZWZpbml0ZUZvcm0sXG4gICAgICAgICAgICB2YWx1ZTogW10sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgb2JqZWN0LnZhbHVlLnB1c2godmFsdWUudG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxufVxuTG9jYWxDb25zdHJ1Y3RlZFZhbHVlQmxvY2suTkFNRSA9IFwiQ29uc3RydWN0ZWRWYWx1ZUJsb2NrXCI7XG5cbnZhciBfYSR2O1xuY2xhc3MgQ29uc3RydWN0ZWQgZXh0ZW5kcyBCYXNlQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzLCBMb2NhbENvbnN0cnVjdGVkVmFsdWVCbG9jayk7XG4gICAgICAgIHRoaXMuaWRCbG9jay5pc0NvbnN0cnVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudmFsdWVCbG9jay5pc0luZGVmaW5pdGVGb3JtID0gdGhpcy5sZW5CbG9jay5pc0luZGVmaW5pdGVGb3JtO1xuICAgICAgICBjb25zdCByZXN1bHRPZmZzZXQgPSB0aGlzLnZhbHVlQmxvY2suZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsICh0aGlzLmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm0pID8gaW5wdXRMZW5ndGggOiB0aGlzLmxlbkJsb2NrLmxlbmd0aCk7XG4gICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gdGhpcy52YWx1ZUJsb2NrLmVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaWRCbG9jay5lcnJvci5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoICs9IHRoaXMuaWRCbG9jay5ibG9ja0xlbmd0aDtcbiAgICAgICAgaWYgKCF0aGlzLmxlbkJsb2NrLmVycm9yLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggKz0gdGhpcy5sZW5CbG9jay5ibG9ja0xlbmd0aDtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlQmxvY2suZXJyb3IubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLnZhbHVlQmxvY2suYmxvY2tMZW5ndGg7XG4gICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XG4gICAgfVxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy52YWx1ZUJsb2NrLnZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZS50b1N0cmluZyhcImFzY2lpXCIpLnNwbGl0KFwiXFxuXCIpLm1hcCgobykgPT4gYCAgJHtvfWApLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrTmFtZSA9IHRoaXMuaWRCbG9jay50YWdDbGFzcyA9PT0gM1xuICAgICAgICAgICAgPyBgWyR7dGhpcy5pZEJsb2NrLnRhZ051bWJlcn1dYFxuICAgICAgICAgICAgOiB0aGlzLmNvbnN0cnVjdG9yLk5BTUU7XG4gICAgICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoXG4gICAgICAgICAgICA/IGAke2Jsb2NrTmFtZX0gOlxcbiR7dmFsdWVzLmpvaW4oXCJcXG5cIil9YFxuICAgICAgICAgICAgOiBgJHtibG9ja05hbWV9IDpgO1xuICAgIH1cbn1cbl9hJHYgPSBDb25zdHJ1Y3RlZDtcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLkNvbnN0cnVjdGVkID0gX2Ekdjtcbn0pKCk7XG5Db25zdHJ1Y3RlZC5OQU1FID0gXCJDT05TVFJVQ1RFRFwiO1xuXG5jbGFzcyBMb2NhbEVuZE9mQ29udGVudFZhbHVlQmxvY2sgZXh0ZW5kcyBWYWx1ZUJsb2NrIHtcbiAgICBmcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgX2lucHV0TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBpbnB1dE9mZnNldDtcbiAgICB9XG4gICAgdG9CRVIoX3NpemVPbmx5KSB7XG4gICAgICAgIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gICAgfVxufVxuTG9jYWxFbmRPZkNvbnRlbnRWYWx1ZUJsb2NrLm92ZXJyaWRlID0gXCJFbmRPZkNvbnRlbnRWYWx1ZUJsb2NrXCI7XG5cbnZhciBfYSR1O1xuY2xhc3MgRW5kT2ZDb250ZW50IGV4dGVuZHMgQmFzZUJsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycywgTG9jYWxFbmRPZkNvbnRlbnRWYWx1ZUJsb2NrKTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDA7XG4gICAgfVxufVxuX2EkdSA9IEVuZE9mQ29udGVudDtcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLkVuZE9mQ29udGVudCA9IF9hJHU7XG59KSgpO1xuRW5kT2ZDb250ZW50Lk5BTUUgPSBFTkRfT0ZfQ09OVEVOVF9OQU1FO1xuXG52YXIgX2EkdDtcbmNsYXNzIE51bGwgZXh0ZW5kcyBCYXNlQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzLCBWYWx1ZUJsb2NrKTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDU7XG4gICAgfVxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5sZW5CbG9jay5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiTm9uLXplcm8gbGVuZ3RoIG9mIHZhbHVlIGJsb2NrIGZvciBOdWxsIHR5cGVcIik7XG4gICAgICAgIGlmICghdGhpcy5pZEJsb2NrLmVycm9yLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggKz0gdGhpcy5pZEJsb2NrLmJsb2NrTGVuZ3RoO1xuICAgICAgICBpZiAoIXRoaXMubGVuQmxvY2suZXJyb3IubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmxlbkJsb2NrLmJsb2NrTGVuZ3RoO1xuICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoICs9IGlucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoKGlucHV0T2Zmc2V0ICsgaW5wdXRMZW5ndGgpID4gaW5wdXRCdWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRW5kIG9mIGlucHV0IHJlYWNoZWQgYmVmb3JlIG1lc3NhZ2Ugd2FzIGZ1bGx5IGRlY29kZWQgKGluY29uc2lzdGVudCBvZmZzZXQgYW5kIGxlbmd0aCB2YWx1ZXMpXCI7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKTtcbiAgICB9XG4gICAgdG9CRVIoc2l6ZU9ubHksIHdyaXRlcikge1xuICAgICAgICBjb25zdCByZXRCdWYgPSBuZXcgQXJyYXlCdWZmZXIoMik7XG4gICAgICAgIGlmICghc2l6ZU9ubHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheShyZXRCdWYpO1xuICAgICAgICAgICAgcmV0Vmlld1swXSA9IDB4MDU7XG4gICAgICAgICAgICByZXRWaWV3WzFdID0gMHgwMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JpdGVyKSB7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGUocmV0QnVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0QnVmO1xuICAgIH1cbiAgICBvbkFzY2lpRW5jb2RpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9YDtcbiAgICB9XG59XG5fYSR0ID0gTnVsbDtcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLk51bGwgPSBfYSR0O1xufSkoKTtcbk51bGwuTkFNRSA9IFwiTlVMTFwiO1xuXG5jbGFzcyBMb2NhbEJvb2xlYW5WYWx1ZUJsb2NrIGV4dGVuZHMgSGV4QmxvY2soVmFsdWVCbG9jaykge1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBvY3RldCBvZiB0aGlzLnZhbHVlSGV4Vmlldykge1xuICAgICAgICAgICAgaWYgKG9jdGV0ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVIZXhWaWV3WzBdID0gdmFsdWUgPyAweEZGIDogMHgwMDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSwgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLnZhbHVlSGV4KSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkocGFyYW1ldGVycy52YWx1ZUhleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xuICAgICAgICBjb25zdCBpbnB1dFZpZXcgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGlucHV0QnVmZmVyKTtcbiAgICAgICAgaWYgKCFjaGVja0J1ZmZlclBhcmFtcyh0aGlzLCBpbnB1dFZpZXcsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IGlucHV0Vmlldy5zdWJhcnJheShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aCk7XG4gICAgICAgIGlmIChpbnB1dExlbmd0aCA+IDEpXG4gICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2goXCJCb29sZWFuIHZhbHVlIGVuY29kZWQgaW4gbW9yZSB0aGVuIDEgb2N0ZXRcIik7XG4gICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gdHJ1ZTtcbiAgICAgICAgcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxEZWNvZGVUQy5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoID0gaW5wdXRMZW5ndGg7XG4gICAgICAgIHJldHVybiAoaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aCk7XG4gICAgfVxuICAgIHRvQkVSKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUhleFZpZXcuc2xpY2UoKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5Mb2NhbEJvb2xlYW5WYWx1ZUJsb2NrLk5BTUUgPSBcIkJvb2xlYW5WYWx1ZUJsb2NrXCI7XG5cbnZhciBfYSRzO1xuY2xhc3MgQm9vbGVhbiBleHRlbmRzIEJhc2VCbG9jayB7XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlQmxvY2sudmFsdWU7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycywgTG9jYWxCb29sZWFuVmFsdWVCbG9jayk7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAxO1xuICAgIH1cbiAgICBvbkFzY2lpRW5jb2RpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9IDogJHt0aGlzLmdldFZhbHVlfWA7XG4gICAgfVxufVxuX2EkcyA9IEJvb2xlYW47XG4oKCkgPT4ge1xuICAgIHR5cGVTdG9yZS5Cb29sZWFuID0gX2Ekcztcbn0pKCk7XG5Cb29sZWFuLk5BTUUgPSBcIkJPT0xFQU5cIjtcblxuY2xhc3MgTG9jYWxPY3RldFN0cmluZ1ZhbHVlQmxvY2sgZXh0ZW5kcyBIZXhCbG9jayhMb2NhbENvbnN0cnVjdGVkVmFsdWVCbG9jaykge1xuICAgIGNvbnN0cnVjdG9yKHsgaXNDb25zdHJ1Y3RlZCA9IGZhbHNlLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5pc0NvbnN0cnVjdGVkID0gaXNDb25zdHJ1Y3RlZDtcbiAgICB9XG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XG4gICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzSGV4T25seSA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzdWx0T2Zmc2V0ID0gTG9jYWxDb25zdHJ1Y3RlZFZhbHVlQmxvY2sucHJvdG90eXBlLmZyb21CRVIuY2FsbCh0aGlzLCBpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tOYW1lID0gdGhpcy52YWx1ZVtpXS5jb25zdHJ1Y3Rvci5OQU1FO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2tOYW1lID09PSBFTkRfT0ZfQ09OVEVOVF9OQU1FKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW5kZWZpbml0ZUZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gXCJFbmRPZkNvbnRlbnQgaXMgdW5leHBlY3RlZCwgT0NURVQgU1RSSU5HIG1heSBjb25zaXN0cyBvZiBPQ1RFVCBTVFJJTkdzIG9ubHlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEJsb2NrTmFtZSAhPT0gT0NURVRfU1RSSU5HX05BTUUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiT0NURVQgU1RSSU5HIG1heSBjb25zaXN0cyBvZiBPQ1RFVCBTVFJJTkdzIG9ubHlcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdE9mZnNldCA9IHN1cGVyLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoID0gaW5wdXRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcbiAgICB9XG4gICAgdG9CRVIoc2l6ZU9ubHksIHdyaXRlcikge1xuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuIExvY2FsQ29uc3RydWN0ZWRWYWx1ZUJsb2NrLnByb3RvdHlwZS50b0JFUi5jYWxsKHRoaXMsIHNpemVPbmx5LCB3cml0ZXIpO1xuICAgICAgICByZXR1cm4gc2l6ZU9ubHlcbiAgICAgICAgICAgID8gbmV3IEFycmF5QnVmZmVyKHRoaXMudmFsdWVIZXhWaWV3LmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICA6IHRoaXMudmFsdWVIZXhWaWV3LnNsaWNlKCkuYnVmZmVyO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIGlzQ29uc3RydWN0ZWQ6IHRoaXMuaXNDb25zdHJ1Y3RlZCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5Mb2NhbE9jdGV0U3RyaW5nVmFsdWVCbG9jay5OQU1FID0gXCJPY3RldFN0cmluZ1ZhbHVlQmxvY2tcIjtcblxudmFyIF9hJHI7XG5jbGFzcyBPY3RldFN0cmluZyBleHRlbmRzIEJhc2VCbG9jayB7XG4gICAgY29uc3RydWN0b3IoeyBpZEJsb2NrID0ge30sIGxlbkJsb2NrID0ge30sIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XG4gICAgICAgIHZhciBfYiwgX2M7XG4gICAgICAgIChfYiA9IHBhcmFtZXRlcnMuaXNDb25zdHJ1Y3RlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKHBhcmFtZXRlcnMuaXNDb25zdHJ1Y3RlZCA9ICEhKChfYyA9IHBhcmFtZXRlcnMudmFsdWUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpKTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgIGlzQ29uc3RydWN0ZWQ6IHBhcmFtZXRlcnMuaXNDb25zdHJ1Y3RlZCxcbiAgICAgICAgICAgICAgICAuLi5pZEJsb2NrLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbkJsb2NrOiB7XG4gICAgICAgICAgICAgICAgLi4ubGVuQmxvY2ssXG4gICAgICAgICAgICAgICAgaXNJbmRlZmluaXRlRm9ybTogISFwYXJhbWV0ZXJzLmlzSW5kZWZpbml0ZUZvcm0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucGFyYW1ldGVycyxcbiAgICAgICAgfSwgTG9jYWxPY3RldFN0cmluZ1ZhbHVlQmxvY2spO1xuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gNDtcbiAgICB9XG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudmFsdWVCbG9jay5pc0NvbnN0cnVjdGVkID0gdGhpcy5pZEJsb2NrLmlzQ29uc3RydWN0ZWQ7XG4gICAgICAgIHRoaXMudmFsdWVCbG9jay5pc0luZGVmaW5pdGVGb3JtID0gdGhpcy5sZW5CbG9jay5pc0luZGVmaW5pdGVGb3JtO1xuICAgICAgICBpZiAoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkQmxvY2suZXJyb3IubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggKz0gdGhpcy5pZEJsb2NrLmJsb2NrTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMubGVuQmxvY2suZXJyb3IubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggKz0gdGhpcy5sZW5CbG9jay5ibG9ja0xlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudmFsdWVCbG9jay5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gaW5wdXRCdWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KGlucHV0QnVmZmVyKSA6IGlucHV0QnVmZmVyO1xuICAgICAgICAgICAgY29uc3QgYnVmID0gdmlldy5zdWJhcnJheShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChidWYuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc24gPSBsb2NhbEZyb21CRVIoYnVmLCAwLCBidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc24ub2Zmc2V0ICE9PSAtMSAmJiBhc24ub2Zmc2V0ID09PSBpbnB1dExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gW2Fzbi5yZXN1bHRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5mcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpO1xuICAgIH1cbiAgICBvbkFzY2lpRW5jb2RpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlQmxvY2suaXNDb25zdHJ1Y3RlZCB8fCAodGhpcy52YWx1ZUJsb2NrLnZhbHVlICYmIHRoaXMudmFsdWVCbG9jay52YWx1ZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0ZWQucHJvdG90eXBlLm9uQXNjaWlFbmNvZGluZy5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLk5BTUU7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0hleCh0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3KTtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9IDogJHt2YWx1ZX1gO1xuICAgIH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlkQmxvY2suaXNDb25zdHJ1Y3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXcuc2xpY2UoKS5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBjb250ZW50IG9mIHRoaXMudmFsdWVCbG9jay52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBfYSRyKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaChjb250ZW50LnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLmNvbmNhdChhcnJheSk7XG4gICAgfVxufVxuX2EkciA9IE9jdGV0U3RyaW5nO1xuKCgpID0+IHtcbiAgICB0eXBlU3RvcmUuT2N0ZXRTdHJpbmcgPSBfYSRyO1xufSkoKTtcbk9jdGV0U3RyaW5nLk5BTUUgPSBPQ1RFVF9TVFJJTkdfTkFNRTtcblxuY2xhc3MgTG9jYWxCaXRTdHJpbmdWYWx1ZUJsb2NrIGV4dGVuZHMgSGV4QmxvY2soTG9jYWxDb25zdHJ1Y3RlZFZhbHVlQmxvY2spIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHVudXNlZEJpdHMgPSAwLCBpc0NvbnN0cnVjdGVkID0gZmFsc2UsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLnVudXNlZEJpdHMgPSB1bnVzZWRCaXRzO1xuICAgICAgICB0aGlzLmlzQ29uc3RydWN0ZWQgPSBpc0NvbnN0cnVjdGVkO1xuICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoID0gdGhpcy52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XG4gICAgICAgIGlmICghaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0T2Zmc2V0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdE9mZnNldCA9IExvY2FsQ29uc3RydWN0ZWRWYWx1ZUJsb2NrLnByb3RvdHlwZS5mcm9tQkVSLmNhbGwodGhpcywgaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0T2Zmc2V0ID09PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEJsb2NrTmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLk5BTUU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCbG9ja05hbWUgPT09IEVORF9PRl9DT05URU5UX05BTUUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbmRlZmluaXRlRm9ybSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIkVuZE9mQ29udGVudCBpcyB1bmV4cGVjdGVkLCBCSVQgU1RSSU5HIG1heSBjb25zaXN0cyBvZiBCSVQgU1RSSU5HcyBvbmx5XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCbG9ja05hbWUgIT09IEJJVF9TVFJJTkdfTkFNRSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gXCJCSVQgU1RSSU5HIG1heSBjb25zaXN0cyBvZiBCSVQgU1RSSU5HcyBvbmx5XCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVCbG9jayA9IHZhbHVlLnZhbHVlQmxvY2s7XG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLnVudXNlZEJpdHMgPiAwKSAmJiAodmFsdWVCbG9jay51bnVzZWRCaXRzID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiVXNpbmcgb2YgXFxcInVudXNlZCBiaXRzXFxcIiBpbnNpZGUgY29uc3RydWN0aXZlIEJJVCBTVFJJTkcgYWxsb3dlZCBmb3IgbGVhc3Qgb25lIG9ubHlcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVudXNlZEJpdHMgPSB2YWx1ZUJsb2NrLnVudXNlZEJpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0VmlldyA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpO1xuICAgICAgICBpZiAoIWNoZWNrQnVmZmVyUGFyYW1zKHRoaXMsIGlucHV0VmlldywgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludEJ1ZmZlciA9IGlucHV0Vmlldy5zdWJhcnJheShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aCk7XG4gICAgICAgIHRoaXMudW51c2VkQml0cyA9IGludEJ1ZmZlclswXTtcbiAgICAgICAgaWYgKHRoaXMudW51c2VkQml0cyA+IDcpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIlVudXNlZCBiaXRzIGZvciBCaXRTdHJpbmcgbXVzdCBiZSBpbiByYW5nZSAwLTdcIjtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudW51c2VkQml0cykge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gaW50QnVmZmVyLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoYnVmLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuID0gbG9jYWxGcm9tQkVSKGJ1ZiwgMCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXNuLm9mZnNldCAhPT0gLTEgJiYgYXNuLm9mZnNldCA9PT0gKGlucHV0TGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbYXNuLnJlc3VsdF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSBpbnRCdWZmZXIuc3ViYXJyYXkoMSk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSBpbnRCdWZmZXIubGVuZ3RoO1xuICAgICAgICByZXR1cm4gKGlucHV0T2Zmc2V0ICsgaW5wdXRMZW5ndGgpO1xuICAgIH1cbiAgICB0b0JFUihzaXplT25seSwgd3JpdGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBMb2NhbENvbnN0cnVjdGVkVmFsdWVCbG9jay5wcm90b3R5cGUudG9CRVIuY2FsbCh0aGlzLCBzaXplT25seSwgd3JpdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2l6ZU9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIodGhpcy52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoICsgMSk7XG4gICAgICAgIHJldFZpZXdbMF0gPSB0aGlzLnVudXNlZEJpdHM7XG4gICAgICAgIHJldFZpZXcuc2V0KHRoaXMudmFsdWVIZXhWaWV3LCAxKTtcbiAgICAgICAgcmV0dXJuIHJldFZpZXcuYnVmZmVyO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIHVudXNlZEJpdHM6IHRoaXMudW51c2VkQml0cyxcbiAgICAgICAgICAgIGlzQ29uc3RydWN0ZWQ6IHRoaXMuaXNDb25zdHJ1Y3RlZCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5Mb2NhbEJpdFN0cmluZ1ZhbHVlQmxvY2suTkFNRSA9IFwiQml0U3RyaW5nVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkcTtcbmNsYXNzIEJpdFN0cmluZyBleHRlbmRzIEJhc2VCbG9jayB7XG4gICAgY29uc3RydWN0b3IoeyBpZEJsb2NrID0ge30sIGxlbkJsb2NrID0ge30sIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XG4gICAgICAgIHZhciBfYiwgX2M7XG4gICAgICAgIChfYiA9IHBhcmFtZXRlcnMuaXNDb25zdHJ1Y3RlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKHBhcmFtZXRlcnMuaXNDb25zdHJ1Y3RlZCA9ICEhKChfYyA9IHBhcmFtZXRlcnMudmFsdWUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpKTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgIGlzQ29uc3RydWN0ZWQ6IHBhcmFtZXRlcnMuaXNDb25zdHJ1Y3RlZCxcbiAgICAgICAgICAgICAgICAuLi5pZEJsb2NrLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbkJsb2NrOiB7XG4gICAgICAgICAgICAgICAgLi4ubGVuQmxvY2ssXG4gICAgICAgICAgICAgICAgaXNJbmRlZmluaXRlRm9ybTogISFwYXJhbWV0ZXJzLmlzSW5kZWZpbml0ZUZvcm0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucGFyYW1ldGVycyxcbiAgICAgICAgfSwgTG9jYWxCaXRTdHJpbmdWYWx1ZUJsb2NrKTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDM7XG4gICAgfVxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xuICAgICAgICB0aGlzLnZhbHVlQmxvY2suaXNDb25zdHJ1Y3RlZCA9IHRoaXMuaWRCbG9jay5pc0NvbnN0cnVjdGVkO1xuICAgICAgICB0aGlzLnZhbHVlQmxvY2suaXNJbmRlZmluaXRlRm9ybSA9IHRoaXMubGVuQmxvY2suaXNJbmRlZmluaXRlRm9ybTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCk7XG4gICAgfVxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVCbG9jay5pc0NvbnN0cnVjdGVkIHx8ICh0aGlzLnZhbHVlQmxvY2sudmFsdWUgJiYgdGhpcy52YWx1ZUJsb2NrLnZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RlZC5wcm90b3R5cGUub25Bc2NpaUVuY29kaW5nLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBiaXRzID0gW107XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUhleCA9IHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXc7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgdmFsdWVIZXgpIHtcbiAgICAgICAgICAgICAgICBiaXRzLnB1c2goYnl0ZS50b1N0cmluZygyKS5wYWRTdGFydCg4LCBcIjBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYml0c1N0ciA9IGJpdHMuam9pbihcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLk5BTUU7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGJpdHNTdHIuc3Vic3RyaW5nKDAsIGJpdHNTdHIubGVuZ3RoIC0gdGhpcy52YWx1ZUJsb2NrLnVudXNlZEJpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIGAke25hbWV9IDogJHt2YWx1ZX1gO1xuICAgICAgICB9XG4gICAgfVxufVxuX2EkcSA9IEJpdFN0cmluZztcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLkJpdFN0cmluZyA9IF9hJHE7XG59KSgpO1xuQml0U3RyaW5nLk5BTUUgPSBCSVRfU1RSSU5HX05BTUU7XG5cbnZhciBfYSRwO1xuZnVuY3Rpb24gdmlld0FkZChmaXJzdCwgc2Vjb25kKSB7XG4gICAgY29uc3QgYyA9IG5ldyBVaW50OEFycmF5KFswXSk7XG4gICAgY29uc3QgZmlyc3RWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZmlyc3QpO1xuICAgIGNvbnN0IHNlY29uZFZpZXcgPSBuZXcgVWludDhBcnJheShzZWNvbmQpO1xuICAgIGxldCBmaXJzdFZpZXdDb3B5ID0gZmlyc3RWaWV3LnNsaWNlKDApO1xuICAgIGNvbnN0IGZpcnN0Vmlld0NvcHlMZW5ndGggPSBmaXJzdFZpZXdDb3B5Lmxlbmd0aCAtIDE7XG4gICAgY29uc3Qgc2Vjb25kVmlld0NvcHkgPSBzZWNvbmRWaWV3LnNsaWNlKDApO1xuICAgIGNvbnN0IHNlY29uZFZpZXdDb3B5TGVuZ3RoID0gc2Vjb25kVmlld0NvcHkubGVuZ3RoIC0gMTtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIGNvbnN0IG1heCA9IChzZWNvbmRWaWV3Q29weUxlbmd0aCA8IGZpcnN0Vmlld0NvcHlMZW5ndGgpID8gZmlyc3RWaWV3Q29weUxlbmd0aCA6IHNlY29uZFZpZXdDb3B5TGVuZ3RoO1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBmb3IgKGxldCBpID0gbWF4OyBpID49IDA7IGktLSwgY291bnRlcisrKSB7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgY2FzZSAoY291bnRlciA8IHNlY29uZFZpZXdDb3B5Lmxlbmd0aCk6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaXJzdFZpZXdDb3B5W2ZpcnN0Vmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSArIHNlY29uZFZpZXdDb3B5W3NlY29uZFZpZXdDb3B5TGVuZ3RoIC0gY291bnRlcl0gKyBjWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpcnN0Vmlld0NvcHlbZmlyc3RWaWV3Q29weUxlbmd0aCAtIGNvdW50ZXJdICsgY1swXTtcbiAgICAgICAgfVxuICAgICAgICBjWzBdID0gdmFsdWUgLyAxMDtcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIChjb3VudGVyID49IGZpcnN0Vmlld0NvcHkubGVuZ3RoKTpcbiAgICAgICAgICAgICAgICBmaXJzdFZpZXdDb3B5ID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxDb25jYXRWaWV3KG5ldyBVaW50OEFycmF5KFt2YWx1ZSAlIDEwXSksIGZpcnN0Vmlld0NvcHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBmaXJzdFZpZXdDb3B5W2ZpcnN0Vmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSA9IHZhbHVlICUgMTA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNbMF0gPiAwKVxuICAgICAgICBmaXJzdFZpZXdDb3B5ID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxDb25jYXRWaWV3KGMsIGZpcnN0Vmlld0NvcHkpO1xuICAgIHJldHVybiBmaXJzdFZpZXdDb3B5O1xufVxuZnVuY3Rpb24gcG93ZXIyKG4pIHtcbiAgICBpZiAobiA+PSBwb3dlcnMyLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBwID0gcG93ZXJzMi5sZW5ndGg7IHAgPD0gbjsgcCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkoWzBdKTtcbiAgICAgICAgICAgIGxldCBkaWdpdHMgPSAocG93ZXJzMltwIC0gMV0pLnNsaWNlKDApO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IChkaWdpdHMubGVuZ3RoIC0gMSk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBuZXcgVWludDhBcnJheShbKGRpZ2l0c1tpXSA8PCAxKSArIGNbMF1dKTtcbiAgICAgICAgICAgICAgICBjWzBdID0gbmV3VmFsdWVbMF0gLyAxMDtcbiAgICAgICAgICAgICAgICBkaWdpdHNbaV0gPSBuZXdWYWx1ZVswXSAlIDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNbMF0gPiAwKVxuICAgICAgICAgICAgICAgIGRpZ2l0cyA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsQ29uY2F0VmlldyhjLCBkaWdpdHMpO1xuICAgICAgICAgICAgcG93ZXJzMi5wdXNoKGRpZ2l0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvd2VyczJbbl07XG59XG5mdW5jdGlvbiB2aWV3U3ViKGZpcnN0LCBzZWNvbmQpIHtcbiAgICBsZXQgYiA9IDA7XG4gICAgY29uc3QgZmlyc3RWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZmlyc3QpO1xuICAgIGNvbnN0IHNlY29uZFZpZXcgPSBuZXcgVWludDhBcnJheShzZWNvbmQpO1xuICAgIGNvbnN0IGZpcnN0Vmlld0NvcHkgPSBmaXJzdFZpZXcuc2xpY2UoMCk7XG4gICAgY29uc3QgZmlyc3RWaWV3Q29weUxlbmd0aCA9IGZpcnN0Vmlld0NvcHkubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBzZWNvbmRWaWV3Q29weSA9IHNlY29uZFZpZXcuc2xpY2UoMCk7XG4gICAgY29uc3Qgc2Vjb25kVmlld0NvcHlMZW5ndGggPSBzZWNvbmRWaWV3Q29weS5sZW5ndGggLSAxO1xuICAgIGxldCB2YWx1ZTtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHNlY29uZFZpZXdDb3B5TGVuZ3RoOyBpID49IDA7IGktLSwgY291bnRlcisrKSB7XG4gICAgICAgIHZhbHVlID0gZmlyc3RWaWV3Q29weVtmaXJzdFZpZXdDb3B5TGVuZ3RoIC0gY291bnRlcl0gLSBzZWNvbmRWaWV3Q29weVtzZWNvbmRWaWV3Q29weUxlbmd0aCAtIGNvdW50ZXJdIC0gYjtcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlICh2YWx1ZSA8IDApOlxuICAgICAgICAgICAgICAgIGIgPSAxO1xuICAgICAgICAgICAgICAgIGZpcnN0Vmlld0NvcHlbZmlyc3RWaWV3Q29weUxlbmd0aCAtIGNvdW50ZXJdID0gdmFsdWUgKyAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYiA9IDA7XG4gICAgICAgICAgICAgICAgZmlyc3RWaWV3Q29weVtmaXJzdFZpZXdDb3B5TGVuZ3RoIC0gY291bnRlcl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYiA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IChmaXJzdFZpZXdDb3B5TGVuZ3RoIC0gc2Vjb25kVmlld0NvcHlMZW5ndGggKyAxKTsgaSA+PSAwOyBpLS0sIGNvdW50ZXIrKykge1xuICAgICAgICAgICAgdmFsdWUgPSBmaXJzdFZpZXdDb3B5W2ZpcnN0Vmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSAtIGI7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgYiA9IDE7XG4gICAgICAgICAgICAgICAgZmlyc3RWaWV3Q29weVtmaXJzdFZpZXdDb3B5TGVuZ3RoIC0gY291bnRlcl0gPSB2YWx1ZSArIDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYiA9IDA7XG4gICAgICAgICAgICAgICAgZmlyc3RWaWV3Q29weVtmaXJzdFZpZXdDb3B5TGVuZ3RoIC0gY291bnRlcl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlyc3RWaWV3Q29weS5zbGljZSgpO1xufVxuY2xhc3MgTG9jYWxJbnRlZ2VyVmFsdWVCbG9jayBleHRlbmRzIEhleEJsb2NrKFZhbHVlQmxvY2spIHtcbiAgICBzZXRWYWx1ZUhleCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVIZXhWaWV3Lmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2goXCJUb28gYmlnIEludGVnZXIgZm9yIGRlY29kaW5nLCBoZXggb25seVwiKTtcbiAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlRGVjID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlRGVjID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxEZWNvZGVUQy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl92YWx1ZURlYyA9IDA7XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLnZhbHVlSGV4KSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlSGV4KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVEZWMgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgdmFsdWVEZWModikge1xuICAgICAgICB0aGlzLl92YWx1ZURlYyA9IHY7XG4gICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkocHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxFbmNvZGVUQyh2KSk7XG4gICAgfVxuICAgIGdldCB2YWx1ZURlYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlRGVjO1xuICAgIH1cbiAgICBmcm9tREVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgsIGV4cGVjdGVkTGVuZ3RoID0gMCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCk7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgICAgY29uc3QgdmlldyA9IHRoaXMudmFsdWVIZXhWaWV3O1xuICAgICAgICBpZiAoKHZpZXdbMF0gPT09IDB4MDApICYmICgodmlld1sxXSAmIDB4ODApICE9PSAwKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSB2aWV3LnN1YmFycmF5KDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcubGVuZ3RoIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChleHBlY3RlZExlbmd0aCAtIHZpZXcubGVuZ3RoKSA+IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZExlbmd0aCA9IHZpZXcubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSB2aWV3LnN1YmFycmF5KGV4cGVjdGVkTGVuZ3RoIC0gdmlldy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICB0b0RFUihzaXplT25seSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZhbHVlSGV4VmlldztcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlICgodmlld1swXSAmIDB4ODApICE9PSAwKTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRWaWV3WzBdID0gMHgwMDtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFZpZXcuc2V0KHZpZXcsIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IHVwZGF0ZWRWaWV3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKCh2aWV3WzBdID09PSAweDAwKSAmJiAoKHZpZXdbMV0gJiAweDgwKSA9PT0gMCkpOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSB0aGlzLnZhbHVlSGV4Vmlldy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9CRVIoc2l6ZU9ubHkpO1xuICAgIH1cbiAgICBmcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0T2Zmc2V0ID0gc3VwZXIuZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKTtcbiAgICAgICAgaWYgKHJlc3VsdE9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRWYWx1ZUhleCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xuICAgIH1cbiAgICB0b0JFUihzaXplT25seSkge1xuICAgICAgICByZXR1cm4gc2l6ZU9ubHlcbiAgICAgICAgICAgID8gbmV3IEFycmF5QnVmZmVyKHRoaXMudmFsdWVIZXhWaWV3Lmxlbmd0aClcbiAgICAgICAgICAgIDogdGhpcy52YWx1ZUhleFZpZXcuc2xpY2UoKS5idWZmZXI7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgdmFsdWVEZWM6IHRoaXMudmFsdWVEZWMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBmaXJzdEJpdCA9ICh0aGlzLnZhbHVlSGV4Vmlldy5sZW5ndGggKiA4KSAtIDE7XG4gICAgICAgIGxldCBkaWdpdHMgPSBuZXcgVWludDhBcnJheSgodGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoICogOCkgLyAzKTtcbiAgICAgICAgbGV0IGJpdE51bWJlciA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50Qnl0ZTtcbiAgICAgICAgY29uc3QgYXNuMVZpZXcgPSB0aGlzLnZhbHVlSGV4VmlldztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGxldCBmbGFnID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGJ5dGVOdW1iZXIgPSAoYXNuMVZpZXcuYnl0ZUxlbmd0aCAtIDEpOyBieXRlTnVtYmVyID49IDA7IGJ5dGVOdW1iZXItLSkge1xuICAgICAgICAgICAgY3VycmVudEJ5dGUgPSBhc24xVmlld1tieXRlTnVtYmVyXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChjdXJyZW50Qnl0ZSAmIDEpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYml0TnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGZpcnN0Qml0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0cyA9IHZpZXdTdWIocG93ZXIyKGJpdE51bWJlciksIGRpZ2l0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXCItXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0cyA9IHZpZXdBZGQoZGlnaXRzLCBwb3dlcjIoYml0TnVtYmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYml0TnVtYmVyKys7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWdpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkaWdpdHNbaV0pXG4gICAgICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZmxhZylcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZGlnaXRzU3RyaW5nLmNoYXJBdChkaWdpdHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFnID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJlc3VsdCArPSBkaWdpdHNTdHJpbmcuY2hhckF0KDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbl9hJHAgPSBMb2NhbEludGVnZXJWYWx1ZUJsb2NrO1xuTG9jYWxJbnRlZ2VyVmFsdWVCbG9jay5OQU1FID0gXCJJbnRlZ2VyVmFsdWVCbG9ja1wiO1xuKCgpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2EkcC5wcm90b3R5cGUsIFwidmFsdWVIZXhcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHYpO1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUhleCgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlSGV4Vmlldy5zbGljZSgpLmJ1ZmZlcjtcbiAgICAgICAgfSxcbiAgICB9KTtcbn0pKCk7XG5cbnZhciBfYSRvO1xuY2xhc3MgSW50ZWdlciBleHRlbmRzIEJhc2VCbG9jayB7XG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMsIExvY2FsSW50ZWdlclZhbHVlQmxvY2spO1xuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMjtcbiAgICB9XG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIGFzc2VydEJpZ0ludCgpO1xuICAgICAgICByZXR1cm4gQmlnSW50KHRoaXMudmFsdWVCbG9jay50b1N0cmluZygpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaWdJbnQodmFsdWUpIHtcbiAgICAgICAgYXNzZXJ0QmlnSW50KCk7XG4gICAgICAgIGNvbnN0IGJpZ0ludFZhbHVlID0gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFZpZXdXcml0ZXIoKTtcbiAgICAgICAgY29uc3QgaGV4ID0gYmlnSW50VmFsdWUudG9TdHJpbmcoMTYpLnJlcGxhY2UoL14tLywgXCJcIik7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShwdnRzdXRpbHNfX25hbWVzcGFjZS5Db252ZXJ0LkZyb21IZXgoaGV4KSk7XG4gICAgICAgIGlmIChiaWdJbnRWYWx1ZSA8IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gbmV3IFVpbnQ4QXJyYXkodmlldy5sZW5ndGggKyAodmlld1swXSAmIDB4ODAgPyAxIDogMCkpO1xuICAgICAgICAgICAgZmlyc3RbMF0gfD0gMHg4MDtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0SW50ID0gQmlnSW50KGAweCR7cHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0hleChmaXJzdCl9YCk7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRJbnQgPSBmaXJzdEludCArIGJpZ0ludFZhbHVlO1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShwdnRzdXRpbHNfX25hbWVzcGFjZS5Db252ZXJ0LkZyb21IZXgoc2Vjb25kSW50LnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICAgICAgc2Vjb25kWzBdIHw9IDB4ODA7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGUoc2Vjb25kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2aWV3WzBdICYgMHg4MCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZShuZXcgVWludDhBcnJheShbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci53cml0ZSh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBuZXcgX2Ekbyh7IHZhbHVlSGV4OiB3cml0ZXIuZmluYWwoKSB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgY29udmVydFRvREVSKCkge1xuICAgICAgICBjb25zdCBpbnRlZ2VyID0gbmV3IF9hJG8oeyB2YWx1ZUhleDogdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyB9KTtcbiAgICAgICAgaW50ZWdlci52YWx1ZUJsb2NrLnRvREVSKCk7XG4gICAgICAgIHJldHVybiBpbnRlZ2VyO1xuICAgIH1cbiAgICBjb252ZXJ0RnJvbURFUigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfYSRvKHtcbiAgICAgICAgICAgIHZhbHVlSGV4OiB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3WzBdID09PSAwXG4gICAgICAgICAgICAgICAgPyB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3LnN1YmFycmF5KDEpXG4gICAgICAgICAgICAgICAgOiB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25Bc2NpaUVuY29kaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfSA6ICR7dGhpcy52YWx1ZUJsb2NrLnRvU3RyaW5nKCl9YDtcbiAgICB9XG59XG5fYSRvID0gSW50ZWdlcjtcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLkludGVnZXIgPSBfYSRvO1xufSkoKTtcbkludGVnZXIuTkFNRSA9IFwiSU5URUdFUlwiO1xuXG52YXIgX2EkbjtcbmNsYXNzIEVudW1lcmF0ZWQgZXh0ZW5kcyBJbnRlZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAxMDtcbiAgICB9XG59XG5fYSRuID0gRW51bWVyYXRlZDtcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLkVudW1lcmF0ZWQgPSBfYSRuO1xufSkoKTtcbkVudW1lcmF0ZWQuTkFNRSA9IFwiRU5VTUVSQVRFRFwiO1xuXG5jbGFzcyBMb2NhbFNpZFZhbHVlQmxvY2sgZXh0ZW5kcyBIZXhCbG9jayhWYWx1ZUJsb2NrKSB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZURlYyA9IC0xLCBpc0ZpcnN0U2lkID0gZmFsc2UsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLnZhbHVlRGVjID0gdmFsdWVEZWM7XG4gICAgICAgIHRoaXMuaXNGaXJzdFNpZCA9IGlzRmlyc3RTaWQ7XG4gICAgfVxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xuICAgICAgICBpZiAoIWlucHV0TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXRWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XG4gICAgICAgIGlmICghY2hlY2tCdWZmZXJQYXJhbXModGhpcywgaW5wdXRWaWV3LCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW50QnVmZmVyID0gaW5wdXRWaWV3LnN1YmFycmF5KGlucHV0T2Zmc2V0LCBpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKTtcbiAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSBuZXcgVWludDhBcnJheShpbnB1dExlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUhleFZpZXdbaV0gPSBpbnRCdWZmZXJbaV0gJiAweDdGO1xuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCsrO1xuICAgICAgICAgICAgaWYgKChpbnRCdWZmZXJbaV0gJiAweDgwKSA9PT0gMHgwMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZW1wVmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYmxvY2tMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmxvY2tMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcFZpZXdbaV0gPSB0aGlzLnZhbHVlSGV4Vmlld1tpXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IHRlbXBWaWV3O1xuICAgICAgICBpZiAoKGludEJ1ZmZlclt0aGlzLmJsb2NrTGVuZ3RoIC0gMV0gJiAweDgwKSAhPT0gMHgwMCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRW5kIG9mIGlucHV0IHJlYWNoZWQgYmVmb3JlIG1lc3NhZ2Ugd2FzIGZ1bGx5IGRlY29kZWRcIjtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52YWx1ZUhleFZpZXdbMF0gPT09IDB4MDApXG4gICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2goXCJOZWVkbGVzc2x5IGxvbmcgZm9ybWF0IG9mIFNJRCBlbmNvZGluZ1wiKTtcbiAgICAgICAgaWYgKHRoaXMuYmxvY2tMZW5ndGggPD0gOClcbiAgICAgICAgICAgIHRoaXMudmFsdWVEZWMgPSBwdnV0aWxzX19uYW1lc3BhY2UudXRpbEZyb21CYXNlKHRoaXMudmFsdWVIZXhWaWV3LCA3KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzSGV4T25seSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2goXCJUb28gYmlnIFNJRCBmb3IgZGVjb2RpbmcsIGhleCBvbmx5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaW5wdXRPZmZzZXQgKyB0aGlzLmJsb2NrTGVuZ3RoKTtcbiAgICB9XG4gICAgc2V0IHZhbHVlQmlnSW50KHZhbHVlKSB7XG4gICAgICAgIGFzc2VydEJpZ0ludCgpO1xuICAgICAgICBsZXQgYml0cyA9IEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoMik7XG4gICAgICAgIHdoaWxlIChiaXRzLmxlbmd0aCAlIDcpIHtcbiAgICAgICAgICAgIGJpdHMgPSBcIjBcIiArIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaXRzLmxlbmd0aCAvIDcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBieXRlc1tpXSA9IHBhcnNlSW50KGJpdHMuc2xpY2UoaSAqIDcsIGkgKiA3ICsgNyksIDIpICsgKGkgKyAxIDwgYnl0ZXMubGVuZ3RoID8gMHg4MCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJvbUJFUihieXRlcy5idWZmZXIsIDAsIGJ5dGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIHRvQkVSKHNpemVPbmx5KSB7XG4gICAgICAgIGlmICh0aGlzLmlzSGV4T25seSkge1xuICAgICAgICAgICAgaWYgKHNpemVPbmx5KVxuICAgICAgICAgICAgICAgIHJldHVybiAobmV3IEFycmF5QnVmZmVyKHRoaXMudmFsdWVIZXhWaWV3LmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgICAgIGNvbnN0IGN1clZpZXcgPSB0aGlzLnZhbHVlSGV4VmlldztcbiAgICAgICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrTGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHRoaXMuYmxvY2tMZW5ndGggLSAxKTsgaSsrKVxuICAgICAgICAgICAgICAgIHJldFZpZXdbaV0gPSBjdXJWaWV3W2ldIHwgMHg4MDtcbiAgICAgICAgICAgIHJldFZpZXdbdGhpcy5ibG9ja0xlbmd0aCAtIDFdID0gY3VyVmlld1t0aGlzLmJsb2NrTGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gcmV0Vmlldy5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RlZEJ1ZiA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsVG9CYXNlKHRoaXMudmFsdWVEZWMsIDcpO1xuICAgICAgICBpZiAoZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gXCJFcnJvciBkdXJpbmcgZW5jb2RpbmcgU0lEIHZhbHVlXCI7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkQnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICBpZiAoIXNpemVPbmx5KSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkVmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWRCdWYpO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgcmV0Vmlld1tpXSA9IGVuY29kZWRWaWV3W2ldIHwgMHg4MDtcbiAgICAgICAgICAgIHJldFZpZXdbbGVuXSA9IGVuY29kZWRWaWV3W2xlbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldFZpZXc7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuaXNIZXhPbmx5KVxuICAgICAgICAgICAgcmVzdWx0ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0hleCh0aGlzLnZhbHVlSGV4Vmlldyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNGaXJzdFNpZCkge1xuICAgICAgICAgICAgICAgIGxldCBzaWRWYWx1ZSA9IHRoaXMudmFsdWVEZWM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVEZWMgPD0gMzkpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFwiMC5cIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVEZWMgPD0gNzkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFwiMS5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZFZhbHVlIC09IDQwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXCIyLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lkVmFsdWUgLT0gODA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNpZFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy52YWx1ZURlYy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgdmFsdWVEZWM6IHRoaXMudmFsdWVEZWMsXG4gICAgICAgICAgICBpc0ZpcnN0U2lkOiB0aGlzLmlzRmlyc3RTaWQsXG4gICAgICAgIH07XG4gICAgfVxufVxuTG9jYWxTaWRWYWx1ZUJsb2NrLk5BTUUgPSBcInNpZEJsb2NrXCI7XG5cbmNsYXNzIExvY2FsT2JqZWN0SWRlbnRpZmllclZhbHVlQmxvY2sgZXh0ZW5kcyBWYWx1ZUJsb2NrIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlID0gRU1QVFlfU1RSSU5HLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XG4gICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSBpbnB1dE9mZnNldDtcbiAgICAgICAgd2hpbGUgKGlucHV0TGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc2lkQmxvY2sgPSBuZXcgTG9jYWxTaWRWYWx1ZUJsb2NrKCk7XG4gICAgICAgICAgICByZXN1bHRPZmZzZXQgPSBzaWRCbG9jay5mcm9tQkVSKGlucHV0QnVmZmVyLCByZXN1bHRPZmZzZXQsIGlucHV0TGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHNpZEJsb2NrLmVycm9yO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgc2lkQmxvY2suaXNGaXJzdFNpZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoICs9IHNpZEJsb2NrLmJsb2NrTGVuZ3RoO1xuICAgICAgICAgICAgaW5wdXRMZW5ndGggLT0gc2lkQmxvY2suYmxvY2tMZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLnB1c2goc2lkQmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XG4gICAgfVxuICAgIHRvQkVSKHNpemVPbmx5KSB7XG4gICAgICAgIGNvbnN0IHJldEJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUJ1ZiA9IHRoaXMudmFsdWVbaV0udG9CRVIoc2l6ZU9ubHkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlQnVmLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gdGhpcy52YWx1ZVtpXS5lcnJvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0QnVmZmVycy5wdXNoKHZhbHVlQnVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KHJldEJ1ZmZlcnMpO1xuICAgIH1cbiAgICBmcm9tU3RyaW5nKHN0cmluZykge1xuICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIGxldCBwb3MxID0gMDtcbiAgICAgICAgbGV0IHBvczIgPSAwO1xuICAgICAgICBsZXQgc2lkID0gXCJcIjtcbiAgICAgICAgbGV0IGZsYWcgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcG9zMiA9IHN0cmluZy5pbmRleE9mKFwiLlwiLCBwb3MxKTtcbiAgICAgICAgICAgIGlmIChwb3MyID09PSAtMSlcbiAgICAgICAgICAgICAgICBzaWQgPSBzdHJpbmcuc3Vic3RyaW5nKHBvczEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNpZCA9IHN0cmluZy5zdWJzdHJpbmcocG9zMSwgcG9zMik7XG4gICAgICAgICAgICBwb3MxID0gcG9zMiArIDE7XG4gICAgICAgICAgICBpZiAoZmxhZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZEJsb2NrID0gdGhpcy52YWx1ZVswXTtcbiAgICAgICAgICAgICAgICBsZXQgcGx1cyA9IDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzaWRCbG9jay52YWx1ZURlYykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1cyA9IDQwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdXMgPSA4MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRTSUQgPSBwYXJzZUludChzaWQsIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VkU0lEKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNpZEJsb2NrLnZhbHVlRGVjID0gcGFyc2VkU0lEICsgcGx1cztcbiAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWRCbG9jayA9IG5ldyBMb2NhbFNpZFZhbHVlQmxvY2soKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lkID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QmlnSW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZFZhbHVlID0gQmlnSW50KHNpZCk7XG4gICAgICAgICAgICAgICAgICAgIHNpZEJsb2NrLnZhbHVlQmlnSW50ID0gc2lkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaWRCbG9jay52YWx1ZURlYyA9IHBhcnNlSW50KHNpZCwgMTApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oc2lkQmxvY2sudmFsdWVEZWMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZEJsb2NrLmlzRmlyc3RTaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5wdXNoKHNpZEJsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAocG9zMiAhPT0gLTEpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGxldCBpc0hleE9ubHkgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpc0hleE9ubHkgPSB0aGlzLnZhbHVlW2ldLmlzSGV4T25seTtcbiAgICAgICAgICAgIGxldCBzaWRTdHIgPSB0aGlzLnZhbHVlW2ldLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoaSAhPT0gMClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBgJHtyZXN1bHR9LmA7XG4gICAgICAgICAgICBpZiAoaXNIZXhPbmx5KSB7XG4gICAgICAgICAgICAgICAgc2lkU3RyID0gYHske3NpZFN0cn19YDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZVtpXS5pc0ZpcnN0U2lkKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBgMi57JHtzaWRTdHJ9IC0gODB9YDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzaWRTdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNpZFN0cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHNpZEFycmF5OiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvYmplY3Quc2lkQXJyYXkucHVzaCh0aGlzLnZhbHVlW2ldLnRvSlNPTigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbn1cbkxvY2FsT2JqZWN0SWRlbnRpZmllclZhbHVlQmxvY2suTkFNRSA9IFwiT2JqZWN0SWRlbnRpZmllclZhbHVlQmxvY2tcIjtcblxudmFyIF9hJG07XG5jbGFzcyBPYmplY3RJZGVudGlmaWVyIGV4dGVuZHMgQmFzZUJsb2NrIHtcbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVCbG9jay50b1N0cmluZygpO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlQmxvY2suZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzLCBMb2NhbE9iamVjdElkZW50aWZpZXJWYWx1ZUJsb2NrKTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDY7XG4gICAgfVxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IuTkFNRX0gOiAke3RoaXMudmFsdWVCbG9jay50b1N0cmluZygpIHx8IFwiZW1wdHlcIn1gO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmdldFZhbHVlKCksXG4gICAgICAgIH07XG4gICAgfVxufVxuX2EkbSA9IE9iamVjdElkZW50aWZpZXI7XG4oKCkgPT4ge1xuICAgIHR5cGVTdG9yZS5PYmplY3RJZGVudGlmaWVyID0gX2EkbTtcbn0pKCk7XG5PYmplY3RJZGVudGlmaWVyLk5BTUUgPSBcIk9CSkVDVCBJREVOVElGSUVSXCI7XG5cbmNsYXNzIExvY2FsUmVsYXRpdmVTaWRWYWx1ZUJsb2NrIGV4dGVuZHMgSGV4QmxvY2soTG9jYWxCYXNlQmxvY2spIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlRGVjID0gMCwgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMudmFsdWVEZWMgPSB2YWx1ZURlYztcbiAgICB9XG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XG4gICAgICAgIGlmIChpbnB1dExlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBpbnB1dE9mZnNldDtcbiAgICAgICAgY29uc3QgaW5wdXRWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XG4gICAgICAgIGlmICghY2hlY2tCdWZmZXJQYXJhbXModGhpcywgaW5wdXRWaWV3LCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBjb25zdCBpbnRCdWZmZXIgPSBpbnB1dFZpZXcuc3ViYXJyYXkoaW5wdXRPZmZzZXQsIGlucHV0T2Zmc2V0ICsgaW5wdXRMZW5ndGgpO1xuICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KGlucHV0TGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlSGV4Vmlld1tpXSA9IGludEJ1ZmZlcltpXSAmIDB4N0Y7XG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoKys7XG4gICAgICAgICAgICBpZiAoKGludEJ1ZmZlcltpXSAmIDB4ODApID09PSAweDAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlbXBWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5ibG9ja0xlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ibG9ja0xlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGVtcFZpZXdbaV0gPSB0aGlzLnZhbHVlSGV4Vmlld1tpXTtcbiAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSB0ZW1wVmlldztcbiAgICAgICAgaWYgKChpbnRCdWZmZXJbdGhpcy5ibG9ja0xlbmd0aCAtIDFdICYgMHg4MCkgIT09IDB4MDApIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIkVuZCBvZiBpbnB1dCByZWFjaGVkIGJlZm9yZSBtZXNzYWdlIHdhcyBmdWxseSBkZWNvZGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWVIZXhWaWV3WzBdID09PSAweDAwKVxuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiTmVlZGxlc3NseSBsb25nIGZvcm1hdCBvZiBTSUQgZW5jb2RpbmdcIik7XG4gICAgICAgIGlmICh0aGlzLmJsb2NrTGVuZ3RoIDw9IDgpXG4gICAgICAgICAgICB0aGlzLnZhbHVlRGVjID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxGcm9tQmFzZSh0aGlzLnZhbHVlSGV4VmlldywgNyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc0hleE9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiVG9vIGJpZyBTSUQgZm9yIGRlY29kaW5nLCBoZXggb25seVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGlucHV0T2Zmc2V0ICsgdGhpcy5ibG9ja0xlbmd0aCk7XG4gICAgfVxuICAgIHRvQkVSKHNpemVPbmx5KSB7XG4gICAgICAgIGlmICh0aGlzLmlzSGV4T25seSkge1xuICAgICAgICAgICAgaWYgKHNpemVPbmx5KVxuICAgICAgICAgICAgICAgIHJldHVybiAobmV3IEFycmF5QnVmZmVyKHRoaXMudmFsdWVIZXhWaWV3LmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgICAgIGNvbnN0IGN1clZpZXcgPSB0aGlzLnZhbHVlSGV4VmlldztcbiAgICAgICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrTGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHRoaXMuYmxvY2tMZW5ndGggLSAxKTsgaSsrKVxuICAgICAgICAgICAgICAgIHJldFZpZXdbaV0gPSBjdXJWaWV3W2ldIHwgMHg4MDtcbiAgICAgICAgICAgIHJldFZpZXdbdGhpcy5ibG9ja0xlbmd0aCAtIDFdID0gY3VyVmlld1t0aGlzLmJsb2NrTGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gcmV0Vmlldy5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RlZEJ1ZiA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsVG9CYXNlKHRoaXMudmFsdWVEZWMsIDcpO1xuICAgICAgICBpZiAoZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gXCJFcnJvciBkdXJpbmcgZW5jb2RpbmcgU0lEIHZhbHVlXCI7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkQnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICBpZiAoIXNpemVPbmx5KSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkVmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWRCdWYpO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgcmV0Vmlld1tpXSA9IGVuY29kZWRWaWV3W2ldIHwgMHg4MDtcbiAgICAgICAgICAgIHJldFZpZXdbbGVuXSA9IGVuY29kZWRWaWV3W2xlbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldFZpZXcuYnVmZmVyO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmlzSGV4T25seSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuVG9IZXgodGhpcy52YWx1ZUhleFZpZXcpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudmFsdWVEZWMudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIHZhbHVlRGVjOiB0aGlzLnZhbHVlRGVjLFxuICAgICAgICB9O1xuICAgIH1cbn1cbkxvY2FsUmVsYXRpdmVTaWRWYWx1ZUJsb2NrLk5BTUUgPSBcInJlbGF0aXZlU2lkQmxvY2tcIjtcblxuY2xhc3MgTG9jYWxSZWxhdGl2ZU9iamVjdElkZW50aWZpZXJWYWx1ZUJsb2NrIGV4dGVuZHMgVmFsdWVCbG9jayB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSA9IEVNUFRZX1NUUklORywgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xuICAgICAgICBsZXQgcmVzdWx0T2Zmc2V0ID0gaW5wdXRPZmZzZXQ7XG4gICAgICAgIHdoaWxlIChpbnB1dExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZEJsb2NrID0gbmV3IExvY2FsUmVsYXRpdmVTaWRWYWx1ZUJsb2NrKCk7XG4gICAgICAgICAgICByZXN1bHRPZmZzZXQgPSBzaWRCbG9jay5mcm9tQkVSKGlucHV0QnVmZmVyLCByZXN1bHRPZmZzZXQsIGlucHV0TGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHNpZEJsb2NrLmVycm9yO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoICs9IHNpZEJsb2NrLmJsb2NrTGVuZ3RoO1xuICAgICAgICAgICAgaW5wdXRMZW5ndGggLT0gc2lkQmxvY2suYmxvY2tMZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLnB1c2goc2lkQmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XG4gICAgfVxuICAgIHRvQkVSKHNpemVPbmx5LCBfd3JpdGVyKSB7XG4gICAgICAgIGNvbnN0IHJldEJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUJ1ZiA9IHRoaXMudmFsdWVbaV0udG9CRVIoc2l6ZU9ubHkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlQnVmLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gdGhpcy52YWx1ZVtpXS5lcnJvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0QnVmZmVycy5wdXNoKHZhbHVlQnVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KHJldEJ1ZmZlcnMpO1xuICAgIH1cbiAgICBmcm9tU3RyaW5nKHN0cmluZykge1xuICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIGxldCBwb3MxID0gMDtcbiAgICAgICAgbGV0IHBvczIgPSAwO1xuICAgICAgICBsZXQgc2lkID0gXCJcIjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcG9zMiA9IHN0cmluZy5pbmRleE9mKFwiLlwiLCBwb3MxKTtcbiAgICAgICAgICAgIGlmIChwb3MyID09PSAtMSlcbiAgICAgICAgICAgICAgICBzaWQgPSBzdHJpbmcuc3Vic3RyaW5nKHBvczEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNpZCA9IHN0cmluZy5zdWJzdHJpbmcocG9zMSwgcG9zMik7XG4gICAgICAgICAgICBwb3MxID0gcG9zMiArIDE7XG4gICAgICAgICAgICBjb25zdCBzaWRCbG9jayA9IG5ldyBMb2NhbFJlbGF0aXZlU2lkVmFsdWVCbG9jaygpO1xuICAgICAgICAgICAgc2lkQmxvY2sudmFsdWVEZWMgPSBwYXJzZUludChzaWQsIDEwKTtcbiAgICAgICAgICAgIGlmIChpc05hTihzaWRCbG9jay52YWx1ZURlYykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLnB1c2goc2lkQmxvY2spO1xuICAgICAgICB9IHdoaWxlIChwb3MyICE9PSAtMSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGxldCBpc0hleE9ubHkgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpc0hleE9ubHkgPSB0aGlzLnZhbHVlW2ldLmlzSGV4T25seTtcbiAgICAgICAgICAgIGxldCBzaWRTdHIgPSB0aGlzLnZhbHVlW2ldLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoaSAhPT0gMClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBgJHtyZXN1bHR9LmA7XG4gICAgICAgICAgICBpZiAoaXNIZXhPbmx5KSB7XG4gICAgICAgICAgICAgICAgc2lkU3RyID0gYHske3NpZFN0cn19YDtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2lkU3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzaWRTdHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBvYmplY3QgPSB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBzaWRBcnJheTogW10sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG9iamVjdC5zaWRBcnJheS5wdXNoKHRoaXMudmFsdWVbaV0udG9KU09OKCkpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbn1cbkxvY2FsUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyVmFsdWVCbG9jay5OQU1FID0gXCJSZWxhdGl2ZU9iamVjdElkZW50aWZpZXJWYWx1ZUJsb2NrXCI7XG5cbnZhciBfYSRsO1xuY2xhc3MgUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyIGV4dGVuZHMgQmFzZUJsb2NrIHtcbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVCbG9jay50b1N0cmluZygpO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlQmxvY2suZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzLCBMb2NhbFJlbGF0aXZlT2JqZWN0SWRlbnRpZmllclZhbHVlQmxvY2spO1xuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMTM7XG4gICAgfVxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IuTkFNRX0gOiAke3RoaXMudmFsdWVCbG9jay50b1N0cmluZygpIHx8IFwiZW1wdHlcIn1gO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmdldFZhbHVlKCksXG4gICAgICAgIH07XG4gICAgfVxufVxuX2EkbCA9IFJlbGF0aXZlT2JqZWN0SWRlbnRpZmllcjtcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLlJlbGF0aXZlT2JqZWN0SWRlbnRpZmllciA9IF9hJGw7XG59KSgpO1xuUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyLk5BTUUgPSBcIlJlbGF0aXZlT2JqZWN0SWRlbnRpZmllclwiO1xuXG52YXIgX2EkaztcbmNsYXNzIFNlcXVlbmNlIGV4dGVuZHMgQ29uc3RydWN0ZWQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDE2O1xuICAgIH1cbn1cbl9hJGsgPSBTZXF1ZW5jZTtcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLlNlcXVlbmNlID0gX2Ekaztcbn0pKCk7XG5TZXF1ZW5jZS5OQU1FID0gXCJTRVFVRU5DRVwiO1xuXG52YXIgX2EkajtcbmNsYXNzIFNldCBleHRlbmRzIENvbnN0cnVjdGVkIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAxNztcbiAgICB9XG59XG5fYSRqID0gU2V0O1xuKCgpID0+IHtcbiAgICB0eXBlU3RvcmUuU2V0ID0gX2Ekajtcbn0pKCk7XG5TZXQuTkFNRSA9IFwiU0VUXCI7XG5cbmNsYXNzIExvY2FsU3RyaW5nVmFsdWVCbG9jayBleHRlbmRzIEhleEJsb2NrKFZhbHVlQmxvY2spIHtcbiAgICBjb25zdHJ1Y3Rvcih7IC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLmlzSGV4T25seSA9IHRydWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSBFTVBUWV9TVFJJTkc7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxufVxuTG9jYWxTdHJpbmdWYWx1ZUJsb2NrLk5BTUUgPSBcIlN0cmluZ1ZhbHVlQmxvY2tcIjtcblxuY2xhc3MgTG9jYWxTaW1wbGVTdHJpbmdWYWx1ZUJsb2NrIGV4dGVuZHMgTG9jYWxTdHJpbmdWYWx1ZUJsb2NrIHtcbn1cbkxvY2FsU2ltcGxlU3RyaW5nVmFsdWVCbG9jay5OQU1FID0gXCJTaW1wbGVTdHJpbmdWYWx1ZUJsb2NrXCI7XG5cbmNsYXNzIExvY2FsU2ltcGxlU3RyaW5nQmxvY2sgZXh0ZW5kcyBCYXNlU3RyaW5nQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKHsgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycywgTG9jYWxTaW1wbGVTdHJpbmdWYWx1ZUJsb2NrKTtcbiAgICB9XG4gICAgZnJvbUJ1ZmZlcihpbnB1dEJ1ZmZlcikge1xuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpKTtcbiAgICB9XG4gICAgZnJvbVN0cmluZyhpbnB1dFN0cmluZykge1xuICAgICAgICBjb25zdCBzdHJMZW4gPSBpbnB1dFN0cmluZy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoc3RyTGVuKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJMZW47IGkrKylcbiAgICAgICAgICAgIHZpZXdbaV0gPSBpbnB1dFN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWUgPSBpbnB1dFN0cmluZztcbiAgICB9XG59XG5Mb2NhbFNpbXBsZVN0cmluZ0Jsb2NrLk5BTUUgPSBcIlNJTVBMRSBTVFJJTkdcIjtcblxuY2xhc3MgTG9jYWxVdGY4U3RyaW5nVmFsdWVCbG9jayBleHRlbmRzIExvY2FsU2ltcGxlU3RyaW5nQmxvY2sge1xuICAgIGZyb21CdWZmZXIoaW5wdXRCdWZmZXIpIHtcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub1V0ZjhTdHJpbmcoaW5wdXRCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKGBFcnJvciBkdXJpbmcgXCJkZWNvZGVVUklDb21wb25lbnRcIjogJHtleH0sIHVzaW5nIHJhdyBzdHJpbmdgKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZSA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuVG9CaW5hcnkoaW5wdXRCdWZmZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21TdHJpbmcoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHB2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuRnJvbVV0ZjhTdHJpbmcoaW5wdXRTdHJpbmcpKTtcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gaW5wdXRTdHJpbmc7XG4gICAgfVxufVxuTG9jYWxVdGY4U3RyaW5nVmFsdWVCbG9jay5OQU1FID0gXCJVdGY4U3RyaW5nVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkaTtcbmNsYXNzIFV0ZjhTdHJpbmcgZXh0ZW5kcyBMb2NhbFV0ZjhTdHJpbmdWYWx1ZUJsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAxMjtcbiAgICB9XG59XG5fYSRpID0gVXRmOFN0cmluZztcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLlV0ZjhTdHJpbmcgPSBfYSRpO1xufSkoKTtcblV0ZjhTdHJpbmcuTkFNRSA9IFwiVVRGOFN0cmluZ1wiO1xuXG5jbGFzcyBMb2NhbEJtcFN0cmluZ1ZhbHVlQmxvY2sgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcbiAgICBmcm9tQnVmZmVyKGlucHV0QnVmZmVyKSB7XG4gICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZSA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuVG9VdGYxNlN0cmluZyhpbnB1dEJ1ZmZlcik7XG4gICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXcgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGlucHV0QnVmZmVyKTtcbiAgICB9XG4gICAgZnJvbVN0cmluZyhpbnB1dFN0cmluZykge1xuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWUgPSBpbnB1dFN0cmluZztcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHB2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuRnJvbVV0ZjE2U3RyaW5nKGlucHV0U3RyaW5nKSk7XG4gICAgfVxufVxuTG9jYWxCbXBTdHJpbmdWYWx1ZUJsb2NrLk5BTUUgPSBcIkJtcFN0cmluZ1ZhbHVlQmxvY2tcIjtcblxudmFyIF9hJGg7XG5jbGFzcyBCbXBTdHJpbmcgZXh0ZW5kcyBMb2NhbEJtcFN0cmluZ1ZhbHVlQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKHsgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAzMDtcbiAgICB9XG59XG5fYSRoID0gQm1wU3RyaW5nO1xuKCgpID0+IHtcbiAgICB0eXBlU3RvcmUuQm1wU3RyaW5nID0gX2EkaDtcbn0pKCk7XG5CbXBTdHJpbmcuTkFNRSA9IFwiQk1QU3RyaW5nXCI7XG5cbmNsYXNzIExvY2FsVW5pdmVyc2FsU3RyaW5nVmFsdWVCbG9jayBleHRlbmRzIExvY2FsU2ltcGxlU3RyaW5nQmxvY2sge1xuICAgIGZyb21CdWZmZXIoaW5wdXRCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgY29weUJ1ZmZlciA9IEFycmF5QnVmZmVyLmlzVmlldyhpbnB1dEJ1ZmZlcikgPyBpbnB1dEJ1ZmZlci5zbGljZSgpLmJ1ZmZlciA6IGlucHV0QnVmZmVyLnNsaWNlKDApO1xuICAgICAgICBjb25zdCB2YWx1ZVZpZXcgPSBuZXcgVWludDhBcnJheShjb3B5QnVmZmVyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZVZpZXcubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICAgIHZhbHVlVmlld1tpXSA9IHZhbHVlVmlld1tpICsgM107XG4gICAgICAgICAgICB2YWx1ZVZpZXdbaSArIDFdID0gdmFsdWVWaWV3W2kgKyAyXTtcbiAgICAgICAgICAgIHZhbHVlVmlld1tpICsgMl0gPSAweDAwO1xuICAgICAgICAgICAgdmFsdWVWaWV3W2kgKyAzXSA9IDB4MDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDMyQXJyYXkoY29weUJ1ZmZlcikpO1xuICAgIH1cbiAgICBmcm9tU3RyaW5nKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHN0ckxlbmd0aCA9IGlucHV0U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdmFsdWVIZXhWaWV3ID0gdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHN0ckxlbmd0aCAqIDQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlQnVmID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxUb0Jhc2UoaW5wdXRTdHJpbmcuY2hhckNvZGVBdChpKSwgOCk7XG4gICAgICAgICAgICBjb25zdCBjb2RlVmlldyA9IG5ldyBVaW50OEFycmF5KGNvZGVCdWYpO1xuICAgICAgICAgICAgaWYgKGNvZGVWaWV3Lmxlbmd0aCA+IDQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBkaWYgPSA0IC0gY29kZVZpZXcubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IChjb2RlVmlldy5sZW5ndGggLSAxKTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgICAgICAgdmFsdWVIZXhWaWV3W2kgKiA0ICsgaiArIGRpZl0gPSBjb2RlVmlld1tqXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWUgPSBpbnB1dFN0cmluZztcbiAgICB9XG59XG5Mb2NhbFVuaXZlcnNhbFN0cmluZ1ZhbHVlQmxvY2suTkFNRSA9IFwiVW5pdmVyc2FsU3RyaW5nVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkZztcbmNsYXNzIFVuaXZlcnNhbFN0cmluZyBleHRlbmRzIExvY2FsVW5pdmVyc2FsU3RyaW5nVmFsdWVCbG9jayB7XG4gICAgY29uc3RydWN0b3IoeyAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDI4O1xuICAgIH1cbn1cbl9hJGcgPSBVbml2ZXJzYWxTdHJpbmc7XG4oKCkgPT4ge1xuICAgIHR5cGVTdG9yZS5Vbml2ZXJzYWxTdHJpbmcgPSBfYSRnO1xufSkoKTtcblVuaXZlcnNhbFN0cmluZy5OQU1FID0gXCJVbml2ZXJzYWxTdHJpbmdcIjtcblxudmFyIF9hJGY7XG5jbGFzcyBOdW1lcmljU3RyaW5nIGV4dGVuZHMgTG9jYWxTaW1wbGVTdHJpbmdCbG9jayB7XG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMTg7XG4gICAgfVxufVxuX2EkZiA9IE51bWVyaWNTdHJpbmc7XG4oKCkgPT4ge1xuICAgIHR5cGVTdG9yZS5OdW1lcmljU3RyaW5nID0gX2EkZjtcbn0pKCk7XG5OdW1lcmljU3RyaW5nLk5BTUUgPSBcIk51bWVyaWNTdHJpbmdcIjtcblxudmFyIF9hJGU7XG5jbGFzcyBQcmludGFibGVTdHJpbmcgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAxOTtcbiAgICB9XG59XG5fYSRlID0gUHJpbnRhYmxlU3RyaW5nO1xuKCgpID0+IHtcbiAgICB0eXBlU3RvcmUuUHJpbnRhYmxlU3RyaW5nID0gX2EkZTtcbn0pKCk7XG5QcmludGFibGVTdHJpbmcuTkFNRSA9IFwiUHJpbnRhYmxlU3RyaW5nXCI7XG5cbnZhciBfYSRkO1xuY2xhc3MgVGVsZXRleFN0cmluZyBleHRlbmRzIExvY2FsU2ltcGxlU3RyaW5nQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDIwO1xuICAgIH1cbn1cbl9hJGQgPSBUZWxldGV4U3RyaW5nO1xuKCgpID0+IHtcbiAgICB0eXBlU3RvcmUuVGVsZXRleFN0cmluZyA9IF9hJGQ7XG59KSgpO1xuVGVsZXRleFN0cmluZy5OQU1FID0gXCJUZWxldGV4U3RyaW5nXCI7XG5cbnZhciBfYSRjO1xuY2xhc3MgVmlkZW90ZXhTdHJpbmcgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAyMTtcbiAgICB9XG59XG5fYSRjID0gVmlkZW90ZXhTdHJpbmc7XG4oKCkgPT4ge1xuICAgIHR5cGVTdG9yZS5WaWRlb3RleFN0cmluZyA9IF9hJGM7XG59KSgpO1xuVmlkZW90ZXhTdHJpbmcuTkFNRSA9IFwiVmlkZW90ZXhTdHJpbmdcIjtcblxudmFyIF9hJGI7XG5jbGFzcyBJQTVTdHJpbmcgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAyMjtcbiAgICB9XG59XG5fYSRiID0gSUE1U3RyaW5nO1xuKCgpID0+IHtcbiAgICB0eXBlU3RvcmUuSUE1U3RyaW5nID0gX2EkYjtcbn0pKCk7XG5JQTVTdHJpbmcuTkFNRSA9IFwiSUE1U3RyaW5nXCI7XG5cbnZhciBfYSRhO1xuY2xhc3MgR3JhcGhpY1N0cmluZyBleHRlbmRzIExvY2FsU2ltcGxlU3RyaW5nQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDI1O1xuICAgIH1cbn1cbl9hJGEgPSBHcmFwaGljU3RyaW5nO1xuKCgpID0+IHtcbiAgICB0eXBlU3RvcmUuR3JhcGhpY1N0cmluZyA9IF9hJGE7XG59KSgpO1xuR3JhcGhpY1N0cmluZy5OQU1FID0gXCJHcmFwaGljU3RyaW5nXCI7XG5cbnZhciBfYSQ5O1xuY2xhc3MgVmlzaWJsZVN0cmluZyBleHRlbmRzIExvY2FsU2ltcGxlU3RyaW5nQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDI2O1xuICAgIH1cbn1cbl9hJDkgPSBWaXNpYmxlU3RyaW5nO1xuKCgpID0+IHtcbiAgICB0eXBlU3RvcmUuVmlzaWJsZVN0cmluZyA9IF9hJDk7XG59KSgpO1xuVmlzaWJsZVN0cmluZy5OQU1FID0gXCJWaXNpYmxlU3RyaW5nXCI7XG5cbnZhciBfYSQ4O1xuY2xhc3MgR2VuZXJhbFN0cmluZyBleHRlbmRzIExvY2FsU2ltcGxlU3RyaW5nQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDI3O1xuICAgIH1cbn1cbl9hJDggPSBHZW5lcmFsU3RyaW5nO1xuKCgpID0+IHtcbiAgICB0eXBlU3RvcmUuR2VuZXJhbFN0cmluZyA9IF9hJDg7XG59KSgpO1xuR2VuZXJhbFN0cmluZy5OQU1FID0gXCJHZW5lcmFsU3RyaW5nXCI7XG5cbnZhciBfYSQ3O1xuY2xhc3MgQ2hhcmFjdGVyU3RyaW5nIGV4dGVuZHMgTG9jYWxTaW1wbGVTdHJpbmdCbG9jayB7XG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMjk7XG4gICAgfVxufVxuX2EkNyA9IENoYXJhY3RlclN0cmluZztcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLkNoYXJhY3RlclN0cmluZyA9IF9hJDc7XG59KSgpO1xuQ2hhcmFjdGVyU3RyaW5nLk5BTUUgPSBcIkNoYXJhY3RlclN0cmluZ1wiO1xuXG52YXIgX2EkNjtcbmNsYXNzIFVUQ1RpbWUgZXh0ZW5kcyBWaXNpYmxlU3RyaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCB2YWx1ZURhdGUsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLnllYXIgPSAwO1xuICAgICAgICB0aGlzLm1vbnRoID0gMDtcbiAgICAgICAgdGhpcy5kYXkgPSAwO1xuICAgICAgICB0aGlzLmhvdXIgPSAwO1xuICAgICAgICB0aGlzLm1pbnV0ZSA9IDA7XG4gICAgICAgIHRoaXMuc2Vjb25kID0gMDtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXdbaV0gPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZURhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbURhdGUodmFsdWVEYXRlKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLnRvQnVmZmVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAyMztcbiAgICB9XG4gICAgZnJvbUJ1ZmZlcihpbnB1dEJ1ZmZlcikge1xuICAgICAgICB0aGlzLmZyb21TdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGlucHV0QnVmZmVyKSkpO1xuICAgIH1cbiAgICB0b0J1ZmZlcigpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc3RyLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHZpZXdbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgZnJvbURhdGUoaW5wdXREYXRlKSB7XG4gICAgICAgIHRoaXMueWVhciA9IGlucHV0RGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICB0aGlzLm1vbnRoID0gaW5wdXREYXRlLmdldFVUQ01vbnRoKCkgKyAxO1xuICAgICAgICB0aGlzLmRheSA9IGlucHV0RGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIHRoaXMuaG91ciA9IGlucHV0RGF0ZS5nZXRVVENIb3VycygpO1xuICAgICAgICB0aGlzLm1pbnV0ZSA9IGlucHV0RGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgIHRoaXMuc2Vjb25kID0gaW5wdXREYXRlLmdldFVUQ1NlY29uZHMoKTtcbiAgICB9XG4gICAgdG9EYXRlKCkge1xuICAgICAgICByZXR1cm4gKG5ldyBEYXRlKERhdGUuVVRDKHRoaXMueWVhciwgdGhpcy5tb250aCAtIDEsIHRoaXMuZGF5LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCkpKTtcbiAgICB9XG4gICAgZnJvbVN0cmluZyhpbnB1dFN0cmluZykge1xuICAgICAgICBjb25zdCBwYXJzZXIgPSAvKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pWi9pZztcbiAgICAgICAgY29uc3QgcGFyc2VyQXJyYXkgPSBwYXJzZXIuZXhlYyhpbnB1dFN0cmluZyk7XG4gICAgICAgIGlmIChwYXJzZXJBcnJheSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeWVhciA9IHBhcnNlSW50KHBhcnNlckFycmF5WzFdLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyID49IDUwKVxuICAgICAgICAgICAgdGhpcy55ZWFyID0gMTkwMCArIHllYXI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMueWVhciA9IDIwMDAgKyB5ZWFyO1xuICAgICAgICB0aGlzLm1vbnRoID0gcGFyc2VJbnQocGFyc2VyQXJyYXlbMl0sIDEwKTtcbiAgICAgICAgdGhpcy5kYXkgPSBwYXJzZUludChwYXJzZXJBcnJheVszXSwgMTApO1xuICAgICAgICB0aGlzLmhvdXIgPSBwYXJzZUludChwYXJzZXJBcnJheVs0XSwgMTApO1xuICAgICAgICB0aGlzLm1pbnV0ZSA9IHBhcnNlSW50KHBhcnNlckFycmF5WzVdLCAxMCk7XG4gICAgICAgIHRoaXMuc2Vjb25kID0gcGFyc2VJbnQocGFyc2VyQXJyYXlbNl0sIDEwKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoZW5jb2RpbmcgPSBcImlzb1wiKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJpc29cIikge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0QXJyYXkgPSBuZXcgQXJyYXkoNyk7XG4gICAgICAgICAgICBvdXRwdXRBcnJheVswXSA9IHB2dXRpbHNfX25hbWVzcGFjZS5wYWROdW1iZXIoKCh0aGlzLnllYXIgPCAyMDAwKSA/ICh0aGlzLnllYXIgLSAxOTAwKSA6ICh0aGlzLnllYXIgLSAyMDAwKSksIDIpO1xuICAgICAgICAgICAgb3V0cHV0QXJyYXlbMV0gPSBwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMubW9udGgsIDIpO1xuICAgICAgICAgICAgb3V0cHV0QXJyYXlbMl0gPSBwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMuZGF5LCAyKTtcbiAgICAgICAgICAgIG91dHB1dEFycmF5WzNdID0gcHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLmhvdXIsIDIpO1xuICAgICAgICAgICAgb3V0cHV0QXJyYXlbNF0gPSBwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMubWludXRlLCAyKTtcbiAgICAgICAgICAgIG91dHB1dEFycmF5WzVdID0gcHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLnNlY29uZCwgMik7XG4gICAgICAgICAgICBvdXRwdXRBcnJheVs2XSA9IFwiWlwiO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEFycmF5LmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICB9XG4gICAgb25Bc2NpaUVuY29kaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfSA6ICR7dGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpfWA7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgeWVhcjogdGhpcy55ZWFyLFxuICAgICAgICAgICAgbW9udGg6IHRoaXMubW9udGgsXG4gICAgICAgICAgICBkYXk6IHRoaXMuZGF5LFxuICAgICAgICAgICAgaG91cjogdGhpcy5ob3VyLFxuICAgICAgICAgICAgbWludXRlOiB0aGlzLm1pbnV0ZSxcbiAgICAgICAgICAgIHNlY29uZDogdGhpcy5zZWNvbmQsXG4gICAgICAgIH07XG4gICAgfVxufVxuX2EkNiA9IFVUQ1RpbWU7XG4oKCkgPT4ge1xuICAgIHR5cGVTdG9yZS5VVENUaW1lID0gX2EkNjtcbn0pKCk7XG5VVENUaW1lLk5BTUUgPSBcIlVUQ1RpbWVcIjtcblxudmFyIF9hJDU7XG5jbGFzcyBHZW5lcmFsaXplZFRpbWUgZXh0ZW5kcyBVVENUaW1lIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgKF9iID0gdGhpcy5taWxsaXNlY29uZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKHRoaXMubWlsbGlzZWNvbmQgPSAwKTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDI0O1xuICAgIH1cbiAgICBmcm9tRGF0ZShpbnB1dERhdGUpIHtcbiAgICAgICAgc3VwZXIuZnJvbURhdGUoaW5wdXREYXRlKTtcbiAgICAgICAgdGhpcy5taWxsaXNlY29uZCA9IGlucHV0RGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICB9XG4gICAgdG9EYXRlKCkge1xuICAgICAgICBjb25zdCB1dGNEYXRlID0gRGF0ZS5VVEModGhpcy55ZWFyLCB0aGlzLm1vbnRoIC0gMSwgdGhpcy5kYXksIHRoaXMuaG91ciwgdGhpcy5taW51dGUsIHRoaXMuc2Vjb25kLCB0aGlzLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgcmV0dXJuIChuZXcgRGF0ZSh1dGNEYXRlKSk7XG4gICAgfVxuICAgIGZyb21TdHJpbmcoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgbGV0IGlzVVRDID0gZmFsc2U7XG4gICAgICAgIGxldCB0aW1lU3RyaW5nID0gXCJcIjtcbiAgICAgICAgbGV0IGRhdGVUaW1lU3RyaW5nID0gXCJcIjtcbiAgICAgICAgbGV0IGZyYWN0aW9uUGFydCA9IDA7XG4gICAgICAgIGxldCBwYXJzZXI7XG4gICAgICAgIGxldCBob3VyRGlmZmVyZW5jZSA9IDA7XG4gICAgICAgIGxldCBtaW51dGVEaWZmZXJlbmNlID0gMDtcbiAgICAgICAgaWYgKGlucHV0U3RyaW5nW2lucHV0U3RyaW5nLmxlbmd0aCAtIDFdID09PSBcIlpcIikge1xuICAgICAgICAgICAgdGltZVN0cmluZyA9IGlucHV0U3RyaW5nLnN1YnN0cmluZygwLCBpbnB1dFN0cmluZy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlzVVRDID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IG5ldyBOdW1iZXIoaW5wdXRTdHJpbmdbaW5wdXRTdHJpbmcubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG51bWJlci52YWx1ZU9mKCkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGlucHV0IHN0cmluZyBmb3IgY29udmVyc2lvblwiKTtcbiAgICAgICAgICAgIHRpbWVTdHJpbmcgPSBpbnB1dFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVVEMpIHtcbiAgICAgICAgICAgIGlmICh0aW1lU3RyaW5nLmluZGV4T2YoXCIrXCIpICE9PSAtMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBpbnB1dCBzdHJpbmcgZm9yIGNvbnZlcnNpb25cIik7XG4gICAgICAgICAgICBpZiAodGltZVN0cmluZy5pbmRleE9mKFwiLVwiKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG11bHRpcGxpZXIgPSAxO1xuICAgICAgICAgICAgbGV0IGRpZmZlcmVuY2VQb3NpdGlvbiA9IHRpbWVTdHJpbmcuaW5kZXhPZihcIitcIik7XG4gICAgICAgICAgICBsZXQgZGlmZmVyZW5jZVN0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZVBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGRpZmZlcmVuY2VQb3NpdGlvbiA9IHRpbWVTdHJpbmcuaW5kZXhPZihcIi1cIik7XG4gICAgICAgICAgICAgICAgbXVsdGlwbGllciA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2VQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlU3RyaW5nID0gdGltZVN0cmluZy5zdWJzdHJpbmcoZGlmZmVyZW5jZVBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgICAgICAgdGltZVN0cmluZyA9IHRpbWVTdHJpbmcuc3Vic3RyaW5nKDAsIGRpZmZlcmVuY2VQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKChkaWZmZXJlbmNlU3RyaW5nLmxlbmd0aCAhPT0gMikgJiYgKGRpZmZlcmVuY2VTdHJpbmcubGVuZ3RoICE9PSA0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xuICAgICAgICAgICAgICAgIGxldCBudW1iZXIgPSBwYXJzZUludChkaWZmZXJlbmNlU3RyaW5nLnN1YnN0cmluZygwLCAyKSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihudW1iZXIudmFsdWVPZigpKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xuICAgICAgICAgICAgICAgIGhvdXJEaWZmZXJlbmNlID0gbXVsdGlwbGllciAqIG51bWJlcjtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZmVyZW5jZVN0cmluZy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyID0gcGFyc2VJbnQoZGlmZmVyZW5jZVN0cmluZy5zdWJzdHJpbmcoMiwgNCksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bWJlci52YWx1ZU9mKCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICBtaW51dGVEaWZmZXJlbmNlID0gbXVsdGlwbGllciAqIG51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZyYWN0aW9uUG9pbnRQb3NpdGlvbiA9IHRpbWVTdHJpbmcuaW5kZXhPZihcIi5cIik7XG4gICAgICAgIGlmIChmcmFjdGlvblBvaW50UG9zaXRpb24gPT09IC0xKVxuICAgICAgICAgICAgZnJhY3Rpb25Qb2ludFBvc2l0aW9uID0gdGltZVN0cmluZy5pbmRleE9mKFwiLFwiKTtcbiAgICAgICAgaWYgKGZyYWN0aW9uUG9pbnRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWN0aW9uUGFydENoZWNrID0gbmV3IE51bWJlcihgMCR7dGltZVN0cmluZy5zdWJzdHJpbmcoZnJhY3Rpb25Qb2ludFBvc2l0aW9uKX1gKTtcbiAgICAgICAgICAgIGlmIChpc05hTihmcmFjdGlvblBhcnRDaGVjay52YWx1ZU9mKCkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGlucHV0IHN0cmluZyBmb3IgY29udmVyc2lvblwiKTtcbiAgICAgICAgICAgIGZyYWN0aW9uUGFydCA9IGZyYWN0aW9uUGFydENoZWNrLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGRhdGVUaW1lU3RyaW5nID0gdGltZVN0cmluZy5zdWJzdHJpbmcoMCwgZnJhY3Rpb25Qb2ludFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkYXRlVGltZVN0cmluZyA9IHRpbWVTdHJpbmc7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgY2FzZSAoZGF0ZVRpbWVTdHJpbmcubGVuZ3RoID09PSA4KTpcbiAgICAgICAgICAgICAgICBwYXJzZXIgPSAvKFxcZHs0fSkoXFxkezJ9KShcXGR7Mn0pL2lnO1xuICAgICAgICAgICAgICAgIGlmIChmcmFjdGlvblBvaW50UG9zaXRpb24gIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBpbnB1dCBzdHJpbmcgZm9yIGNvbnZlcnNpb25cIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIChkYXRlVGltZVN0cmluZy5sZW5ndGggPT09IDEwKTpcbiAgICAgICAgICAgICAgICBwYXJzZXIgPSAvKFxcZHs0fSkoXFxkezJ9KShcXGR7Mn0pKFxcZHsyfSkvaWc7XG4gICAgICAgICAgICAgICAgaWYgKGZyYWN0aW9uUG9pbnRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWN0aW9uUmVzdWx0ID0gNjAgKiBmcmFjdGlvblBhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWludXRlID0gTWF0aC5mbG9vcihmcmFjdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uUmVzdWx0ID0gNjAgKiAoZnJhY3Rpb25SZXN1bHQgLSB0aGlzLm1pbnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kID0gTWF0aC5mbG9vcihmcmFjdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uUmVzdWx0ID0gMTAwMCAqIChmcmFjdGlvblJlc3VsdCAtIHRoaXMuc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZCA9IE1hdGguZmxvb3IoZnJhY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKGRhdGVUaW1lU3RyaW5nLmxlbmd0aCA9PT0gMTIpOlxuICAgICAgICAgICAgICAgIHBhcnNlciA9IC8oXFxkezR9KShcXGR7Mn0pKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pL2lnO1xuICAgICAgICAgICAgICAgIGlmIChmcmFjdGlvblBvaW50UG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmcmFjdGlvblJlc3VsdCA9IDYwICogZnJhY3Rpb25QYXJ0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlY29uZCA9IE1hdGguZmxvb3IoZnJhY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBmcmFjdGlvblJlc3VsdCA9IDEwMDAgKiAoZnJhY3Rpb25SZXN1bHQgLSB0aGlzLnNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmQgPSBNYXRoLmZsb29yKGZyYWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIChkYXRlVGltZVN0cmluZy5sZW5ndGggPT09IDE0KTpcbiAgICAgICAgICAgICAgICBwYXJzZXIgPSAvKFxcZHs0fSkoXFxkezJ9KShcXGR7Mn0pKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pL2lnO1xuICAgICAgICAgICAgICAgIGlmIChmcmFjdGlvblBvaW50UG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYWN0aW9uUmVzdWx0ID0gMTAwMCAqIGZyYWN0aW9uUGFydDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZCA9IE1hdGguZmxvb3IoZnJhY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlckFycmF5ID0gcGFyc2VyLmV4ZWMoZGF0ZVRpbWVTdHJpbmcpO1xuICAgICAgICBpZiAocGFyc2VyQXJyYXkgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBpbnB1dCBzdHJpbmcgZm9yIGNvbnZlcnNpb25cIik7XG4gICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgcGFyc2VyQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyID0gcGFyc2VJbnQocGFyc2VyQXJyYXlbal0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoID0gcGFyc2VJbnQocGFyc2VyQXJyYXlbal0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRheSA9IHBhcnNlSW50KHBhcnNlckFycmF5W2pdLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3VyID0gcGFyc2VJbnQocGFyc2VyQXJyYXlbal0sIDEwKSArIGhvdXJEaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWludXRlID0gcGFyc2VJbnQocGFyc2VyQXJyYXlbal0sIDEwKSArIG1pbnV0ZURpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWNvbmQgPSBwYXJzZUludChwYXJzZXJBcnJheVtqXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBpbnB1dCBzdHJpbmcgZm9yIGNvbnZlcnNpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVVRDID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgdGVtcERhdGUgPSBuZXcgRGF0ZSh0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5taWxsaXNlY29uZCk7XG4gICAgICAgICAgICB0aGlzLnllYXIgPSB0ZW1wRGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgdGhpcy5tb250aCA9IHRlbXBEYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICB0aGlzLmRheSA9IHRlbXBEYXRlLmdldFVUQ0RheSgpO1xuICAgICAgICAgICAgdGhpcy5ob3VyID0gdGVtcERhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgIHRoaXMubWludXRlID0gdGVtcERhdGUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgdGhpcy5zZWNvbmQgPSB0ZW1wRGF0ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kID0gdGVtcERhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoZW5jb2RpbmcgPSBcImlzb1wiKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJpc29cIikge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0QXJyYXkgPSBbXTtcbiAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gocHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLnllYXIsIDQpKTtcbiAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gocHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLm1vbnRoLCAyKSk7XG4gICAgICAgICAgICBvdXRwdXRBcnJheS5wdXNoKHB2dXRpbHNfX25hbWVzcGFjZS5wYWROdW1iZXIodGhpcy5kYXksIDIpKTtcbiAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gocHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLmhvdXIsIDIpKTtcbiAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gocHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLm1pbnV0ZSwgMikpO1xuICAgICAgICAgICAgb3V0cHV0QXJyYXkucHVzaChwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMuc2Vjb25kLCAyKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWxsaXNlY29uZCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2goXCIuXCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gocHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLm1pbGxpc2Vjb25kLCAzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRBcnJheS5wdXNoKFwiWlwiKTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRBcnJheS5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmQ6IHRoaXMubWlsbGlzZWNvbmQsXG4gICAgICAgIH07XG4gICAgfVxufVxuX2EkNSA9IEdlbmVyYWxpemVkVGltZTtcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLkdlbmVyYWxpemVkVGltZSA9IF9hJDU7XG59KSgpO1xuR2VuZXJhbGl6ZWRUaW1lLk5BTUUgPSBcIkdlbmVyYWxpemVkVGltZVwiO1xuXG52YXIgX2EkNDtcbmNsYXNzIERBVEUgZXh0ZW5kcyBVdGY4U3RyaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAzMTtcbiAgICB9XG59XG5fYSQ0ID0gREFURTtcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLkRBVEUgPSBfYSQ0O1xufSkoKTtcbkRBVEUuTkFNRSA9IFwiREFURVwiO1xuXG52YXIgX2EkMztcbmNsYXNzIFRpbWVPZkRheSBleHRlbmRzIFV0ZjhTdHJpbmcge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDMyO1xuICAgIH1cbn1cbl9hJDMgPSBUaW1lT2ZEYXk7XG4oKCkgPT4ge1xuICAgIHR5cGVTdG9yZS5UaW1lT2ZEYXkgPSBfYSQzO1xufSkoKTtcblRpbWVPZkRheS5OQU1FID0gXCJUaW1lT2ZEYXlcIjtcblxudmFyIF9hJDI7XG5jbGFzcyBEYXRlVGltZSBleHRlbmRzIFV0ZjhTdHJpbmcge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDMzO1xuICAgIH1cbn1cbl9hJDIgPSBEYXRlVGltZTtcbigoKSA9PiB7XG4gICAgdHlwZVN0b3JlLkRhdGVUaW1lID0gX2EkMjtcbn0pKCk7XG5EYXRlVGltZS5OQU1FID0gXCJEYXRlVGltZVwiO1xuXG52YXIgX2EkMTtcbmNsYXNzIER1cmF0aW9uIGV4dGVuZHMgVXRmOFN0cmluZyB7XG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMzQ7XG4gICAgfVxufVxuX2EkMSA9IER1cmF0aW9uO1xuKCgpID0+IHtcbiAgICB0eXBlU3RvcmUuRHVyYXRpb24gPSBfYSQxO1xufSkoKTtcbkR1cmF0aW9uLk5BTUUgPSBcIkR1cmF0aW9uXCI7XG5cbnZhciBfYTtcbmNsYXNzIFRJTUUgZXh0ZW5kcyBVdGY4U3RyaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAxNDtcbiAgICB9XG59XG5fYSA9IFRJTUU7XG4oKCkgPT4ge1xuICAgIHR5cGVTdG9yZS5USU1FID0gX2E7XG59KSgpO1xuVElNRS5OQU1FID0gXCJUSU1FXCI7XG5cbmNsYXNzIEFueSB7XG4gICAgY29uc3RydWN0b3IoeyBuYW1lID0gRU1QVFlfU1RSSU5HLCBvcHRpb25hbCA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgfVxufVxuXG5jbGFzcyBDaG9pY2UgZXh0ZW5kcyBBbnkge1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgPSBbXSwgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59XG5cbmNsYXNzIFJlcGVhdGVkIGV4dGVuZHMgQW55IHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlID0gbmV3IEFueSgpLCBsb2NhbCA9IGZhbHNlLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XG4gICAgfVxufVxuXG5jbGFzcyBSYXdEYXRhIHtcbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZpZXcuc2xpY2UoKS5idWZmZXI7XG4gICAgfVxuICAgIHNldCBkYXRhKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyBkYXRhID0gRU1QVFlfVklFVyB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5kYXRhVmlldyA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoZGF0YSk7XG4gICAgfVxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xuICAgICAgICBjb25zdCBlbmRMZW5ndGggPSBpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoO1xuICAgICAgICB0aGlzLmRhdGFWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcikuc3ViYXJyYXkoaW5wdXRPZmZzZXQsIGVuZExlbmd0aCk7XG4gICAgICAgIHJldHVybiBlbmRMZW5ndGg7XG4gICAgfVxuICAgIHRvQkVSKF9zaXplT25seSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmlldy5zbGljZSgpLmJ1ZmZlcjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVTY2hlbWEocm9vdCwgaW5wdXREYXRhLCBpbnB1dFNjaGVtYSkge1xuICAgIGlmIChpbnB1dFNjaGVtYSBpbnN0YW5jZW9mIENob2ljZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaW5wdXRTY2hlbWEudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmVTY2hlbWEocm9vdCwgaW5wdXREYXRhLCBlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudmVyaWZpZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2ZXJpZmllZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByb290LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgX3Jlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiB7IGVycm9yOiBcIldyb25nIHZhbHVlcyBmb3IgQ2hvaWNlIHR5cGVcIiB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5oYXNPd25Qcm9wZXJ0eShOQU1FKSlcbiAgICAgICAgICAgICAgICBfcmVzdWx0Lm5hbWUgPSBpbnB1dFNjaGVtYS5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlucHV0U2NoZW1hIGluc3RhbmNlb2YgQW55KSB7XG4gICAgICAgIGlmIChpbnB1dFNjaGVtYS5oYXNPd25Qcm9wZXJ0eShOQU1FKSlcbiAgICAgICAgICAgIHJvb3RbaW5wdXRTY2hlbWEubmFtZV0gPSBpbnB1dERhdGE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJpZmllZDogdHJ1ZSxcbiAgICAgICAgICAgIHJlc3VsdDogcm9vdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKChyb290IGluc3RhbmNlb2YgT2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJXcm9uZyByb290IG9iamVjdFwiIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICgoaW5wdXREYXRhIGluc3RhbmNlb2YgT2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJXcm9uZyBBU04uMSBkYXRhXCIgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKChpbnB1dFNjaGVtYSBpbnN0YW5jZW9mIE9iamVjdCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXG4gICAgICAgICAgICByZXN1bHQ6IHsgZXJyb3I6IFwiV3JvbmcgQVNOLjEgc2NoZW1hXCIgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKChJRF9CTE9DSyBpbiBpbnB1dFNjaGVtYSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXG4gICAgICAgICAgICByZXN1bHQ6IHsgZXJyb3I6IFwiV3JvbmcgQVNOLjEgc2NoZW1hXCIgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKChGUk9NX0JFUiBpbiBpbnB1dFNjaGVtYS5pZEJsb2NrKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJXcm9uZyBBU04uMSBzY2hlbWFcIiB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoKFRPX0JFUiBpbiBpbnB1dFNjaGVtYS5pZEJsb2NrKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJXcm9uZyBBU04uMSBzY2hlbWFcIiB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGVkSWQgPSBpbnB1dFNjaGVtYS5pZEJsb2NrLnRvQkVSKGZhbHNlKTtcbiAgICBpZiAoZW5jb2RlZElkLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJFcnJvciBlbmNvZGluZyBpZEJsb2NrIGZvciBBU04uMSBzY2hlbWFcIiB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVkT2Zmc2V0ID0gaW5wdXRTY2hlbWEuaWRCbG9jay5mcm9tQkVSKGVuY29kZWRJZCwgMCwgZW5jb2RlZElkLmJ5dGVMZW5ndGgpO1xuICAgIGlmIChkZWNvZGVkT2Zmc2V0ID09PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcmVzdWx0OiB7IGVycm9yOiBcIkVycm9yIGRlY29kaW5nIGlkQmxvY2sgZm9yIEFTTi4xIHNjaGVtYVwiIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnB1dFNjaGVtYS5pZEJsb2NrLmhhc093blByb3BlcnR5KFRBR19DTEFTUykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXG4gICAgICAgICAgICByZXN1bHQ6IHsgZXJyb3I6IFwiV3JvbmcgQVNOLjEgc2NoZW1hXCIgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlucHV0U2NoZW1hLmlkQmxvY2sudGFnQ2xhc3MgIT09IGlucHV0RGF0YS5pZEJsb2NrLnRhZ0NsYXNzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXG4gICAgICAgICAgICByZXN1bHQ6IHJvb3QsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnB1dFNjaGVtYS5pZEJsb2NrLmhhc093blByb3BlcnR5KFRBR19OVU1CRVIpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcmVzdWx0OiB7IGVycm9yOiBcIldyb25nIEFTTi4xIHNjaGVtYVwiIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnB1dFNjaGVtYS5pZEJsb2NrLnRhZ051bWJlciAhPT0gaW5wdXREYXRhLmlkQmxvY2sudGFnTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXG4gICAgICAgICAgICByZXN1bHQ6IHJvb3QsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnB1dFNjaGVtYS5pZEJsb2NrLmhhc093blByb3BlcnR5KElTX0NPTlNUUlVDVEVEKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJXcm9uZyBBU04uMSBzY2hlbWFcIiB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW5wdXRTY2hlbWEuaWRCbG9jay5pc0NvbnN0cnVjdGVkICE9PSBpbnB1dERhdGEuaWRCbG9jay5pc0NvbnN0cnVjdGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXG4gICAgICAgICAgICByZXN1bHQ6IHJvb3QsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICghKElTX0hFWF9PTkxZIGluIGlucHV0U2NoZW1hLmlkQmxvY2spKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXG4gICAgICAgICAgICByZXN1bHQ6IHsgZXJyb3I6IFwiV3JvbmcgQVNOLjEgc2NoZW1hXCIgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlucHV0U2NoZW1hLmlkQmxvY2suaXNIZXhPbmx5ICE9PSBpbnB1dERhdGEuaWRCbG9jay5pc0hleE9ubHkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3VsdDogcm9vdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlucHV0U2NoZW1hLmlkQmxvY2suaXNIZXhPbmx5KSB7XG4gICAgICAgIGlmICgoVkFMVUVfSEVYX1ZJRVcgaW4gaW5wdXRTY2hlbWEuaWRCbG9jaykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHsgZXJyb3I6IFwiV3JvbmcgQVNOLjEgc2NoZW1hXCIgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NoZW1hVmlldyA9IGlucHV0U2NoZW1hLmlkQmxvY2sudmFsdWVIZXhWaWV3O1xuICAgICAgICBjb25zdCBhc24xVmlldyA9IGlucHV0RGF0YS5pZEJsb2NrLnZhbHVlSGV4VmlldztcbiAgICAgICAgaWYgKHNjaGVtYVZpZXcubGVuZ3RoICE9PSBhc24xVmlldy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogcm9vdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWFWaWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hVmlld1tpXSAhPT0gYXNuMVZpZXdbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcm9vdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKSB7XG4gICAgICAgIGlucHV0U2NoZW1hLm5hbWUgPSBpbnB1dFNjaGVtYS5uYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csIEVNUFRZX1NUUklORyk7XG4gICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKVxuICAgICAgICAgICAgcm9vdFtpbnB1dFNjaGVtYS5uYW1lXSA9IGlucHV0RGF0YTtcbiAgICB9XG4gICAgaWYgKGlucHV0U2NoZW1hIGluc3RhbmNlb2YgdHlwZVN0b3JlLkNvbnN0cnVjdGVkKSB7XG4gICAgICAgIGxldCBhZG1pc3Npb24gPSAwO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcmVzdWx0OiB7IGVycm9yOiBcIlVua25vd24gZXJyb3JcIiB9LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgbWF4TGVuZ3RoID0gaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChtYXhMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZVswXSBpbnN0YW5jZW9mIFJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoID0gaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyaWZpZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiByb290LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGlucHV0RGF0YS52YWx1ZUJsb2NrLnZhbHVlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICYmIChpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgICAgIGxldCBfb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIF9vcHRpb25hbCA9IF9vcHRpb25hbCAmJiAoaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZVtpXS5vcHRpb25hbCB8fCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoX29wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyaWZpZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcm9vdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYS5uYW1lID0gaW5wdXRTY2hlbWEubmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBFTVBUWV9TVFJJTkcpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcm9vdFtpbnB1dFNjaGVtYS5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvb3QuZXJyb3IgPSBcIkluY29uc2lzdGVudCBvYmplY3QgbGVuZ3RoXCI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJvb3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoaSAtIGFkbWlzc2lvbikgPj0gaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbaV0ub3B0aW9uYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IF9yZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJvb3QsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZXJyb3IgPSBcIkluY29uc2lzdGVudCBsZW5ndGggYmV0d2VlbiBBU04uMSBkYXRhIGFuZCBzY2hlbWFcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0U2NoZW1hLm5hbWUgPSBpbnB1dFNjaGVtYS5uYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csIEVNUFRZX1NUUklORyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRTY2hlbWEubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByb290W2lucHV0U2NoZW1hLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQubmFtZSA9IGlucHV0U2NoZW1hLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbMF0gaW5zdGFuY2VvZiBSZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjb21wYXJlU2NoZW1hKHJvb3QsIGlucHV0RGF0YS52YWx1ZUJsb2NrLnZhbHVlW2ldLCBpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC52ZXJpZmllZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLm9wdGlvbmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkbWlzc2lvbisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRTY2hlbWEubmFtZSA9IGlucHV0U2NoZW1hLm5hbWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgRU1QVFlfU1RSSU5HKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcm9vdFtpbnB1dFNjaGVtYS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKE5BTUUgaW4gaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZVswXSkgJiYgKGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbMF0ubmFtZS5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFycmF5Um9vdCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChMT0NBTCBpbiBpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdKSAmJiAoaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZVswXS5sb2NhbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlSb290ID0gaW5wdXREYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Um9vdCA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFycmF5Um9vdFtpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLm5hbWVdID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Um9vdFtpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLm5hbWVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVJvb3RbaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZVswXS5uYW1lXS5wdXNoKGlucHV0RGF0YS52YWx1ZUJsb2NrLnZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY29tcGFyZVNjaGVtYShyb290LCBpbnB1dERhdGEudmFsdWVCbG9jay52YWx1ZVtpIC0gYWRtaXNzaW9uXSwgaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmVyaWZpZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZVtpXS5vcHRpb25hbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZG1pc3Npb24rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0U2NoZW1hLm5hbWUgPSBpbnB1dFNjaGVtYS5uYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csIEVNUFRZX1NUUklORyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJvb3RbaW5wdXRTY2hlbWEubmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC52ZXJpZmllZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IF9yZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogcm9vdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaW5wdXRTY2hlbWEubmFtZSkge1xuICAgICAgICAgICAgICAgIGlucHV0U2NoZW1hLm5hbWUgPSBpbnB1dFNjaGVtYS5uYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csIEVNUFRZX1NUUklORyk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJvb3RbaW5wdXRTY2hlbWEubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIF9yZXN1bHQubmFtZSA9IGlucHV0U2NoZW1hLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcmlmaWVkOiB0cnVlLFxuICAgICAgICAgICAgcmVzdWx0OiByb290LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW5wdXRTY2hlbWEucHJpbWl0aXZlU2NoZW1hXG4gICAgICAgICYmIChWQUxVRV9IRVhfVklFVyBpbiBpbnB1dERhdGEudmFsdWVCbG9jaykpIHtcbiAgICAgICAgY29uc3QgYXNuMSA9IGxvY2FsRnJvbUJFUihpbnB1dERhdGEudmFsdWVCbG9jay52YWx1ZUhleFZpZXcpO1xuICAgICAgICBpZiAoYXNuMS5vZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBfcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGFzbjEucmVzdWx0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRTY2hlbWEubmFtZSA9IGlucHV0U2NoZW1hLm5hbWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgRU1QVFlfU1RSSU5HKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRTY2hlbWEubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcm9vdFtpbnB1dFNjaGVtYS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdC5uYW1lID0gaW5wdXRTY2hlbWEubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGFyZVNjaGVtYShyb290LCBhc24xLnJlc3VsdCwgaW5wdXRTY2hlbWEucHJpbWl0aXZlU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVyaWZpZWQ6IHRydWUsXG4gICAgICAgIHJlc3VsdDogcm9vdCxcbiAgICB9O1xufVxuZnVuY3Rpb24gdmVyaWZ5U2NoZW1hKGlucHV0QnVmZmVyLCBpbnB1dFNjaGVtYSkge1xuICAgIGlmICgoaW5wdXRTY2hlbWEgaW5zdGFuY2VvZiBPYmplY3QpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcmVzdWx0OiB7IGVycm9yOiBcIldyb25nIEFTTi4xIHNjaGVtYSB0eXBlXCIgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgYXNuMSA9IGxvY2FsRnJvbUJFUihwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGlucHV0QnVmZmVyKSk7XG4gICAgaWYgKGFzbjEub2Zmc2V0ID09PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcmVzdWx0OiBhc24xLnJlc3VsdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhcmVTY2hlbWEoYXNuMS5yZXN1bHQsIGFzbjEucmVzdWx0LCBpbnB1dFNjaGVtYSk7XG59XG5cbmV4cG9ydHMuQW55ID0gQW55O1xuZXhwb3J0cy5CYXNlQmxvY2sgPSBCYXNlQmxvY2s7XG5leHBvcnRzLkJhc2VTdHJpbmdCbG9jayA9IEJhc2VTdHJpbmdCbG9jaztcbmV4cG9ydHMuQml0U3RyaW5nID0gQml0U3RyaW5nO1xuZXhwb3J0cy5CbXBTdHJpbmcgPSBCbXBTdHJpbmc7XG5leHBvcnRzLkJvb2xlYW4gPSBCb29sZWFuO1xuZXhwb3J0cy5DaGFyYWN0ZXJTdHJpbmcgPSBDaGFyYWN0ZXJTdHJpbmc7XG5leHBvcnRzLkNob2ljZSA9IENob2ljZTtcbmV4cG9ydHMuQ29uc3RydWN0ZWQgPSBDb25zdHJ1Y3RlZDtcbmV4cG9ydHMuREFURSA9IERBVEU7XG5leHBvcnRzLkRhdGVUaW1lID0gRGF0ZVRpbWU7XG5leHBvcnRzLkR1cmF0aW9uID0gRHVyYXRpb247XG5leHBvcnRzLkVuZE9mQ29udGVudCA9IEVuZE9mQ29udGVudDtcbmV4cG9ydHMuRW51bWVyYXRlZCA9IEVudW1lcmF0ZWQ7XG5leHBvcnRzLkdlbmVyYWxTdHJpbmcgPSBHZW5lcmFsU3RyaW5nO1xuZXhwb3J0cy5HZW5lcmFsaXplZFRpbWUgPSBHZW5lcmFsaXplZFRpbWU7XG5leHBvcnRzLkdyYXBoaWNTdHJpbmcgPSBHcmFwaGljU3RyaW5nO1xuZXhwb3J0cy5IZXhCbG9jayA9IEhleEJsb2NrO1xuZXhwb3J0cy5JQTVTdHJpbmcgPSBJQTVTdHJpbmc7XG5leHBvcnRzLkludGVnZXIgPSBJbnRlZ2VyO1xuZXhwb3J0cy5OdWxsID0gTnVsbDtcbmV4cG9ydHMuTnVtZXJpY1N0cmluZyA9IE51bWVyaWNTdHJpbmc7XG5leHBvcnRzLk9iamVjdElkZW50aWZpZXIgPSBPYmplY3RJZGVudGlmaWVyO1xuZXhwb3J0cy5PY3RldFN0cmluZyA9IE9jdGV0U3RyaW5nO1xuZXhwb3J0cy5QcmltaXRpdmUgPSBQcmltaXRpdmU7XG5leHBvcnRzLlByaW50YWJsZVN0cmluZyA9IFByaW50YWJsZVN0cmluZztcbmV4cG9ydHMuUmF3RGF0YSA9IFJhd0RhdGE7XG5leHBvcnRzLlJlbGF0aXZlT2JqZWN0SWRlbnRpZmllciA9IFJlbGF0aXZlT2JqZWN0SWRlbnRpZmllcjtcbmV4cG9ydHMuUmVwZWF0ZWQgPSBSZXBlYXRlZDtcbmV4cG9ydHMuU2VxdWVuY2UgPSBTZXF1ZW5jZTtcbmV4cG9ydHMuU2V0ID0gU2V0O1xuZXhwb3J0cy5USU1FID0gVElNRTtcbmV4cG9ydHMuVGVsZXRleFN0cmluZyA9IFRlbGV0ZXhTdHJpbmc7XG5leHBvcnRzLlRpbWVPZkRheSA9IFRpbWVPZkRheTtcbmV4cG9ydHMuVVRDVGltZSA9IFVUQ1RpbWU7XG5leHBvcnRzLlVuaXZlcnNhbFN0cmluZyA9IFVuaXZlcnNhbFN0cmluZztcbmV4cG9ydHMuVXRmOFN0cmluZyA9IFV0ZjhTdHJpbmc7XG5leHBvcnRzLlZhbHVlQmxvY2sgPSBWYWx1ZUJsb2NrO1xuZXhwb3J0cy5WaWRlb3RleFN0cmluZyA9IFZpZGVvdGV4U3RyaW5nO1xuZXhwb3J0cy5WaWV3V3JpdGVyID0gVmlld1dyaXRlcjtcbmV4cG9ydHMuVmlzaWJsZVN0cmluZyA9IFZpc2libGVTdHJpbmc7XG5leHBvcnRzLmNvbXBhcmVTY2hlbWEgPSBjb21wYXJlU2NoZW1hO1xuZXhwb3J0cy5mcm9tQkVSID0gZnJvbUJFUjtcbmV4cG9ydHMudmVyaWZ5U2NoZW1hID0gdmVyaWZ5U2NoZW1hO1xuIl0sIm5hbWVzIjpbInB2dHN1dGlscyIsInJlcXVpcmUiLCJwdnV0aWxzIiwiX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0IiwiZSIsIm4iLCJPYmplY3QiLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZGVmYXVsdCIsImZyZWV6ZSIsInB2dHN1dGlsc19fbmFtZXNwYWNlIiwicHZ1dGlsc19fbmFtZXNwYWNlIiwiYXNzZXJ0QmlnSW50IiwiQmlnSW50IiwiRXJyb3IiLCJjb25jYXQiLCJidWZmZXJzIiwib3V0cHV0TGVuZ3RoIiwicHJldkxlbmd0aCIsImkiLCJsZW5ndGgiLCJidWZmZXIiLCJieXRlTGVuZ3RoIiwicmV0VmlldyIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJjaGVja0J1ZmZlclBhcmFtcyIsImJhc2VCbG9jayIsImlucHV0QnVmZmVyIiwiaW5wdXRPZmZzZXQiLCJpbnB1dExlbmd0aCIsImVycm9yIiwiVmlld1dyaXRlciIsImNvbnN0cnVjdG9yIiwiaXRlbXMiLCJ3cml0ZSIsImJ1ZiIsInB1c2giLCJmaW5hbCIsInBvd2VyczIiLCJkaWdpdHNTdHJpbmciLCJOQU1FIiwiVkFMVUVfSEVYX1ZJRVciLCJJU19IRVhfT05MWSIsIklEX0JMT0NLIiwiVEFHX0NMQVNTIiwiVEFHX05VTUJFUiIsIklTX0NPTlNUUlVDVEVEIiwiRlJPTV9CRVIiLCJUT19CRVIiLCJMT0NBTCIsIkVNUFRZX1NUUklORyIsIkVNUFRZX0JVRkZFUiIsIkFycmF5QnVmZmVyIiwiRU1QVFlfVklFVyIsIkVORF9PRl9DT05URU5UX05BTUUiLCJPQ1RFVF9TVFJJTkdfTkFNRSIsIkJJVF9TVFJJTkdfTkFNRSIsIkhleEJsb2NrIiwiQmFzZUNsYXNzIiwiX2EiLCJTb21lIiwidmFsdWVIZXgiLCJ2YWx1ZUhleFZpZXciLCJzbGljZSIsInZhbHVlIiwiYXJncyIsIl9iIiwicGFyYW1zIiwiaXNIZXhPbmx5IiwiQnVmZmVyU291cmNlQ29udmVydGVyIiwidG9VaW50OEFycmF5IiwiZnJvbUJFUiIsInZpZXciLCJlbmRMZW5ndGgiLCJzdWJhcnJheSIsIndhcm5pbmdzIiwiYmxvY2tMZW5ndGgiLCJ0b0JFUiIsInNpemVPbmx5IiwidG9KU09OIiwiQ29udmVydCIsIlRvSGV4IiwiTG9jYWxCYXNlQmxvY2siLCJibG9ja05hbWUiLCJ2YWx1ZUJlZm9yZURlY29kZSIsInZhbHVlQmVmb3JlRGVjb2RlVmlldyIsIlZhbHVlQmxvY2siLCJfaW5wdXRCdWZmZXIiLCJfaW5wdXRPZmZzZXQiLCJfaW5wdXRMZW5ndGgiLCJUeXBlRXJyb3IiLCJfc2l6ZU9ubHkiLCJfd3JpdGVyIiwiTG9jYWxJZGVudGlmaWNhdGlvbkJsb2NrIiwiaWRCbG9jayIsIl9jIiwiX2QiLCJ0YWdDbGFzcyIsInRhZ051bWJlciIsImlzQ29uc3RydWN0ZWQiLCJmaXJzdE9jdGV0IiwibnVtYmVyIiwiZW5jb2RlZEJ1ZiIsInV0aWxUb0Jhc2UiLCJlbmNvZGVkVmlldyIsInNpemUiLCJjdXJWaWV3IiwiaW5wdXRWaWV3IiwiaW50QnVmZmVyIiwidGFnQ2xhc3NNYXNrIiwidGFnTnVtYmVyTWFzayIsImNvdW50IiwiaW50VGFnTnVtYmVyQnVmZmVyIiwidGFnTnVtYmVyQnVmZmVyTWF4TGVuZ3RoIiwidGVtcEJ1ZmZlclZpZXciLCJ1dGlsRnJvbUJhc2UiLCJMb2NhbExlbmd0aEJsb2NrIiwibGVuQmxvY2siLCJpc0luZGVmaW5pdGVGb3JtIiwibG9uZ0Zvcm1Vc2VkIiwibGVuT2Zmc2V0IiwibGVuZ3RoQnVmZmVyVmlldyIsInJldEJ1ZiIsInR5cGVTdG9yZSIsIkJhc2VCbG9jayIsIm5hbWUiLCJvcHRpb25hbCIsInByaW1pdGl2ZVNjaGVtYSIsInBhcmFtZXRlcnMiLCJ2YWx1ZUJsb2NrVHlwZSIsInZhbHVlQmxvY2siLCJyZXN1bHRPZmZzZXQiLCJ3cml0ZXIiLCJwcmVwYXJlSW5kZWZpbml0ZUZvcm0iLCJpZEJsb2NrQnVmIiwidmFsdWVCbG9ja0J1ZiIsImxlbkJsb2NrQnVmIiwib2JqZWN0IiwidG9TdHJpbmciLCJlbmNvZGluZyIsIm9uQXNjaWlFbmNvZGluZyIsImlzRXF1YWwiLCJvdGhlciIsInRoaXNSYXciLCJvdGhlclJhdyIsImlzRXF1YWxCdWZmZXIiLCJDb25zdHJ1Y3RlZCIsIkJhc2VTdHJpbmdCbG9jayIsImdldFZhbHVlIiwic2V0VmFsdWUiLCJzdHJpbmdWYWx1ZUJsb2NrVHlwZSIsImZyb21TdHJpbmciLCJmcm9tQnVmZmVyIiwiTG9jYWxQcmltaXRpdmVWYWx1ZUJsb2NrIiwiX2EkdyIsIlByaW1pdGl2ZSIsImxvY2FsQ2hhbmdlVHlwZSIsImlucHV0T2JqZWN0IiwibmV3VHlwZSIsIm5ld09iamVjdCIsImxvY2FsRnJvbUJFUiIsImluY29taW5nT2Zmc2V0IiwicmV0dXJuT2JqZWN0Iiwib2Zmc2V0IiwicmVzdWx0IiwibmV3QVNOMVR5cGUiLCJFbmRPZkNvbnRlbnQiLCJCb29sZWFuIiwiSW50ZWdlciIsIkJpdFN0cmluZyIsIk9jdGV0U3RyaW5nIiwiTnVsbCIsIk9iamVjdElkZW50aWZpZXIiLCJFbnVtZXJhdGVkIiwiVXRmOFN0cmluZyIsIlJlbGF0aXZlT2JqZWN0SWRlbnRpZmllciIsIlRJTUUiLCJTZXF1ZW5jZSIsIlNldCIsIk51bWVyaWNTdHJpbmciLCJQcmludGFibGVTdHJpbmciLCJUZWxldGV4U3RyaW5nIiwiVmlkZW90ZXhTdHJpbmciLCJJQTVTdHJpbmciLCJVVENUaW1lIiwiR2VuZXJhbGl6ZWRUaW1lIiwiR3JhcGhpY1N0cmluZyIsIlZpc2libGVTdHJpbmciLCJHZW5lcmFsU3RyaW5nIiwiVW5pdmVyc2FsU3RyaW5nIiwiQ2hhcmFjdGVyU3RyaW5nIiwiQm1wU3RyaW5nIiwiREFURSIsIlRpbWVPZkRheSIsIkRhdGVUaW1lIiwiRHVyYXRpb24iLCJjaGVja0xlbiIsImluZGVmaW5pdGVMZW5ndGgiLCJMb2NhbENvbnN0cnVjdGVkVmFsdWVCbG9jayIsImN1cnJlbnRPZmZzZXQiLCJwb3AiLCJfYSR2IiwidmFsdWVzIiwic3BsaXQiLCJtYXAiLCJvIiwiam9pbiIsIkxvY2FsRW5kT2ZDb250ZW50VmFsdWVCbG9jayIsIm92ZXJyaWRlIiwiX2EkdSIsIl9hJHQiLCJMb2NhbEJvb2xlYW5WYWx1ZUJsb2NrIiwib2N0ZXQiLCJ1dGlsRGVjb2RlVEMiLCJjYWxsIiwiX2EkcyIsIkxvY2FsT2N0ZXRTdHJpbmdWYWx1ZUJsb2NrIiwicHJvdG90eXBlIiwiY3VycmVudEJsb2NrTmFtZSIsIl9hJHIiLCJhc24iLCJhcnJheSIsImNvbnRlbnQiLCJMb2NhbEJpdFN0cmluZ1ZhbHVlQmxvY2siLCJ1bnVzZWRCaXRzIiwiX2EkcSIsImJpdHMiLCJieXRlIiwicGFkU3RhcnQiLCJiaXRzU3RyIiwic3Vic3RyaW5nIiwiX2EkcCIsInZpZXdBZGQiLCJmaXJzdCIsInNlY29uZCIsImMiLCJmaXJzdFZpZXciLCJzZWNvbmRWaWV3IiwiZmlyc3RWaWV3Q29weSIsImZpcnN0Vmlld0NvcHlMZW5ndGgiLCJzZWNvbmRWaWV3Q29weSIsInNlY29uZFZpZXdDb3B5TGVuZ3RoIiwibWF4IiwiY291bnRlciIsInV0aWxDb25jYXRWaWV3IiwicG93ZXIyIiwicCIsImRpZ2l0cyIsIm5ld1ZhbHVlIiwidmlld1N1YiIsImIiLCJMb2NhbEludGVnZXJWYWx1ZUJsb2NrIiwic2V0VmFsdWVIZXgiLCJfdmFsdWVEZWMiLCJ1bmRlZmluZWQiLCJ2YWx1ZURlYyIsInYiLCJ1dGlsRW5jb2RlVEMiLCJmcm9tREVSIiwiZXhwZWN0ZWRMZW5ndGgiLCJ0b0RFUiIsInVwZGF0ZWRWaWV3IiwiZmlyc3RCaXQiLCJiaXROdW1iZXIiLCJjdXJyZW50Qnl0ZSIsImFzbjFWaWV3IiwiZmxhZyIsImJ5dGVOdW1iZXIiLCJjaGFyQXQiLCJfYSRvIiwidG9CaWdJbnQiLCJmcm9tQmlnSW50IiwiYmlnSW50VmFsdWUiLCJoZXgiLCJyZXBsYWNlIiwiRnJvbUhleCIsImZpcnN0SW50Iiwic2Vjb25kSW50IiwicmVzIiwiY29udmVydFRvREVSIiwiaW50ZWdlciIsImNvbnZlcnRGcm9tREVSIiwiX2EkbiIsIkxvY2FsU2lkVmFsdWVCbG9jayIsImlzRmlyc3RTaWQiLCJ0ZW1wVmlldyIsInZhbHVlQmlnSW50IiwiYnl0ZXMiLCJwYXJzZUludCIsImxlbiIsInNpZFZhbHVlIiwiTG9jYWxPYmplY3RJZGVudGlmaWVyVmFsdWVCbG9jayIsInNpZEJsb2NrIiwicmV0QnVmZmVycyIsInZhbHVlQnVmIiwic3RyaW5nIiwicG9zMSIsInBvczIiLCJzaWQiLCJpbmRleE9mIiwicGx1cyIsInBhcnNlZFNJRCIsImlzTmFOIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsInNpZFN0ciIsInNpZEFycmF5IiwiX2EkbSIsIkxvY2FsUmVsYXRpdmVTaWRWYWx1ZUJsb2NrIiwiTG9jYWxSZWxhdGl2ZU9iamVjdElkZW50aWZpZXJWYWx1ZUJsb2NrIiwiX2EkbCIsIl9hJGsiLCJfYSRqIiwiTG9jYWxTdHJpbmdWYWx1ZUJsb2NrIiwiTG9jYWxTaW1wbGVTdHJpbmdWYWx1ZUJsb2NrIiwiTG9jYWxTaW1wbGVTdHJpbmdCbG9jayIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiaW5wdXRTdHJpbmciLCJzdHJMZW4iLCJjaGFyQ29kZUF0IiwiTG9jYWxVdGY4U3RyaW5nVmFsdWVCbG9jayIsIlRvVXRmOFN0cmluZyIsImV4IiwiVG9CaW5hcnkiLCJGcm9tVXRmOFN0cmluZyIsIl9hJGkiLCJMb2NhbEJtcFN0cmluZ1ZhbHVlQmxvY2siLCJUb1V0ZjE2U3RyaW5nIiwiRnJvbVV0ZjE2U3RyaW5nIiwiX2EkaCIsIkxvY2FsVW5pdmVyc2FsU3RyaW5nVmFsdWVCbG9jayIsImNvcHlCdWZmZXIiLCJpc1ZpZXciLCJ2YWx1ZVZpZXciLCJVaW50MzJBcnJheSIsInN0ckxlbmd0aCIsImNvZGVCdWYiLCJjb2RlVmlldyIsImRpZiIsImoiLCJfYSRnIiwiX2EkZiIsIl9hJGUiLCJfYSRkIiwiX2EkYyIsIl9hJGIiLCJfYSRhIiwiX2EkOSIsIl9hJDgiLCJfYSQ3IiwiX2EkNiIsInZhbHVlRGF0ZSIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJmcm9tRGF0ZSIsInRvQnVmZmVyIiwic3RyIiwiaW5wdXREYXRlIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwidG9EYXRlIiwiRGF0ZSIsIlVUQyIsInBhcnNlciIsInBhcnNlckFycmF5IiwiZXhlYyIsIm91dHB1dEFycmF5IiwiQXJyYXkiLCJwYWROdW1iZXIiLCJ0b0lTT1N0cmluZyIsIl9hJDUiLCJtaWxsaXNlY29uZCIsImdldFVUQ01pbGxpc2Vjb25kcyIsInV0Y0RhdGUiLCJpc1VUQyIsInRpbWVTdHJpbmciLCJkYXRlVGltZVN0cmluZyIsImZyYWN0aW9uUGFydCIsImhvdXJEaWZmZXJlbmNlIiwibWludXRlRGlmZmVyZW5jZSIsInZhbHVlT2YiLCJtdWx0aXBsaWVyIiwiZGlmZmVyZW5jZVBvc2l0aW9uIiwiZGlmZmVyZW5jZVN0cmluZyIsImZyYWN0aW9uUG9pbnRQb3NpdGlvbiIsImZyYWN0aW9uUGFydENoZWNrIiwiZnJhY3Rpb25SZXN1bHQiLCJNYXRoIiwiZmxvb3IiLCJ0ZW1wRGF0ZSIsImdldFVUQ0RheSIsIl9hJDQiLCJfYSQzIiwiX2EkMiIsIl9hJDEiLCJBbnkiLCJDaG9pY2UiLCJSZXBlYXRlZCIsImxvY2FsIiwiUmF3RGF0YSIsImRhdGEiLCJkYXRhVmlldyIsImNvbXBhcmVTY2hlbWEiLCJyb290IiwiaW5wdXREYXRhIiwiaW5wdXRTY2hlbWEiLCJlbGVtZW50IiwidmVyaWZpZWQiLCJfcmVzdWx0IiwiaGFzT3duUHJvcGVydHkiLCJlbmNvZGVkSWQiLCJkZWNvZGVkT2Zmc2V0Iiwic2NoZW1hVmlldyIsImFkbWlzc2lvbiIsIm1heExlbmd0aCIsIl9vcHRpb25hbCIsImFycmF5Um9vdCIsImFzbjEiLCJ2ZXJpZnlTY2hlbWEiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/asn1js/build/index.js\n");

/***/ })

};
;